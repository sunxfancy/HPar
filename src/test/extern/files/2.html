
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LLVM 语法参考手册 &mdash; LLVM 3.8 文档</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="LLVM 3.8 文档" href="index.html" />
    <link rel="next" title="Building LLVM with CMake" href="CMake.html" />
    <link rel="prev" title="概述" href="index.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body role="document">
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="CMake.html" title="Building LLVM with CMake"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="概述"
             accesskey="P">上一页</a> |</li>
  <li><a href="http://llvm.org/">LLVM 官网</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">LLVM 中文文档</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="llvm-language-reference-manual">
<h1>LLVM 语法参考手册<a class="headerlink" href="#llvm-language-reference-manual" title="永久链接至标题">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id652">摘要</a></li>
<li><a class="reference internal" href="#introduction" id="id653">简介</a><ul>
<li><a class="reference internal" href="#well-formedness" id="id654">结构良好性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#identifiers" id="id655">标识符</a></li>
<li><a class="reference internal" href="#high-level-structure" id="id656">High Level Structure</a><ul>
<li><a class="reference internal" href="#module-structure" id="id657">Module Structure</a></li>
<li><a class="reference internal" href="#linkage-types" id="id658">Linkage Types</a></li>
<li><a class="reference internal" href="#calling-conventions" id="id659">Calling Conventions</a></li>
<li><a class="reference internal" href="#visibility-styles" id="id660">Visibility Styles</a></li>
<li><a class="reference internal" href="#dll-storage-classes" id="id661">DLL Storage Classes</a></li>
<li><a class="reference internal" href="#thread-local-storage-models" id="id662">Thread Local Storage Models</a></li>
<li><a class="reference internal" href="#structure-types" id="id663">Structure Types</a></li>
<li><a class="reference internal" href="#global-variables" id="id664">Global Variables</a></li>
<li><a class="reference internal" href="#functions" id="id665">Functions</a></li>
<li><a class="reference internal" href="#aliases" id="id666">Aliases</a></li>
<li><a class="reference internal" href="#comdats" id="id667">Comdats</a></li>
<li><a class="reference internal" href="#named-metadata" id="id668">Named Metadata</a></li>
<li><a class="reference internal" href="#parameter-attributes" id="id669">Parameter Attributes</a></li>
<li><a class="reference internal" href="#garbage-collector-strategy-names" id="id670">Garbage Collector Strategy Names</a></li>
<li><a class="reference internal" href="#prefix-data" id="id671">Prefix Data</a></li>
<li><a class="reference internal" href="#prologue-data" id="id672">Prologue Data</a></li>
<li><a class="reference internal" href="#personality-function" id="id673">Personality Function</a></li>
<li><a class="reference internal" href="#attribute-groups" id="id674">Attribute Groups</a></li>
<li><a class="reference internal" href="#function-attributes" id="id675">Function Attributes</a></li>
<li><a class="reference internal" href="#operand-bundles" id="id676">Operand Bundles</a><ul>
<li><a class="reference internal" href="#deoptimization-operand-bundles" id="id677">Deoptimization Operand Bundles</a></li>
<li><a class="reference internal" href="#funclet-operand-bundles" id="id678">Funclet Operand Bundles</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-level-inline-assembly" id="id679">Module-Level Inline Assembly</a></li>
<li><a class="reference internal" href="#data-layout" id="id680">Data Layout</a></li>
<li><a class="reference internal" href="#target-triple" id="id681">Target Triple</a></li>
<li><a class="reference internal" href="#pointer-aliasing-rules" id="id682">Pointer Aliasing Rules</a></li>
<li><a class="reference internal" href="#volatile-memory-accesses" id="id683">Volatile Memory Accesses</a></li>
<li><a class="reference internal" href="#memory-model-for-concurrent-operations" id="id684">Memory Model for Concurrent Operations</a></li>
<li><a class="reference internal" href="#atomic-memory-ordering-constraints" id="id685">Atomic Memory Ordering Constraints</a></li>
<li><a class="reference internal" href="#fast-math-flags" id="id686">Fast-Math Flags</a></li>
<li><a class="reference internal" href="#use-list-order-directives" id="id687">Use-list Order Directives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-system" id="id688">Type System</a><ul>
<li><a class="reference internal" href="#void-type" id="id689">Void Type</a></li>
<li><a class="reference internal" href="#function-type" id="id690">Function Type</a></li>
<li><a class="reference internal" href="#first-class-types" id="id691">First Class Types</a><ul>
<li><a class="reference internal" href="#single-value-types" id="id692">Single Value Types</a><ul>
<li><a class="reference internal" href="#integer-type" id="id693">Integer Type</a></li>
<li><a class="reference internal" href="#floating-point-types" id="id694">Floating Point Types</a></li>
<li><a class="reference internal" href="#x86-mmx-type" id="id695">X86_mmx Type</a></li>
<li><a class="reference internal" href="#pointer-type" id="id696">Pointer Type</a></li>
<li><a class="reference internal" href="#vector-type" id="id697">Vector Type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#label-type" id="id698">Label Type</a></li>
<li><a class="reference internal" href="#token-type" id="id699">Token Type</a></li>
<li><a class="reference internal" href="#metadata-type" id="id700">Metadata Type</a></li>
<li><a class="reference internal" href="#aggregate-types" id="id701">Aggregate Types</a><ul>
<li><a class="reference internal" href="#array-type" id="id702">Array Type</a></li>
<li><a class="reference internal" href="#structure-type" id="id703">Structure Type</a></li>
<li><a class="reference internal" href="#opaque-structure-types" id="id704">Opaque Structure Types</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#constants" id="id705">Constants</a><ul>
<li><a class="reference internal" href="#simple-constants" id="id706">Simple Constants</a></li>
<li><a class="reference internal" href="#complex-constants" id="id707">Complex Constants</a></li>
<li><a class="reference internal" href="#global-variable-and-function-addresses" id="id708">Global Variable and Function Addresses</a></li>
<li><a class="reference internal" href="#undefined-values" id="id709">Undefined Values</a></li>
<li><a class="reference internal" href="#poison-values" id="id710">Poison Values</a></li>
<li><a class="reference internal" href="#addresses-of-basic-blocks" id="id711">Addresses of Basic Blocks</a></li>
<li><a class="reference internal" href="#constant-expressions" id="id712">Constant Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-values" id="id713">Other Values</a><ul>
<li><a class="reference internal" href="#inline-assembler-expressions" id="id714">Inline Assembler Expressions</a><ul>
<li><a class="reference internal" href="#inline-asm-constraint-string" id="id715">Inline Asm Constraint String</a><ul>
<li><a class="reference internal" href="#output-constraints" id="id716">Output constraints</a></li>
<li><a class="reference internal" href="#input-constraints" id="id717">Input constraints</a></li>
<li><a class="reference internal" href="#indirect-inputs-and-outputs" id="id718">Indirect inputs and outputs</a></li>
<li><a class="reference internal" href="#clobber-constraints" id="id719">Clobber constraints</a></li>
<li><a class="reference internal" href="#constraint-codes" id="id720">Constraint Codes</a></li>
<li><a class="reference internal" href="#supported-constraint-code-list" id="id721">Supported Constraint Code List</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asm-template-argument-modifiers" id="id722">Asm template argument modifiers</a></li>
<li><a class="reference internal" href="#inline-asm-metadata" id="id723">Inline Asm Metadata</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#metadata" id="id724">Metadata</a><ul>
<li><a class="reference internal" href="#metadata-nodes-and-metadata-strings" id="id725">Metadata Nodes and Metadata Strings</a><ul>
<li><a class="reference internal" href="#specialized-metadata-nodes" id="id726">Specialized Metadata Nodes</a><ul>
<li><a class="reference internal" href="#dicompileunit" id="id727">DICompileUnit</a></li>
<li><a class="reference internal" href="#difile" id="id728">DIFile</a></li>
<li><a class="reference internal" href="#dibasictype" id="id729">DIBasicType</a></li>
<li><a class="reference internal" href="#disubroutinetype" id="id730">DISubroutineType</a></li>
<li><a class="reference internal" href="#diderivedtype" id="id731">DIDerivedType</a></li>
<li><a class="reference internal" href="#dicompositetype" id="id732">DICompositeType</a></li>
<li><a class="reference internal" href="#disubrange" id="id733">DISubrange</a></li>
<li><a class="reference internal" href="#dienumerator" id="id734">DIEnumerator</a></li>
<li><a class="reference internal" href="#ditemplatetypeparameter" id="id735">DITemplateTypeParameter</a></li>
<li><a class="reference internal" href="#ditemplatevalueparameter" id="id736">DITemplateValueParameter</a></li>
<li><a class="reference internal" href="#dinamespace" id="id737">DINamespace</a></li>
<li><a class="reference internal" href="#diglobalvariable" id="id738">DIGlobalVariable</a></li>
<li><a class="reference internal" href="#disubprogram" id="id739">DISubprogram</a></li>
<li><a class="reference internal" href="#dilexicalblock" id="id740">DILexicalBlock</a></li>
<li><a class="reference internal" href="#dilexicalblockfile" id="id741">DILexicalBlockFile</a></li>
<li><a class="reference internal" href="#dilocation" id="id742">DILocation</a></li>
<li><a class="reference internal" href="#dilocalvariable" id="id743">DILocalVariable</a></li>
<li><a class="reference internal" href="#diexpression" id="id744">DIExpression</a></li>
<li><a class="reference internal" href="#diobjcproperty" id="id745">DIObjCProperty</a></li>
<li><a class="reference internal" href="#diimportedentity" id="id746">DIImportedEntity</a></li>
<li><a class="reference internal" href="#dimacro" id="id747">DIMacro</a></li>
<li><a class="reference internal" href="#dimacrofile" id="id748">DIMacroFile</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tbaa-metadata" id="id749">&#8216;<code class="docutils literal"><span class="pre">tbaa</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#tbaa-struct-metadata" id="id750">&#8216;<code class="docutils literal"><span class="pre">tbaa.struct</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#noalias-and-alias-scope-metadata" id="id751">&#8216;<code class="docutils literal"><span class="pre">noalias</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">alias.scope</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#fpmath-metadata" id="id752">&#8216;<code class="docutils literal"><span class="pre">fpmath</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#range-metadata" id="id753">&#8216;<code class="docutils literal"><span class="pre">range</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#unpredictable-metadata" id="id754">&#8216;<code class="docutils literal"><span class="pre">unpredictable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop" id="id755">&#8216;<code class="docutils literal"><span class="pre">llvm.loop</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-loop-vectorize-and-llvm-loop-interleave" id="id756">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-loop-interleave-count-metadata" id="id757">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-vectorize-enable-metadata" id="id758">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.enable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-vectorize-width-metadata" id="id759">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll" id="id760">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-count-metadata" id="id761">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-disable-metadata" id="id762">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.disable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-runtime-disable-metadata" id="id763">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.runtime.disable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-enable-metadata" id="id764">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.enable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-full-metadata" id="id765">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.full</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-mem" id="id766">&#8216;<code class="docutils literal"><span class="pre">llvm.mem</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-mem-parallel-loop-access-metadata" id="id767">&#8216;<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-bitsets" id="id768">&#8216;<code class="docutils literal"><span class="pre">llvm.bitsets</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#invariant-group-metadata" id="id769">&#8216;<code class="docutils literal"><span class="pre">invariant.group</span></code>&#8216; Metadata</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-flags-metadata" id="id770">Module Flags Metadata</a><ul>
<li><a class="reference internal" href="#objective-c-garbage-collection-module-flags-metadata" id="id771">Objective-C Garbage Collection Module Flags Metadata</a></li>
<li><a class="reference internal" href="#automatic-linker-flags-module-flags-metadata" id="id772">Automatic Linker Flags Module Flags Metadata</a></li>
<li><a class="reference internal" href="#c-type-width-module-flags-metadata" id="id773">C type width Module Flags Metadata</a></li>
</ul>
</li>
<li><a class="reference internal" href="#intrinsic-global-variables" id="id774">Intrinsic Global Variables</a><ul>
<li><a class="reference internal" href="#the-llvm-used-global-variable" id="id775">The &#8216;<code class="docutils literal"><span class="pre">llvm.used</span></code>&#8216; Global Variable</a></li>
<li><a class="reference internal" href="#the-llvm-compiler-used-global-variable" id="id776">The &#8216;<code class="docutils literal"><span class="pre">llvm.compiler.used</span></code>&#8216; Global Variable</a></li>
<li><a class="reference internal" href="#the-llvm-global-ctors-global-variable" id="id777">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_ctors</span></code>&#8216; Global Variable</a></li>
<li><a class="reference internal" href="#the-llvm-global-dtors-global-variable" id="id778">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_dtors</span></code>&#8216; Global Variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instruction-reference" id="id779">Instruction Reference</a><ul>
<li><a class="reference internal" href="#terminator-instructions" id="id780">Terminator Instructions</a><ul>
<li><a class="reference internal" href="#ret-instruction" id="id781">&#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#syntax" id="id782">Syntax:</a></li>
<li><a class="reference internal" href="#overview" id="id783">Overview:</a></li>
<li><a class="reference internal" href="#arguments" id="id784">Arguments:</a></li>
<li><a class="reference internal" href="#semantics" id="id785">Semantics:</a></li>
<li><a class="reference internal" href="#example" id="id786">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#br-instruction" id="id787">&#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id19" id="id788">Syntax:</a></li>
<li><a class="reference internal" href="#id20" id="id789">Overview:</a></li>
<li><a class="reference internal" href="#id21" id="id790">Arguments:</a></li>
<li><a class="reference internal" href="#id22" id="id791">Semantics:</a></li>
<li><a class="reference internal" href="#id23" id="id792">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#switch-instruction" id="id793">&#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id24" id="id794">Syntax:</a></li>
<li><a class="reference internal" href="#id25" id="id795">Overview:</a></li>
<li><a class="reference internal" href="#id26" id="id796">Arguments:</a></li>
<li><a class="reference internal" href="#id27" id="id797">Semantics:</a></li>
<li><a class="reference internal" href="#implementation" id="id798">Implementation:</a></li>
<li><a class="reference internal" href="#id28" id="id799">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indirectbr-instruction" id="id800">&#8216;<code class="docutils literal"><span class="pre">indirectbr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id29" id="id801">Syntax:</a></li>
<li><a class="reference internal" href="#id30" id="id802">Overview:</a></li>
<li><a class="reference internal" href="#id31" id="id803">Arguments:</a></li>
<li><a class="reference internal" href="#id32" id="id804">Semantics:</a></li>
<li><a class="reference internal" href="#id33" id="id805">Implementation:</a></li>
<li><a class="reference internal" href="#id34" id="id806">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoke-instruction" id="id807">&#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id35" id="id808">Syntax:</a></li>
<li><a class="reference internal" href="#id36" id="id809">Overview:</a></li>
<li><a class="reference internal" href="#id37" id="id810">Arguments:</a></li>
<li><a class="reference internal" href="#id38" id="id811">Semantics:</a></li>
<li><a class="reference internal" href="#id39" id="id812">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resume-instruction" id="id813">&#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id40" id="id814">Syntax:</a></li>
<li><a class="reference internal" href="#id41" id="id815">Overview:</a></li>
<li><a class="reference internal" href="#id42" id="id816">Arguments:</a></li>
<li><a class="reference internal" href="#id43" id="id817">Semantics:</a></li>
<li><a class="reference internal" href="#id44" id="id818">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#catchswitch-instruction" id="id819">&#8216;<code class="docutils literal"><span class="pre">catchswitch</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id45" id="id820">Syntax:</a></li>
<li><a class="reference internal" href="#id46" id="id821">Overview:</a></li>
<li><a class="reference internal" href="#id47" id="id822">Arguments:</a></li>
<li><a class="reference internal" href="#id48" id="id823">Semantics:</a></li>
<li><a class="reference internal" href="#id49" id="id824">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#catchret-instruction" id="id825">&#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id50" id="id826">Syntax:</a></li>
<li><a class="reference internal" href="#id51" id="id827">Overview:</a></li>
<li><a class="reference internal" href="#id52" id="id828">Arguments:</a></li>
<li><a class="reference internal" href="#id53" id="id829">Semantics:</a></li>
<li><a class="reference internal" href="#id54" id="id830">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cleanupret-instruction" id="id831">&#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id55" id="id832">Syntax:</a></li>
<li><a class="reference internal" href="#id56" id="id833">Overview:</a></li>
<li><a class="reference internal" href="#id57" id="id834">Arguments:</a></li>
<li><a class="reference internal" href="#id60" id="id835">Semantics:</a></li>
<li><a class="reference internal" href="#id61" id="id836">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unreachable-instruction" id="id837">&#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id62" id="id838">Syntax:</a></li>
<li><a class="reference internal" href="#id63" id="id839">Overview:</a></li>
<li><a class="reference internal" href="#id64" id="id840">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#binary-operations" id="id841">Binary Operations</a><ul>
<li><a class="reference internal" href="#add-instruction" id="id842">&#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id65" id="id843">Syntax:</a></li>
<li><a class="reference internal" href="#id66" id="id844">Overview:</a></li>
<li><a class="reference internal" href="#id67" id="id845">Arguments:</a></li>
<li><a class="reference internal" href="#id68" id="id846">Semantics:</a></li>
<li><a class="reference internal" href="#id69" id="id847">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fadd-instruction" id="id848">&#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id70" id="id849">Syntax:</a></li>
<li><a class="reference internal" href="#id71" id="id850">Overview:</a></li>
<li><a class="reference internal" href="#id72" id="id851">Arguments:</a></li>
<li><a class="reference internal" href="#id73" id="id852">Semantics:</a></li>
<li><a class="reference internal" href="#id74" id="id853">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sub-instruction" id="id854">&#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id75" id="id855">Syntax:</a></li>
<li><a class="reference internal" href="#id76" id="id856">Overview:</a></li>
<li><a class="reference internal" href="#id77" id="id857">Arguments:</a></li>
<li><a class="reference internal" href="#id78" id="id858">Semantics:</a></li>
<li><a class="reference internal" href="#id79" id="id859">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fsub-instruction" id="id860">&#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id80" id="id861">Syntax:</a></li>
<li><a class="reference internal" href="#id81" id="id862">Overview:</a></li>
<li><a class="reference internal" href="#id82" id="id863">Arguments:</a></li>
<li><a class="reference internal" href="#id83" id="id864">Semantics:</a></li>
<li><a class="reference internal" href="#id84" id="id865">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mul-instruction" id="id866">&#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id85" id="id867">Syntax:</a></li>
<li><a class="reference internal" href="#id86" id="id868">Overview:</a></li>
<li><a class="reference internal" href="#id87" id="id869">Arguments:</a></li>
<li><a class="reference internal" href="#id88" id="id870">Semantics:</a></li>
<li><a class="reference internal" href="#id89" id="id871">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fmul-instruction" id="id872">&#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id90" id="id873">Syntax:</a></li>
<li><a class="reference internal" href="#id91" id="id874">Overview:</a></li>
<li><a class="reference internal" href="#id92" id="id875">Arguments:</a></li>
<li><a class="reference internal" href="#id93" id="id876">Semantics:</a></li>
<li><a class="reference internal" href="#id94" id="id877">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#udiv-instruction" id="id878">&#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id95" id="id879">Syntax:</a></li>
<li><a class="reference internal" href="#id96" id="id880">Overview:</a></li>
<li><a class="reference internal" href="#id97" id="id881">Arguments:</a></li>
<li><a class="reference internal" href="#id98" id="id882">Semantics:</a></li>
<li><a class="reference internal" href="#id99" id="id883">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sdiv-instruction" id="id884">&#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id100" id="id885">Syntax:</a></li>
<li><a class="reference internal" href="#id101" id="id886">Overview:</a></li>
<li><a class="reference internal" href="#id102" id="id887">Arguments:</a></li>
<li><a class="reference internal" href="#id103" id="id888">Semantics:</a></li>
<li><a class="reference internal" href="#id104" id="id889">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fdiv-instruction" id="id890">&#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id105" id="id891">Syntax:</a></li>
<li><a class="reference internal" href="#id106" id="id892">Overview:</a></li>
<li><a class="reference internal" href="#id107" id="id893">Arguments:</a></li>
<li><a class="reference internal" href="#id108" id="id894">Semantics:</a></li>
<li><a class="reference internal" href="#id109" id="id895">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#urem-instruction" id="id896">&#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id110" id="id897">Syntax:</a></li>
<li><a class="reference internal" href="#id111" id="id898">Overview:</a></li>
<li><a class="reference internal" href="#id112" id="id899">Arguments:</a></li>
<li><a class="reference internal" href="#id113" id="id900">Semantics:</a></li>
<li><a class="reference internal" href="#id114" id="id901">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#srem-instruction" id="id902">&#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id115" id="id903">Syntax:</a></li>
<li><a class="reference internal" href="#id116" id="id904">Overview:</a></li>
<li><a class="reference internal" href="#id117" id="id905">Arguments:</a></li>
<li><a class="reference internal" href="#id118" id="id906">Semantics:</a></li>
<li><a class="reference internal" href="#id119" id="id907">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frem-instruction" id="id908">&#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id120" id="id909">Syntax:</a></li>
<li><a class="reference internal" href="#id121" id="id910">Overview:</a></li>
<li><a class="reference internal" href="#id122" id="id911">Arguments:</a></li>
<li><a class="reference internal" href="#id123" id="id912">Semantics:</a></li>
<li><a class="reference internal" href="#id124" id="id913">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-binary-operations" id="id914">Bitwise Binary Operations</a><ul>
<li><a class="reference internal" href="#shl-instruction" id="id915">&#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id125" id="id916">Syntax:</a></li>
<li><a class="reference internal" href="#id126" id="id917">Overview:</a></li>
<li><a class="reference internal" href="#id127" id="id918">Arguments:</a></li>
<li><a class="reference internal" href="#id128" id="id919">Semantics:</a></li>
<li><a class="reference internal" href="#id129" id="id920">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lshr-instruction" id="id921">&#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id130" id="id922">Syntax:</a></li>
<li><a class="reference internal" href="#id131" id="id923">Overview:</a></li>
<li><a class="reference internal" href="#id132" id="id924">Arguments:</a></li>
<li><a class="reference internal" href="#id133" id="id925">Semantics:</a></li>
<li><a class="reference internal" href="#id134" id="id926">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ashr-instruction" id="id927">&#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id135" id="id928">Syntax:</a></li>
<li><a class="reference internal" href="#id136" id="id929">Overview:</a></li>
<li><a class="reference internal" href="#id137" id="id930">Arguments:</a></li>
<li><a class="reference internal" href="#id138" id="id931">Semantics:</a></li>
<li><a class="reference internal" href="#id139" id="id932">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#and-instruction" id="id933">&#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id140" id="id934">Syntax:</a></li>
<li><a class="reference internal" href="#id141" id="id935">Overview:</a></li>
<li><a class="reference internal" href="#id142" id="id936">Arguments:</a></li>
<li><a class="reference internal" href="#id143" id="id937">Semantics:</a></li>
<li><a class="reference internal" href="#id144" id="id938">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-instruction" id="id939">&#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id145" id="id940">Syntax:</a></li>
<li><a class="reference internal" href="#id146" id="id941">Overview:</a></li>
<li><a class="reference internal" href="#id147" id="id942">Arguments:</a></li>
<li><a class="reference internal" href="#id148" id="id943">Semantics:</a></li>
<li><a class="reference internal" href="#id149" id="id944">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xor-instruction" id="id945">&#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id150" id="id946">Syntax:</a></li>
<li><a class="reference internal" href="#id151" id="id947">Overview:</a></li>
<li><a class="reference internal" href="#id152" id="id948">Arguments:</a></li>
<li><a class="reference internal" href="#id153" id="id949">Semantics:</a></li>
<li><a class="reference internal" href="#id154" id="id950">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#vector-operations" id="id951">Vector Operations</a><ul>
<li><a class="reference internal" href="#extractelement-instruction" id="id952">&#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id155" id="id953">Syntax:</a></li>
<li><a class="reference internal" href="#id156" id="id954">Overview:</a></li>
<li><a class="reference internal" href="#id157" id="id955">Arguments:</a></li>
<li><a class="reference internal" href="#id158" id="id956">Semantics:</a></li>
<li><a class="reference internal" href="#id159" id="id957">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#insertelement-instruction" id="id958">&#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id160" id="id959">Syntax:</a></li>
<li><a class="reference internal" href="#id161" id="id960">Overview:</a></li>
<li><a class="reference internal" href="#id162" id="id961">Arguments:</a></li>
<li><a class="reference internal" href="#id163" id="id962">Semantics:</a></li>
<li><a class="reference internal" href="#id164" id="id963">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shufflevector-instruction" id="id964">&#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id165" id="id965">Syntax:</a></li>
<li><a class="reference internal" href="#id166" id="id966">Overview:</a></li>
<li><a class="reference internal" href="#id167" id="id967">Arguments:</a></li>
<li><a class="reference internal" href="#id168" id="id968">Semantics:</a></li>
<li><a class="reference internal" href="#id169" id="id969">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#aggregate-operations" id="id970">Aggregate Operations</a><ul>
<li><a class="reference internal" href="#extractvalue-instruction" id="id971">&#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id170" id="id972">Syntax:</a></li>
<li><a class="reference internal" href="#id171" id="id973">Overview:</a></li>
<li><a class="reference internal" href="#id172" id="id974">Arguments:</a></li>
<li><a class="reference internal" href="#id173" id="id975">Semantics:</a></li>
<li><a class="reference internal" href="#id174" id="id976">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#insertvalue-instruction" id="id977">&#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id175" id="id978">Syntax:</a></li>
<li><a class="reference internal" href="#id176" id="id979">Overview:</a></li>
<li><a class="reference internal" href="#id177" id="id980">Arguments:</a></li>
<li><a class="reference internal" href="#id178" id="id981">Semantics:</a></li>
<li><a class="reference internal" href="#id179" id="id982">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#memory-access-and-addressing-operations" id="id983">Memory Access and Addressing Operations</a><ul>
<li><a class="reference internal" href="#alloca-instruction" id="id984">&#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id180" id="id985">Syntax:</a></li>
<li><a class="reference internal" href="#id181" id="id986">Overview:</a></li>
<li><a class="reference internal" href="#id182" id="id987">Arguments:</a></li>
<li><a class="reference internal" href="#id183" id="id988">Semantics:</a></li>
<li><a class="reference internal" href="#id184" id="id989">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#load-instruction" id="id990">&#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id185" id="id991">Syntax:</a></li>
<li><a class="reference internal" href="#id186" id="id992">Overview:</a></li>
<li><a class="reference internal" href="#id187" id="id993">Arguments:</a></li>
<li><a class="reference internal" href="#id188" id="id994">Semantics:</a></li>
<li><a class="reference internal" href="#id189" id="id995">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#store-instruction" id="id996">&#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id190" id="id997">Syntax:</a></li>
<li><a class="reference internal" href="#id191" id="id998">Overview:</a></li>
<li><a class="reference internal" href="#id192" id="id999">Arguments:</a></li>
<li><a class="reference internal" href="#id193" id="id1000">Semantics:</a></li>
<li><a class="reference internal" href="#id194" id="id1001">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fence-instruction" id="id1002">&#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id195" id="id1003">Syntax:</a></li>
<li><a class="reference internal" href="#id196" id="id1004">Overview:</a></li>
<li><a class="reference internal" href="#id197" id="id1005">Arguments:</a></li>
<li><a class="reference internal" href="#id198" id="id1006">Semantics:</a></li>
<li><a class="reference internal" href="#id199" id="id1007">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cmpxchg-instruction" id="id1008">&#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id200" id="id1009">Syntax:</a></li>
<li><a class="reference internal" href="#id201" id="id1010">Overview:</a></li>
<li><a class="reference internal" href="#id202" id="id1011">Arguments:</a></li>
<li><a class="reference internal" href="#id203" id="id1012">Semantics:</a></li>
<li><a class="reference internal" href="#id204" id="id1013">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#atomicrmw-instruction" id="id1014">&#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id205" id="id1015">Syntax:</a></li>
<li><a class="reference internal" href="#id206" id="id1016">Overview:</a></li>
<li><a class="reference internal" href="#id207" id="id1017">Arguments:</a></li>
<li><a class="reference internal" href="#id208" id="id1018">Semantics:</a></li>
<li><a class="reference internal" href="#id209" id="id1019">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#getelementptr-instruction" id="id1020">&#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id210" id="id1021">Syntax:</a></li>
<li><a class="reference internal" href="#id211" id="id1022">Overview:</a></li>
<li><a class="reference internal" href="#id212" id="id1023">Arguments:</a></li>
<li><a class="reference internal" href="#id213" id="id1024">Semantics:</a></li>
<li><a class="reference internal" href="#id214" id="id1025">Example:</a></li>
<li><a class="reference internal" href="#vector-of-pointers" id="id1026">Vector of pointers:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conversion-operations" id="id1027">Conversion Operations</a><ul>
<li><a class="reference internal" href="#trunc-to-instruction" id="id1028">&#8216;<code class="docutils literal"><span class="pre">trunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id215" id="id1029">Syntax:</a></li>
<li><a class="reference internal" href="#id216" id="id1030">Overview:</a></li>
<li><a class="reference internal" href="#id217" id="id1031">Arguments:</a></li>
<li><a class="reference internal" href="#id218" id="id1032">Semantics:</a></li>
<li><a class="reference internal" href="#id219" id="id1033">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#zext-to-instruction" id="id1034">&#8216;<code class="docutils literal"><span class="pre">zext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id220" id="id1035">Syntax:</a></li>
<li><a class="reference internal" href="#id221" id="id1036">Overview:</a></li>
<li><a class="reference internal" href="#id222" id="id1037">Arguments:</a></li>
<li><a class="reference internal" href="#id223" id="id1038">Semantics:</a></li>
<li><a class="reference internal" href="#id224" id="id1039">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sext-to-instruction" id="id1040">&#8216;<code class="docutils literal"><span class="pre">sext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id225" id="id1041">Syntax:</a></li>
<li><a class="reference internal" href="#id226" id="id1042">Overview:</a></li>
<li><a class="reference internal" href="#id227" id="id1043">Arguments:</a></li>
<li><a class="reference internal" href="#id228" id="id1044">Semantics:</a></li>
<li><a class="reference internal" href="#id229" id="id1045">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fptrunc-to-instruction" id="id1046">&#8216;<code class="docutils literal"><span class="pre">fptrunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id230" id="id1047">Syntax:</a></li>
<li><a class="reference internal" href="#id231" id="id1048">Overview:</a></li>
<li><a class="reference internal" href="#id232" id="id1049">Arguments:</a></li>
<li><a class="reference internal" href="#id233" id="id1050">Semantics:</a></li>
<li><a class="reference internal" href="#id234" id="id1051">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fpext-to-instruction" id="id1052">&#8216;<code class="docutils literal"><span class="pre">fpext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id235" id="id1053">Syntax:</a></li>
<li><a class="reference internal" href="#id236" id="id1054">Overview:</a></li>
<li><a class="reference internal" href="#id237" id="id1055">Arguments:</a></li>
<li><a class="reference internal" href="#id238" id="id1056">Semantics:</a></li>
<li><a class="reference internal" href="#id239" id="id1057">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fptoui-to-instruction" id="id1058">&#8216;<code class="docutils literal"><span class="pre">fptoui</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id240" id="id1059">Syntax:</a></li>
<li><a class="reference internal" href="#id241" id="id1060">Overview:</a></li>
<li><a class="reference internal" href="#id242" id="id1061">Arguments:</a></li>
<li><a class="reference internal" href="#id243" id="id1062">Semantics:</a></li>
<li><a class="reference internal" href="#id244" id="id1063">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fptosi-to-instruction" id="id1064">&#8216;<code class="docutils literal"><span class="pre">fptosi</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id245" id="id1065">Syntax:</a></li>
<li><a class="reference internal" href="#id246" id="id1066">Overview:</a></li>
<li><a class="reference internal" href="#id247" id="id1067">Arguments:</a></li>
<li><a class="reference internal" href="#id248" id="id1068">Semantics:</a></li>
<li><a class="reference internal" href="#id249" id="id1069">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uitofp-to-instruction" id="id1070">&#8216;<code class="docutils literal"><span class="pre">uitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id250" id="id1071">Syntax:</a></li>
<li><a class="reference internal" href="#id251" id="id1072">Overview:</a></li>
<li><a class="reference internal" href="#id252" id="id1073">Arguments:</a></li>
<li><a class="reference internal" href="#id253" id="id1074">Semantics:</a></li>
<li><a class="reference internal" href="#id254" id="id1075">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sitofp-to-instruction" id="id1076">&#8216;<code class="docutils literal"><span class="pre">sitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id255" id="id1077">Syntax:</a></li>
<li><a class="reference internal" href="#id256" id="id1078">Overview:</a></li>
<li><a class="reference internal" href="#id257" id="id1079">Arguments:</a></li>
<li><a class="reference internal" href="#id258" id="id1080">Semantics:</a></li>
<li><a class="reference internal" href="#id259" id="id1081">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ptrtoint-to-instruction" id="id1082">&#8216;<code class="docutils literal"><span class="pre">ptrtoint</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id260" id="id1083">Syntax:</a></li>
<li><a class="reference internal" href="#id261" id="id1084">Overview:</a></li>
<li><a class="reference internal" href="#id262" id="id1085">Arguments:</a></li>
<li><a class="reference internal" href="#id263" id="id1086">Semantics:</a></li>
<li><a class="reference internal" href="#id264" id="id1087">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inttoptr-to-instruction" id="id1088">&#8216;<code class="docutils literal"><span class="pre">inttoptr</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id265" id="id1089">Syntax:</a></li>
<li><a class="reference internal" href="#id266" id="id1090">Overview:</a></li>
<li><a class="reference internal" href="#id267" id="id1091">Arguments:</a></li>
<li><a class="reference internal" href="#id268" id="id1092">Semantics:</a></li>
<li><a class="reference internal" href="#id269" id="id1093">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitcast-to-instruction" id="id1094">&#8216;<code class="docutils literal"><span class="pre">bitcast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id270" id="id1095">Syntax:</a></li>
<li><a class="reference internal" href="#id271" id="id1096">Overview:</a></li>
<li><a class="reference internal" href="#id272" id="id1097">Arguments:</a></li>
<li><a class="reference internal" href="#id273" id="id1098">Semantics:</a></li>
<li><a class="reference internal" href="#id274" id="id1099">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#addrspacecast-to-instruction" id="id1100">&#8216;<code class="docutils literal"><span class="pre">addrspacecast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id275" id="id1101">Syntax:</a></li>
<li><a class="reference internal" href="#id276" id="id1102">Overview:</a></li>
<li><a class="reference internal" href="#id277" id="id1103">Arguments:</a></li>
<li><a class="reference internal" href="#id278" id="id1104">Semantics:</a></li>
<li><a class="reference internal" href="#id279" id="id1105">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#other-operations" id="id1106">Other Operations</a><ul>
<li><a class="reference internal" href="#icmp-instruction" id="id1107">&#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id280" id="id1108">Syntax:</a></li>
<li><a class="reference internal" href="#id281" id="id1109">Overview:</a></li>
<li><a class="reference internal" href="#id282" id="id1110">Arguments:</a></li>
<li><a class="reference internal" href="#id283" id="id1111">Semantics:</a></li>
<li><a class="reference internal" href="#id284" id="id1112">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fcmp-instruction" id="id1113">&#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id285" id="id1114">Syntax:</a></li>
<li><a class="reference internal" href="#id286" id="id1115">Overview:</a></li>
<li><a class="reference internal" href="#id287" id="id1116">Arguments:</a></li>
<li><a class="reference internal" href="#id288" id="id1117">Semantics:</a></li>
<li><a class="reference internal" href="#id289" id="id1118">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phi-instruction" id="id1119">&#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id290" id="id1120">Syntax:</a></li>
<li><a class="reference internal" href="#id291" id="id1121">Overview:</a></li>
<li><a class="reference internal" href="#id292" id="id1122">Arguments:</a></li>
<li><a class="reference internal" href="#id293" id="id1123">Semantics:</a></li>
<li><a class="reference internal" href="#id294" id="id1124">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#select-instruction" id="id1125">&#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id295" id="id1126">Syntax:</a></li>
<li><a class="reference internal" href="#id296" id="id1127">Overview:</a></li>
<li><a class="reference internal" href="#id297" id="id1128">Arguments:</a></li>
<li><a class="reference internal" href="#id298" id="id1129">Semantics:</a></li>
<li><a class="reference internal" href="#id299" id="id1130">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#call-instruction" id="id1131">&#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id300" id="id1132">Syntax:</a></li>
<li><a class="reference internal" href="#id301" id="id1133">Overview:</a></li>
<li><a class="reference internal" href="#id302" id="id1134">Arguments:</a></li>
<li><a class="reference internal" href="#id303" id="id1135">Semantics:</a></li>
<li><a class="reference internal" href="#id304" id="id1136">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#va-arg-instruction" id="id1137">&#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id305" id="id1138">Syntax:</a></li>
<li><a class="reference internal" href="#id306" id="id1139">Overview:</a></li>
<li><a class="reference internal" href="#id307" id="id1140">Arguments:</a></li>
<li><a class="reference internal" href="#id308" id="id1141">Semantics:</a></li>
<li><a class="reference internal" href="#id309" id="id1142">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#landingpad-instruction" id="id1143">&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id310" id="id1144">Syntax:</a></li>
<li><a class="reference internal" href="#id311" id="id1145">Overview:</a></li>
<li><a class="reference internal" href="#id313" id="id1146">Arguments:</a></li>
<li><a class="reference internal" href="#id314" id="id1147">Semantics:</a></li>
<li><a class="reference internal" href="#id315" id="id1148">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#catchpad-instruction" id="id1149">&#8216;<code class="docutils literal"><span class="pre">catchpad</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id316" id="id1150">Syntax:</a></li>
<li><a class="reference internal" href="#id317" id="id1151">Overview:</a></li>
<li><a class="reference internal" href="#id319" id="id1152">Arguments:</a></li>
<li><a class="reference internal" href="#id320" id="id1153">Semantics:</a></li>
<li><a class="reference internal" href="#id322" id="id1154">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cleanuppad-instruction" id="id1155">&#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id323" id="id1156">Syntax:</a></li>
<li><a class="reference internal" href="#id324" id="id1157">Overview:</a></li>
<li><a class="reference internal" href="#id326" id="id1158">Arguments:</a></li>
<li><a class="reference internal" href="#id327" id="id1159">Semantics:</a></li>
<li><a class="reference internal" href="#id329" id="id1160">Example:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#intrinsic-functions" id="id1161">Intrinsic Functions</a><ul>
<li><a class="reference internal" href="#variable-argument-handling-intrinsics" id="id1162">Variable Argument Handling Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-va-start-intrinsic" id="id1163">&#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id330" id="id1164">Syntax:</a></li>
<li><a class="reference internal" href="#id331" id="id1165">Overview:</a></li>
<li><a class="reference internal" href="#id332" id="id1166">Arguments:</a></li>
<li><a class="reference internal" href="#id333" id="id1167">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-va-end-intrinsic" id="id1168">&#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id334" id="id1169">Syntax:</a></li>
<li><a class="reference internal" href="#id335" id="id1170">Overview:</a></li>
<li><a class="reference internal" href="#id336" id="id1171">Arguments:</a></li>
<li><a class="reference internal" href="#id337" id="id1172">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-va-copy-intrinsic" id="id1173">&#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id338" id="id1174">Syntax:</a></li>
<li><a class="reference internal" href="#id339" id="id1175">Overview:</a></li>
<li><a class="reference internal" href="#id340" id="id1176">Arguments:</a></li>
<li><a class="reference internal" href="#id341" id="id1177">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#accurate-garbage-collection-intrinsics" id="id1178">Accurate Garbage Collection Intrinsics</a><ul>
<li><a class="reference internal" href="#experimental-statepoint-intrinsics" id="id1179">Experimental Statepoint Intrinsics</a></li>
<li><a class="reference internal" href="#llvm-gcroot-intrinsic" id="id1180">&#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id343" id="id1181">Syntax:</a></li>
<li><a class="reference internal" href="#id344" id="id1182">Overview:</a></li>
<li><a class="reference internal" href="#id345" id="id1183">Arguments:</a></li>
<li><a class="reference internal" href="#id346" id="id1184">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-gcread-intrinsic" id="id1185">&#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id347" id="id1186">Syntax:</a></li>
<li><a class="reference internal" href="#id348" id="id1187">Overview:</a></li>
<li><a class="reference internal" href="#id349" id="id1188">Arguments:</a></li>
<li><a class="reference internal" href="#id350" id="id1189">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-gcwrite-intrinsic" id="id1190">&#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id351" id="id1191">Syntax:</a></li>
<li><a class="reference internal" href="#id352" id="id1192">Overview:</a></li>
<li><a class="reference internal" href="#id353" id="id1193">Arguments:</a></li>
<li><a class="reference internal" href="#id354" id="id1194">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#code-generator-intrinsics" id="id1195">Code Generator Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-returnaddress-intrinsic" id="id1196">&#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id355" id="id1197">Syntax:</a></li>
<li><a class="reference internal" href="#id356" id="id1198">Overview:</a></li>
<li><a class="reference internal" href="#id357" id="id1199">Arguments:</a></li>
<li><a class="reference internal" href="#id358" id="id1200">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-frameaddress-intrinsic" id="id1201">&#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id359" id="id1202">Syntax:</a></li>
<li><a class="reference internal" href="#id360" id="id1203">Overview:</a></li>
<li><a class="reference internal" href="#id361" id="id1204">Arguments:</a></li>
<li><a class="reference internal" href="#id362" id="id1205">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-localescape-and-llvm-localrecover-intrinsics" id="id1206">&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id363" id="id1207">Syntax:</a></li>
<li><a class="reference internal" href="#id364" id="id1208">Overview:</a></li>
<li><a class="reference internal" href="#id365" id="id1209">Arguments:</a></li>
<li><a class="reference internal" href="#id366" id="id1210">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-read-register-and-llvm-write-register-intrinsics" id="id1211">&#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id367" id="id1212">Syntax:</a></li>
<li><a class="reference internal" href="#id368" id="id1213">Overview:</a></li>
<li><a class="reference internal" href="#id369" id="id1214">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stacksave-intrinsic" id="id1215">&#8216;<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id370" id="id1216">Syntax:</a></li>
<li><a class="reference internal" href="#id371" id="id1217">Overview:</a></li>
<li><a class="reference internal" href="#id372" id="id1218">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stackrestore-intrinsic" id="id1219">&#8216;<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id373" id="id1220">Syntax:</a></li>
<li><a class="reference internal" href="#id374" id="id1221">Overview:</a></li>
<li><a class="reference internal" href="#id375" id="id1222">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-get-dynamic-area-offset-intrinsic" id="id1223">&#8216;<code class="docutils literal"><span class="pre">llvm.get.dynamic.area.offset</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id376" id="id1224">Syntax:</a></li>
<li><a class="reference internal" href="#id377" id="id1225">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-prefetch-intrinsic" id="id1226">&#8216;<code class="docutils literal"><span class="pre">llvm.prefetch</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id378" id="id1227">Syntax:</a></li>
<li><a class="reference internal" href="#id379" id="id1228">Overview:</a></li>
<li><a class="reference internal" href="#id380" id="id1229">Arguments:</a></li>
<li><a class="reference internal" href="#id381" id="id1230">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-pcmarker-intrinsic" id="id1231">&#8216;<code class="docutils literal"><span class="pre">llvm.pcmarker</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id382" id="id1232">Syntax:</a></li>
<li><a class="reference internal" href="#id383" id="id1233">Overview:</a></li>
<li><a class="reference internal" href="#id384" id="id1234">Arguments:</a></li>
<li><a class="reference internal" href="#id385" id="id1235">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-readcyclecounter-intrinsic" id="id1236">&#8216;<code class="docutils literal"><span class="pre">llvm.readcyclecounter</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id386" id="id1237">Syntax:</a></li>
<li><a class="reference internal" href="#id387" id="id1238">Overview:</a></li>
<li><a class="reference internal" href="#id388" id="id1239">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-clear-cache-intrinsic" id="id1240">&#8216;<code class="docutils literal"><span class="pre">llvm.clear_cache</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id389" id="id1241">Syntax:</a></li>
<li><a class="reference internal" href="#id390" id="id1242">Overview:</a></li>
<li><a class="reference internal" href="#id391" id="id1243">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-instrprof-increment-intrinsic" id="id1244">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_increment</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id392" id="id1245">Syntax:</a></li>
<li><a class="reference internal" href="#id393" id="id1246">Overview:</a></li>
<li><a class="reference internal" href="#id394" id="id1247">Arguments:</a></li>
<li><a class="reference internal" href="#id395" id="id1248">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-instrprof-value-profile-intrinsic" id="id1249">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id396" id="id1250">Syntax:</a></li>
<li><a class="reference internal" href="#id397" id="id1251">Overview:</a></li>
<li><a class="reference internal" href="#id398" id="id1252">Arguments:</a></li>
<li><a class="reference internal" href="#id399" id="id1253">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#standard-c-library-intrinsics" id="id1254">Standard C Library Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-memcpy-intrinsic" id="id1255">&#8216;<code class="docutils literal"><span class="pre">llvm.memcpy</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id400" id="id1256">Syntax:</a></li>
<li><a class="reference internal" href="#id401" id="id1257">Overview:</a></li>
<li><a class="reference internal" href="#id402" id="id1258">Arguments:</a></li>
<li><a class="reference internal" href="#id403" id="id1259">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-memmove-intrinsic" id="id1260">&#8216;<code class="docutils literal"><span class="pre">llvm.memmove</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id404" id="id1261">Syntax:</a></li>
<li><a class="reference internal" href="#id405" id="id1262">Overview:</a></li>
<li><a class="reference internal" href="#id406" id="id1263">Arguments:</a></li>
<li><a class="reference internal" href="#id407" id="id1264">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-memset-intrinsics" id="id1265">&#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id408" id="id1266">Syntax:</a></li>
<li><a class="reference internal" href="#id409" id="id1267">Overview:</a></li>
<li><a class="reference internal" href="#id410" id="id1268">Arguments:</a></li>
<li><a class="reference internal" href="#id411" id="id1269">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-sqrt-intrinsic" id="id1270">&#8216;<code class="docutils literal"><span class="pre">llvm.sqrt.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id412" id="id1271">Syntax:</a></li>
<li><a class="reference internal" href="#id413" id="id1272">Overview:</a></li>
<li><a class="reference internal" href="#id414" id="id1273">Arguments:</a></li>
<li><a class="reference internal" href="#id415" id="id1274">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-powi-intrinsic" id="id1275">&#8216;<code class="docutils literal"><span class="pre">llvm.powi.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id416" id="id1276">Syntax:</a></li>
<li><a class="reference internal" href="#id417" id="id1277">Overview:</a></li>
<li><a class="reference internal" href="#id418" id="id1278">Arguments:</a></li>
<li><a class="reference internal" href="#id419" id="id1279">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-sin-intrinsic" id="id1280">&#8216;<code class="docutils literal"><span class="pre">llvm.sin.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id420" id="id1281">Syntax:</a></li>
<li><a class="reference internal" href="#id421" id="id1282">Overview:</a></li>
<li><a class="reference internal" href="#id422" id="id1283">Arguments:</a></li>
<li><a class="reference internal" href="#id423" id="id1284">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-cos-intrinsic" id="id1285">&#8216;<code class="docutils literal"><span class="pre">llvm.cos.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id424" id="id1286">Syntax:</a></li>
<li><a class="reference internal" href="#id425" id="id1287">Overview:</a></li>
<li><a class="reference internal" href="#id426" id="id1288">Arguments:</a></li>
<li><a class="reference internal" href="#id427" id="id1289">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-pow-intrinsic" id="id1290">&#8216;<code class="docutils literal"><span class="pre">llvm.pow.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id428" id="id1291">Syntax:</a></li>
<li><a class="reference internal" href="#id429" id="id1292">Overview:</a></li>
<li><a class="reference internal" href="#id430" id="id1293">Arguments:</a></li>
<li><a class="reference internal" href="#id431" id="id1294">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-exp-intrinsic" id="id1295">&#8216;<code class="docutils literal"><span class="pre">llvm.exp.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id432" id="id1296">Syntax:</a></li>
<li><a class="reference internal" href="#id433" id="id1297">Overview:</a></li>
<li><a class="reference internal" href="#id434" id="id1298">Arguments:</a></li>
<li><a class="reference internal" href="#id435" id="id1299">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-exp2-intrinsic" id="id1300">&#8216;<code class="docutils literal"><span class="pre">llvm.exp2.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id436" id="id1301">Syntax:</a></li>
<li><a class="reference internal" href="#id437" id="id1302">Overview:</a></li>
<li><a class="reference internal" href="#id438" id="id1303">Arguments:</a></li>
<li><a class="reference internal" href="#id439" id="id1304">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-log-intrinsic" id="id1305">&#8216;<code class="docutils literal"><span class="pre">llvm.log.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id440" id="id1306">Syntax:</a></li>
<li><a class="reference internal" href="#id441" id="id1307">Overview:</a></li>
<li><a class="reference internal" href="#id442" id="id1308">Arguments:</a></li>
<li><a class="reference internal" href="#id443" id="id1309">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-log10-intrinsic" id="id1310">&#8216;<code class="docutils literal"><span class="pre">llvm.log10.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id444" id="id1311">Syntax:</a></li>
<li><a class="reference internal" href="#id445" id="id1312">Overview:</a></li>
<li><a class="reference internal" href="#id446" id="id1313">Arguments:</a></li>
<li><a class="reference internal" href="#id447" id="id1314">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-log2-intrinsic" id="id1315">&#8216;<code class="docutils literal"><span class="pre">llvm.log2.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id448" id="id1316">Syntax:</a></li>
<li><a class="reference internal" href="#id449" id="id1317">Overview:</a></li>
<li><a class="reference internal" href="#id450" id="id1318">Arguments:</a></li>
<li><a class="reference internal" href="#id451" id="id1319">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-fma-intrinsic" id="id1320">&#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id452" id="id1321">Syntax:</a></li>
<li><a class="reference internal" href="#id453" id="id1322">Overview:</a></li>
<li><a class="reference internal" href="#id454" id="id1323">Arguments:</a></li>
<li><a class="reference internal" href="#id455" id="id1324">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-fabs-intrinsic" id="id1325">&#8216;<code class="docutils literal"><span class="pre">llvm.fabs.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id456" id="id1326">Syntax:</a></li>
<li><a class="reference internal" href="#id457" id="id1327">Overview:</a></li>
<li><a class="reference internal" href="#id458" id="id1328">Arguments:</a></li>
<li><a class="reference internal" href="#id459" id="id1329">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-minnum-intrinsic" id="id1330">&#8216;<code class="docutils literal"><span class="pre">llvm.minnum.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id460" id="id1331">Syntax:</a></li>
<li><a class="reference internal" href="#id461" id="id1332">Overview:</a></li>
<li><a class="reference internal" href="#id462" id="id1333">Arguments:</a></li>
<li><a class="reference internal" href="#id463" id="id1334">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-maxnum-intrinsic" id="id1335">&#8216;<code class="docutils literal"><span class="pre">llvm.maxnum.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id464" id="id1336">Syntax:</a></li>
<li><a class="reference internal" href="#id465" id="id1337">Overview:</a></li>
<li><a class="reference internal" href="#id466" id="id1338">Arguments:</a></li>
<li><a class="reference internal" href="#id467" id="id1339">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-copysign-intrinsic" id="id1340">&#8216;<code class="docutils literal"><span class="pre">llvm.copysign.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id468" id="id1341">Syntax:</a></li>
<li><a class="reference internal" href="#id469" id="id1342">Overview:</a></li>
<li><a class="reference internal" href="#id470" id="id1343">Arguments:</a></li>
<li><a class="reference internal" href="#id471" id="id1344">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-floor-intrinsic" id="id1345">&#8216;<code class="docutils literal"><span class="pre">llvm.floor.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id472" id="id1346">Syntax:</a></li>
<li><a class="reference internal" href="#id473" id="id1347">Overview:</a></li>
<li><a class="reference internal" href="#id474" id="id1348">Arguments:</a></li>
<li><a class="reference internal" href="#id475" id="id1349">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ceil-intrinsic" id="id1350">&#8216;<code class="docutils literal"><span class="pre">llvm.ceil.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id476" id="id1351">Syntax:</a></li>
<li><a class="reference internal" href="#id477" id="id1352">Overview:</a></li>
<li><a class="reference internal" href="#id478" id="id1353">Arguments:</a></li>
<li><a class="reference internal" href="#id479" id="id1354">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-trunc-intrinsic" id="id1355">&#8216;<code class="docutils literal"><span class="pre">llvm.trunc.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id480" id="id1356">Syntax:</a></li>
<li><a class="reference internal" href="#id481" id="id1357">Overview:</a></li>
<li><a class="reference internal" href="#id482" id="id1358">Arguments:</a></li>
<li><a class="reference internal" href="#id483" id="id1359">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-rint-intrinsic" id="id1360">&#8216;<code class="docutils literal"><span class="pre">llvm.rint.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id484" id="id1361">Syntax:</a></li>
<li><a class="reference internal" href="#id485" id="id1362">Overview:</a></li>
<li><a class="reference internal" href="#id486" id="id1363">Arguments:</a></li>
<li><a class="reference internal" href="#id487" id="id1364">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-nearbyint-intrinsic" id="id1365">&#8216;<code class="docutils literal"><span class="pre">llvm.nearbyint.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id488" id="id1366">Syntax:</a></li>
<li><a class="reference internal" href="#id489" id="id1367">Overview:</a></li>
<li><a class="reference internal" href="#id490" id="id1368">Arguments:</a></li>
<li><a class="reference internal" href="#id491" id="id1369">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-round-intrinsic" id="id1370">&#8216;<code class="docutils literal"><span class="pre">llvm.round.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id492" id="id1371">Syntax:</a></li>
<li><a class="reference internal" href="#id493" id="id1372">Overview:</a></li>
<li><a class="reference internal" href="#id494" id="id1373">Arguments:</a></li>
<li><a class="reference internal" href="#id495" id="id1374">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bit-manipulation-intrinsics" id="id1375">Bit Manipulation Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-bitreverse-intrinsics" id="id1376">&#8216;<code class="docutils literal"><span class="pre">llvm.bitreverse.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id496" id="id1377">Syntax:</a></li>
<li><a class="reference internal" href="#id497" id="id1378">Overview:</a></li>
<li><a class="reference internal" href="#id498" id="id1379">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-bswap-intrinsics" id="id1380">&#8216;<code class="docutils literal"><span class="pre">llvm.bswap.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id499" id="id1381">Syntax:</a></li>
<li><a class="reference internal" href="#id500" id="id1382">Overview:</a></li>
<li><a class="reference internal" href="#id501" id="id1383">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ctpop-intrinsic" id="id1384">&#8216;<code class="docutils literal"><span class="pre">llvm.ctpop.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id502" id="id1385">Syntax:</a></li>
<li><a class="reference internal" href="#id503" id="id1386">Overview:</a></li>
<li><a class="reference internal" href="#id504" id="id1387">Arguments:</a></li>
<li><a class="reference internal" href="#id505" id="id1388">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ctlz-intrinsic" id="id1389">&#8216;<code class="docutils literal"><span class="pre">llvm.ctlz.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id506" id="id1390">Syntax:</a></li>
<li><a class="reference internal" href="#id507" id="id1391">Overview:</a></li>
<li><a class="reference internal" href="#id508" id="id1392">Arguments:</a></li>
<li><a class="reference internal" href="#id509" id="id1393">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-cttz-intrinsic" id="id1394">&#8216;<code class="docutils literal"><span class="pre">llvm.cttz.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id510" id="id1395">Syntax:</a></li>
<li><a class="reference internal" href="#id511" id="id1396">Overview:</a></li>
<li><a class="reference internal" href="#id512" id="id1397">Arguments:</a></li>
<li><a class="reference internal" href="#id513" id="id1398">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-with-overflow-intrinsics" id="id1399">Arithmetic with Overflow Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-sadd-with-overflow-intrinsics" id="id1400">&#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id514" id="id1401">Syntax:</a></li>
<li><a class="reference internal" href="#id515" id="id1402">Overview:</a></li>
<li><a class="reference internal" href="#id516" id="id1403">Arguments:</a></li>
<li><a class="reference internal" href="#id517" id="id1404">Semantics:</a></li>
<li><a class="reference internal" href="#id518" id="id1405">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-uadd-with-overflow-intrinsics" id="id1406">&#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id519" id="id1407">Syntax:</a></li>
<li><a class="reference internal" href="#id520" id="id1408">Overview:</a></li>
<li><a class="reference internal" href="#id521" id="id1409">Arguments:</a></li>
<li><a class="reference internal" href="#id522" id="id1410">Semantics:</a></li>
<li><a class="reference internal" href="#id523" id="id1411">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ssub-with-overflow-intrinsics" id="id1412">&#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id524" id="id1413">Syntax:</a></li>
<li><a class="reference internal" href="#id525" id="id1414">Overview:</a></li>
<li><a class="reference internal" href="#id526" id="id1415">Arguments:</a></li>
<li><a class="reference internal" href="#id527" id="id1416">Semantics:</a></li>
<li><a class="reference internal" href="#id528" id="id1417">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-usub-with-overflow-intrinsics" id="id1418">&#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id529" id="id1419">Syntax:</a></li>
<li><a class="reference internal" href="#id530" id="id1420">Overview:</a></li>
<li><a class="reference internal" href="#id531" id="id1421">Arguments:</a></li>
<li><a class="reference internal" href="#id532" id="id1422">Semantics:</a></li>
<li><a class="reference internal" href="#id533" id="id1423">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-smul-with-overflow-intrinsics" id="id1424">&#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id534" id="id1425">Syntax:</a></li>
<li><a class="reference internal" href="#id535" id="id1426">Overview:</a></li>
<li><a class="reference internal" href="#id536" id="id1427">Arguments:</a></li>
<li><a class="reference internal" href="#id537" id="id1428">Semantics:</a></li>
<li><a class="reference internal" href="#id538" id="id1429">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-umul-with-overflow-intrinsics" id="id1430">&#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id539" id="id1431">Syntax:</a></li>
<li><a class="reference internal" href="#id540" id="id1432">Overview:</a></li>
<li><a class="reference internal" href="#id541" id="id1433">Arguments:</a></li>
<li><a class="reference internal" href="#id542" id="id1434">Semantics:</a></li>
<li><a class="reference internal" href="#id543" id="id1435">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#specialised-arithmetic-intrinsics" id="id1436">Specialised Arithmetic Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-canonicalize-intrinsic" id="id1437">&#8216;<code class="docutils literal"><span class="pre">llvm.canonicalize.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id544" id="id1438">Syntax:</a></li>
<li><a class="reference internal" href="#id545" id="id1439">Overview:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-fmuladd-intrinsic" id="id1440">&#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id546" id="id1441">Syntax:</a></li>
<li><a class="reference internal" href="#id547" id="id1442">Overview:</a></li>
<li><a class="reference internal" href="#id548" id="id1443">Arguments:</a></li>
<li><a class="reference internal" href="#id549" id="id1444">Semantics:</a></li>
<li><a class="reference internal" href="#id550" id="id1445">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#half-precision-floating-point-intrinsics" id="id1446">Half Precision Floating Point Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-convert-to-fp16-intrinsic" id="id1447">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id551" id="id1448">Syntax:</a></li>
<li><a class="reference internal" href="#id552" id="id1449">Overview:</a></li>
<li><a class="reference internal" href="#id553" id="id1450">Arguments:</a></li>
<li><a class="reference internal" href="#id554" id="id1451">Semantics:</a></li>
<li><a class="reference internal" href="#id555" id="id1452">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-convert-from-fp16-intrinsic" id="id1453">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id556" id="id1454">Syntax:</a></li>
<li><a class="reference internal" href="#id557" id="id1455">Overview:</a></li>
<li><a class="reference internal" href="#id558" id="id1456">Arguments:</a></li>
<li><a class="reference internal" href="#id559" id="id1457">Semantics:</a></li>
<li><a class="reference internal" href="#id560" id="id1458">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#debugger-intrinsics" id="id1459">Debugger Intrinsics</a></li>
<li><a class="reference internal" href="#exception-handling-intrinsics" id="id1460">Exception Handling Intrinsics</a></li>
<li><a class="reference internal" href="#trampoline-intrinsics" id="id1461">Trampoline Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-init-trampoline-intrinsic" id="id1462">&#8216;<code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id561" id="id1463">Syntax:</a></li>
<li><a class="reference internal" href="#id562" id="id1464">Overview:</a></li>
<li><a class="reference internal" href="#id563" id="id1465">Arguments:</a></li>
<li><a class="reference internal" href="#id564" id="id1466">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-adjust-trampoline-intrinsic" id="id1467">&#8216;<code class="docutils literal"><span class="pre">llvm.adjust.trampoline</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id565" id="id1468">Syntax:</a></li>
<li><a class="reference internal" href="#id566" id="id1469">Overview:</a></li>
<li><a class="reference internal" href="#id567" id="id1470">Arguments:</a></li>
<li><a class="reference internal" href="#id568" id="id1471">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#masked-vector-load-and-store-intrinsics" id="id1472">Masked Vector Load and Store Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-masked-load-intrinsics" id="id1473">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.load.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id569" id="id1474">Syntax:</a></li>
<li><a class="reference internal" href="#id570" id="id1475">Overview:</a></li>
<li><a class="reference internal" href="#id571" id="id1476">Arguments:</a></li>
<li><a class="reference internal" href="#id572" id="id1477">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-masked-store-intrinsics" id="id1478">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.store.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id573" id="id1479">Syntax:</a></li>
<li><a class="reference internal" href="#id574" id="id1480">Overview:</a></li>
<li><a class="reference internal" href="#id575" id="id1481">Arguments:</a></li>
<li><a class="reference internal" href="#id576" id="id1482">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#masked-vector-gather-and-scatter-intrinsics" id="id1483">Masked Vector Gather and Scatter Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-masked-gather-intrinsics" id="id1484">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.gather.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id577" id="id1485">Syntax:</a></li>
<li><a class="reference internal" href="#id578" id="id1486">Overview:</a></li>
<li><a class="reference internal" href="#id579" id="id1487">Arguments:</a></li>
<li><a class="reference internal" href="#id580" id="id1488">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-masked-scatter-intrinsics" id="id1489">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.scatter.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id581" id="id1490">Syntax:</a></li>
<li><a class="reference internal" href="#id582" id="id1491">Overview:</a></li>
<li><a class="reference internal" href="#id583" id="id1492">Arguments:</a></li>
<li><a class="reference internal" href="#id584" id="id1493">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#memory-use-markers" id="id1494">Memory Use Markers</a><ul>
<li><a class="reference internal" href="#llvm-lifetime-start-intrinsic" id="id1495">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.start</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id585" id="id1496">Syntax:</a></li>
<li><a class="reference internal" href="#id586" id="id1497">Overview:</a></li>
<li><a class="reference internal" href="#id587" id="id1498">Arguments:</a></li>
<li><a class="reference internal" href="#id588" id="id1499">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-lifetime-end-intrinsic" id="id1500">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.end</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id589" id="id1501">Syntax:</a></li>
<li><a class="reference internal" href="#id590" id="id1502">Overview:</a></li>
<li><a class="reference internal" href="#id591" id="id1503">Arguments:</a></li>
<li><a class="reference internal" href="#id592" id="id1504">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-invariant-start-intrinsic" id="id1505">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.start</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id593" id="id1506">Syntax:</a></li>
<li><a class="reference internal" href="#id594" id="id1507">Overview:</a></li>
<li><a class="reference internal" href="#id595" id="id1508">Arguments:</a></li>
<li><a class="reference internal" href="#id596" id="id1509">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-invariant-end-intrinsic" id="id1510">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.end</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id597" id="id1511">Syntax:</a></li>
<li><a class="reference internal" href="#id598" id="id1512">Overview:</a></li>
<li><a class="reference internal" href="#id599" id="id1513">Arguments:</a></li>
<li><a class="reference internal" href="#id600" id="id1514">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-invariant-group-barrier-intrinsic" id="id1515">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id601" id="id1516">Syntax:</a></li>
<li><a class="reference internal" href="#id602" id="id1517">Overview:</a></li>
<li><a class="reference internal" href="#id603" id="id1518">Arguments:</a></li>
<li><a class="reference internal" href="#id604" id="id1519">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#general-intrinsics" id="id1520">General Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-var-annotation-intrinsic" id="id1521">&#8216;<code class="docutils literal"><span class="pre">llvm.var.annotation</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id605" id="id1522">Syntax:</a></li>
<li><a class="reference internal" href="#id606" id="id1523">Overview:</a></li>
<li><a class="reference internal" href="#id607" id="id1524">Arguments:</a></li>
<li><a class="reference internal" href="#id608" id="id1525">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ptr-annotation-intrinsic" id="id1526">&#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id609" id="id1527">Syntax:</a></li>
<li><a class="reference internal" href="#id610" id="id1528">Overview:</a></li>
<li><a class="reference internal" href="#id611" id="id1529">Arguments:</a></li>
<li><a class="reference internal" href="#id612" id="id1530">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-annotation-intrinsic" id="id1531">&#8216;<code class="docutils literal"><span class="pre">llvm.annotation.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id613" id="id1532">Syntax:</a></li>
<li><a class="reference internal" href="#id614" id="id1533">Overview:</a></li>
<li><a class="reference internal" href="#id615" id="id1534">Arguments:</a></li>
<li><a class="reference internal" href="#id616" id="id1535">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-trap-intrinsic" id="id1536">&#8216;<code class="docutils literal"><span class="pre">llvm.trap</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id617" id="id1537">Syntax:</a></li>
<li><a class="reference internal" href="#id618" id="id1538">Overview:</a></li>
<li><a class="reference internal" href="#id619" id="id1539">Arguments:</a></li>
<li><a class="reference internal" href="#id620" id="id1540">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-debugtrap-intrinsic" id="id1541">&#8216;<code class="docutils literal"><span class="pre">llvm.debugtrap</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id621" id="id1542">Syntax:</a></li>
<li><a class="reference internal" href="#id622" id="id1543">Overview:</a></li>
<li><a class="reference internal" href="#id623" id="id1544">Arguments:</a></li>
<li><a class="reference internal" href="#id624" id="id1545">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stackprotector-intrinsic" id="id1546">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotector</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id625" id="id1547">Syntax:</a></li>
<li><a class="reference internal" href="#id626" id="id1548">Overview:</a></li>
<li><a class="reference internal" href="#id627" id="id1549">Arguments:</a></li>
<li><a class="reference internal" href="#id628" id="id1550">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stackprotectorcheck-intrinsic" id="id1551">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id629" id="id1552">Syntax:</a></li>
<li><a class="reference internal" href="#id630" id="id1553">Overview:</a></li>
<li><a class="reference internal" href="#id631" id="id1554">Arguments:</a></li>
<li><a class="reference internal" href="#id632" id="id1555">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-objectsize-intrinsic" id="id1556">&#8216;<code class="docutils literal"><span class="pre">llvm.objectsize</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id633" id="id1557">Syntax:</a></li>
<li><a class="reference internal" href="#id634" id="id1558">Overview:</a></li>
<li><a class="reference internal" href="#id635" id="id1559">Arguments:</a></li>
<li><a class="reference internal" href="#id636" id="id1560">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-expect-intrinsic" id="id1561">&#8216;<code class="docutils literal"><span class="pre">llvm.expect</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id637" id="id1562">Syntax:</a></li>
<li><a class="reference internal" href="#id638" id="id1563">Overview:</a></li>
<li><a class="reference internal" href="#id639" id="id1564">Arguments:</a></li>
<li><a class="reference internal" href="#id640" id="id1565">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-assume-intrinsic" id="id1566">&#8216;<code class="docutils literal"><span class="pre">llvm.assume</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id641" id="id1567">Syntax:</a></li>
<li><a class="reference internal" href="#id642" id="id1568">Overview:</a></li>
<li><a class="reference internal" href="#id643" id="id1569">Arguments:</a></li>
<li><a class="reference internal" href="#id644" id="id1570">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-bitset-test-intrinsic" id="id1571">&#8216;<code class="docutils literal"><span class="pre">llvm.bitset.test</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id645" id="id1572">Syntax:</a></li>
<li><a class="reference internal" href="#id646" id="id1573">Arguments:</a></li>
<li><a class="reference internal" href="#id647" id="id1574">Overview:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-donothing-intrinsic" id="id1575">&#8216;<code class="docutils literal"><span class="pre">llvm.donothing</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id648" id="id1576">Syntax:</a></li>
<li><a class="reference internal" href="#id649" id="id1577">Overview:</a></li>
<li><a class="reference internal" href="#id650" id="id1578">Arguments:</a></li>
<li><a class="reference internal" href="#id651" id="id1579">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#stack-map-intrinsics" id="id1580">Stack Map Intrinsics</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id652">摘要</a><a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>这份文档是LLVM汇编语言的语法参考手册，LLVM汇编语言是一种 <a href="#id1581"><span class="problematic" id="id1582">`静态单赋值（SSA）&lt;https://www.wikiwand.com/zh/静态单赋值形式&gt;`_</span></a> 的中间表示，提供了类型安全检查，低层次的操作符，灵活和清晰表达‘几乎所有’高级语言的能力。同时，它也是LLVM编译算法中各个阶段的一种通用代码表达形式。</p>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id653">简介</a><a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>LLVM的中间代码表示被设计成用在以下三种不同的形式下：作为一种编译器的内存中的中间代码（IR），作为一种保存在磁盘中的字节码形式（适合被JIT编译器快速装载），作为人类可读的汇编语言表示。这使得LLVM为编译器的高效转换和分析提供了一种强有力的中间表达形式，同时也提供了一种很自然的方法来调试和可视化编译后的代码。这三种不同的LLVM中间代码的形式是完全等价的，这份文档就在描述人类可读的形式和其所用到的符号。</p>
<p>LLVM中间字节码表示的目标是，成为一种轻量级和低层次的，同时有表现力的、类型化的并且可扩展的中间语言，更要成为一种 “通用中间表示（IR）”，并且是足够低层次的，这样才能让高层次的语言设计能够清晰地映射到这种中间表示上（就像微处理器指令——机器码，也可以看做是一种中间表示，允许源代码映射到它们上）通过提供类型信息，LLVM可以被用在优化目标上。例如：通过指针分析，可以证明C自动变量是从没存取过函数外的外部变量的，允许提升一个简单的SSA变量，替代一个内存地址等。</p>
<div class="section" id="well-formedness">
<span id="wellformed"></span><h3><a class="toc-backref" href="#id654">结构良好性</a><a class="headerlink" href="#well-formedness" title="永久链接至标题">¶</a></h3>
<p>It is important to note that this document describes &#8216;well formed&#8217; LLVM
assembly language. There is a difference between what the parser accepts
and what is considered &#8216;well formed&#8217;. For example, the following
instruction is syntactically okay, but not well formed:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%x</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="nv">%x</span>
</pre></div>
</div>
<p>because the definition of <code class="docutils literal"><span class="pre">%x</span></code> does not dominate all of its uses. The
LLVM infrastructure provides a verification pass that may be used to
verify that an LLVM module is well formed. This pass is automatically
run by the parser after parsing input assembly and by the optimizer
before it outputs bitcode. The violations pointed out by the verifier
pass indicate bugs in transformation passes or input to the parser.</p>
</div>
</div>
<div class="section" id="identifiers">
<span id="id1"></span><h2><a class="toc-backref" href="#id655">标识符</a><a class="headerlink" href="#identifiers" title="永久链接至标题">¶</a></h2>
<p>LLVM identifiers come in two basic types: global and local. Global
identifiers (functions, global variables) begin with the <code class="docutils literal"><span class="pre">'&#64;'</span></code>
character. Local identifiers (register names, types) begin with the
<code class="docutils literal"><span class="pre">'%'</span></code> character. Additionally, there are three different formats for
identifiers, for different purposes:</p>
<ol class="arabic simple">
<li>Named values are represented as a string of characters with their
prefix. For example, <code class="docutils literal"><span class="pre">%foo</span></code>, <code class="docutils literal"><span class="pre">&#64;DivisionByZero</span></code>,
<code class="docutils literal"><span class="pre">%a.really.long.identifier</span></code>. The actual regular expression used is
&#8216;<code class="docutils literal"><span class="pre">[%&#64;][-a-zA-Z$._][-a-zA-Z$._0-9]*</span></code>&#8216;. Identifiers that require other
characters in their names can be surrounded with quotes. Special
characters may be escaped using <code class="docutils literal"><span class="pre">&quot;\xx&quot;</span></code> where <code class="docutils literal"><span class="pre">xx</span></code> is the ASCII
code for the character in hexadecimal. In this way, any character can
be used in a name value, even quotes themselves. The <code class="docutils literal"><span class="pre">&quot;\01&quot;</span></code> prefix
can be used on global variables to suppress mangling.</li>
<li>Unnamed values are represented as an unsigned numeric value with
their prefix. For example, <code class="docutils literal"><span class="pre">%12</span></code>, <code class="docutils literal"><span class="pre">&#64;2</span></code>, <code class="docutils literal"><span class="pre">%44</span></code>.</li>
<li>Constants, which are described in the section <a class="reference internal" href="#constants">Constants</a> below.</li>
</ol>
<p>LLVM requires that values start with a prefix for two reasons: Compilers
don&#8217;t need to worry about name clashes with reserved words, and the set
of reserved words may be expanded in the future without penalty.
Additionally, unnamed identifiers allow a compiler to quickly come up
with a temporary variable without having to avoid symbol table
conflicts.</p>
<p>Reserved words in LLVM are very similar to reserved words in other
languages. There are keywords for different opcodes (&#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216;,
&#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216;, etc...), for primitive type names (&#8216;<code class="docutils literal"><span class="pre">void</span></code>&#8216;,
&#8216;<code class="docutils literal"><span class="pre">i32</span></code>&#8216;, etc...), and others. These reserved words cannot conflict
with variable names, because none of them start with a prefix character
(<code class="docutils literal"><span class="pre">'%'</span></code> or <code class="docutils literal"><span class="pre">'&#64;'</span></code>).</p>
<p>Here is an example of LLVM code to multiply the integer variable
&#8216;<code class="docutils literal"><span class="pre">%X</span></code>&#8216; by 8:</p>
<p>The easy way:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="m">8</span>
</pre></div>
</div>
<p>After strength reduction:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="m">3</span>
</pre></div>
</div>
<p>And the hard way:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%X</span>           <span class="c">; yields i32:%0</span>
<span class="nv nv-Anonymous">%1</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="nv nv-Anonymous">%0</span>           <span class="c">; yields i32:%1</span>
<span class="nv">%result</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%1</span><span class="p">,</span> <span class="nv nv-Anonymous">%1</span>
</pre></div>
</div>
<p>This last way of multiplying <code class="docutils literal"><span class="pre">%X</span></code> by 8 illustrates several important
lexical features of LLVM:</p>
<ol class="arabic simple">
<li>Comments are delimited with a &#8216;<code class="docutils literal"><span class="pre">;</span></code>&#8216; and go until the end of line.</li>
<li>Unnamed temporaries are created when the result of a computation is
not assigned to a named value.</li>
<li>Unnamed temporaries are numbered sequentially (using a per-function
incrementing counter, starting with 0). Note that basic blocks and unnamed
function parameters are included in this numbering. For example, if the
entry basic block is not given a label name and all function parameters are
named, then it will get number 0.</li>
</ol>
<p>It also shows a convention that we follow in this document. When
demonstrating instructions, we will follow an instruction with a comment
that defines the type and name of value produced.</p>
</div>
<div class="section" id="high-level-structure">
<h2><a class="toc-backref" href="#id656">High Level Structure</a><a class="headerlink" href="#high-level-structure" title="永久链接至标题">¶</a></h2>
<div class="section" id="module-structure">
<h3><a class="toc-backref" href="#id657">Module Structure</a><a class="headerlink" href="#module-structure" title="永久链接至标题">¶</a></h3>
<p>LLVM programs are composed of <code class="docutils literal"><span class="pre">Module</span></code>&#8216;s, each of which is a
translation unit of the input programs. Each module consists of
functions, global variables, and symbol table entries. Modules may be
combined together with the LLVM linker, which merges function (and
global variable) definitions, resolves forward declarations, and merges
symbol table entries. Here is an example of the &#8220;hello world&#8221; module:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Declare the string constant as a global constant.</span>
<span class="vg">@.str</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span> <span class="p">[</span><span class="m">13</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;hello world\0A\00&quot;</span>

<span class="c">; External declaration of the puts function</span>
<span class="k">declare</span> <span class="k">i32</span> <span class="vg">@puts</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nocapture</span><span class="p">)</span> <span class="k">nounwind</span>

<span class="c">; Definition of main function</span>
<span class="k">define</span> <span class="k">i32</span> <span class="vg">@main</span><span class="p">()</span> <span class="p">{</span>   <span class="c">; i32()*</span>
  <span class="c">; Convert [13 x i8]* to i8  *...</span>
  <span class="nv">%cast210</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">13</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">13</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@.str</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span>

  <span class="c">; Call puts function to write out the string to stdout.</span>
  <span class="k">call</span> <span class="k">i32</span> <span class="vg">@puts</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%cast210</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>

<span class="c">; Named metadata</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="k">i32</span> <span class="m">42</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="nv">!&quot;string&quot;</span><span class="p">}</span>
<span class="nv">!foo</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
</pre></div>
</div>
<p>This example is made up of a <a class="reference internal" href="#globalvars"><span class="std std-ref">global variable</span></a> named
&#8220;<code class="docutils literal"><span class="pre">.str</span></code>&#8221;, an external declaration of the &#8220;<code class="docutils literal"><span class="pre">puts</span></code>&#8221; function, a
<a class="reference internal" href="#functionstructure"><span class="std std-ref">function definition</span></a> for &#8220;<code class="docutils literal"><span class="pre">main</span></code>&#8221; and
<a class="reference internal" href="#namedmetadatastructure"><span class="std std-ref">named metadata</span></a> &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221;.</p>
<p>In general, a module is made up of a list of global values (where both
functions and global variables are global values). Global values are
represented by a pointer to a memory location (in this case, a pointer
to an array of char, and a pointer to a function), and have one of the
following <a class="reference internal" href="#linkage"><span class="std std-ref">linkage types</span></a>.</p>
</div>
<div class="section" id="linkage-types">
<span id="linkage"></span><h3><a class="toc-backref" href="#id658">Linkage Types</a><a class="headerlink" href="#linkage-types" title="永久链接至标题">¶</a></h3>
<p>All Global Variables and Functions have one of the following types of
linkage:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>Global values with &#8220;<code class="docutils literal"><span class="pre">private</span></code>&#8221; linkage are only directly
accessible by objects in the current module. In particular, linking
code into a module with an private global value may cause the
private to be renamed as necessary to avoid collisions. Because the
symbol is private to the module, all references can be updated. This
doesn&#8217;t show up in any symbol table in the object file.</dd>
<dt><code class="docutils literal"><span class="pre">internal</span></code></dt>
<dd>Similar to private, but the value shows as a local symbol
(<code class="docutils literal"><span class="pre">STB_LOCAL</span></code> in the case of ELF) in the object file. This
corresponds to the notion of the &#8216;<code class="docutils literal"><span class="pre">static</span></code>&#8216; keyword in C.</dd>
<dt><code class="docutils literal"><span class="pre">available_externally</span></code></dt>
<dd>Globals with &#8220;<code class="docutils literal"><span class="pre">available_externally</span></code>&#8221; linkage are never emitted into
the object file corresponding to the LLVM module. From the linker&#8217;s
perspective, an <code class="docutils literal"><span class="pre">available_externally</span></code> global is equivalent to
an external declaration. They exist to allow inlining and other
optimizations to take place given knowledge of the definition of the
global, which is known to be somewhere outside the module. Globals
with <code class="docutils literal"><span class="pre">available_externally</span></code> linkage are allowed to be discarded at
will, and allow inlining and other optimizations. This linkage type is
only allowed on definitions, not declarations.</dd>
<dt><code class="docutils literal"><span class="pre">linkonce</span></code></dt>
<dd>Globals with &#8220;<code class="docutils literal"><span class="pre">linkonce</span></code>&#8221; linkage are merged with other globals of
the same name when linkage occurs. This can be used to implement
some forms of inline functions, templates, or other code which must
be generated in each translation unit that uses it, but where the
body may be overridden with a more definitive definition later.
Unreferenced <code class="docutils literal"><span class="pre">linkonce</span></code> globals are allowed to be discarded. Note
that <code class="docutils literal"><span class="pre">linkonce</span></code> linkage does not actually allow the optimizer to
inline the body of this function into callers because it doesn&#8217;t
know if this definition of the function is the definitive definition
within the program or whether it will be overridden by a stronger
definition. To enable inlining and other optimizations, use
&#8220;<code class="docutils literal"><span class="pre">linkonce_odr</span></code>&#8221; linkage.</dd>
<dt><code class="docutils literal"><span class="pre">weak</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">weak</span></code>&#8221; linkage has the same merging semantics as <code class="docutils literal"><span class="pre">linkonce</span></code>
linkage, except that unreferenced globals with <code class="docutils literal"><span class="pre">weak</span></code> linkage may
not be discarded. This is used for globals that are declared &#8220;weak&#8221;
in C source code.</dd>
<dt><code class="docutils literal"><span class="pre">common</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">common</span></code>&#8221; linkage is most similar to &#8220;<code class="docutils literal"><span class="pre">weak</span></code>&#8221; linkage, but they
are used for tentative definitions in C, such as &#8220;<code class="docutils literal"><span class="pre">int</span> <span class="pre">X;</span></code>&#8221; at
global scope. Symbols with &#8220;<code class="docutils literal"><span class="pre">common</span></code>&#8221; linkage are merged in the
same way as <code class="docutils literal"><span class="pre">weak</span> <span class="pre">symbols</span></code>, and they may not be deleted if
unreferenced. <code class="docutils literal"><span class="pre">common</span></code> symbols may not have an explicit section,
must have a zero initializer, and may not be marked
&#8216;<a class="reference internal" href="#globalvars"><span class="std std-ref">constant</span></a>&#8216;. Functions and aliases may not have
common linkage.</dd>
</dl>
<dl class="docutils" id="linkage-appending">
<dt><code class="docutils literal"><span class="pre">appending</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">appending</span></code>&#8221; linkage may only be applied to global variables of
pointer to array type. When two global variables with appending
linkage are linked together, the two global arrays are appended
together. This is the LLVM, typesafe, equivalent of having the
system linker append together &#8220;sections&#8221; with identical names when
.o files are linked.</dd>
<dt><code class="docutils literal"><span class="pre">extern_weak</span></code></dt>
<dd>The semantics of this linkage follow the ELF object file model: the
symbol is weak until linked, if not linked, the symbol becomes null
instead of being an undefined reference.</dd>
<dt><code class="docutils literal"><span class="pre">linkonce_odr</span></code>, <code class="docutils literal"><span class="pre">weak_odr</span></code></dt>
<dd>Some languages allow differing globals to be merged, such as two
functions with different semantics. Other languages, such as
<code class="docutils literal"><span class="pre">C++</span></code>, ensure that only equivalent globals are ever merged (the
&#8220;one definition rule&#8221; &#8212; &#8220;ODR&#8221;). Such languages can use the
<code class="docutils literal"><span class="pre">linkonce_odr</span></code> and <code class="docutils literal"><span class="pre">weak_odr</span></code> linkage types to indicate that the
global will only be merged with equivalent globals. These linkage
types are otherwise the same as their non-<code class="docutils literal"><span class="pre">odr</span></code> versions.</dd>
<dt><code class="docutils literal"><span class="pre">external</span></code></dt>
<dd>If none of the above identifiers are used, the global is externally
visible, meaning that it participates in linkage and can be used to
resolve external symbol references.</dd>
</dl>
<p>It is illegal for a function <em>declaration</em> to have any linkage type
other than <code class="docutils literal"><span class="pre">external</span></code> or <code class="docutils literal"><span class="pre">extern_weak</span></code>.</p>
</div>
<div class="section" id="calling-conventions">
<span id="callingconv"></span><h3><a class="toc-backref" href="#id659">Calling Conventions</a><a class="headerlink" href="#calling-conventions" title="永久链接至标题">¶</a></h3>
<p>LLVM <a class="reference internal" href="#functionstructure"><span class="std std-ref">functions</span></a>, <a class="reference internal" href="#i-call"><span class="std std-ref">calls</span></a> and
<a class="reference internal" href="#i-invoke"><span class="std std-ref">invokes</span></a> can all have an optional calling convention
specified for the call. The calling convention of any pair of dynamic
caller/callee must match, or the behavior of the program is undefined.
The following calling conventions are supported by LLVM, and more may be
added in the future:</p>
<dl class="docutils">
<dt>&#8220;<code class="docutils literal"><span class="pre">ccc</span></code>&#8221; - The C calling convention</dt>
<dd>This calling convention (the default if no other calling convention
is specified) matches the target C calling conventions. This calling
convention supports varargs function calls and tolerates some
mismatch in the declared prototype and implemented declaration of
the function (as does normal C).</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">fastcc</span></code>&#8221; - The fast calling convention</dt>
<dd>This calling convention attempts to make calls as fast as possible
(e.g. by passing things in registers). This calling convention
allows the target to use whatever tricks it wants to produce fast
code for the target, without having to conform to an externally
specified ABI (Application Binary Interface). <a class="reference external" href="CodeGenerator.html#id80">Tail calls can only
be optimized when this, the GHC or the HiPE convention is
used.</a> This calling convention does not
support varargs and requires the prototype of all callees to exactly
match the prototype of the function definition.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">coldcc</span></code>&#8221; - The cold calling convention</dt>
<dd>This calling convention attempts to make code in the caller as
efficient as possible under the assumption that the call is not
commonly executed. As such, these calls often preserve all registers
so that the call does not break any live ranges in the caller side.
This calling convention does not support varargs and requires the
prototype of all callees to exactly match the prototype of the
function definition. Furthermore the inliner doesn&#8217;t consider such function
calls for inlining.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cc</span> <span class="pre">10</span></code>&#8221; - GHC convention</dt>
<dd><p class="first">This calling convention has been implemented specifically for use by
the <a class="reference external" href="http://www.haskell.org/ghc">Glasgow Haskell Compiler (GHC)</a>.
It passes everything in registers, going to extremes to achieve this
by disabling callee save registers. This calling convention should
not be used lightly but only for specific situations such as an
alternative to the <em>register pinning</em> performance technique often
used when implementing functional programming languages. At the
moment only X86 supports this convention and it has the following
limitations:</p>
<ul class="simple">
<li>On <em>X86-32</em> only supports up to 4 bit type parameters. No
floating point types are supported.</li>
<li>On <em>X86-64</em> only supports up to 10 bit type parameters and 6
floating point parameters.</li>
</ul>
<p class="last">This calling convention supports <a class="reference external" href="CodeGenerator.html#id80">tail call
optimization</a> but requires both the
caller and callee are using it.</p>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cc</span> <span class="pre">11</span></code>&#8221; - The HiPE calling convention</dt>
<dd>This calling convention has been implemented specifically for use by
the <a class="reference external" href="http://www.it.uu.se/research/group/hipe/">High-Performance Erlang
(HiPE)</a> compiler, <em>the</em>
native code compiler of the <a class="reference external" href="http://www.erlang.org/download.shtml">Ericsson&#8217;s Open Source Erlang/OTP
system</a>. It uses more
registers for argument passing than the ordinary C calling
convention and defines no callee-saved registers. The calling
convention properly supports <a class="reference external" href="CodeGenerator.html#id80">tail call
optimization</a> but requires that both the
caller and the callee use it. It uses a <em>register pinning</em>
mechanism, similar to GHC&#8217;s convention, for keeping frequently
accessed runtime components pinned to specific hardware registers.
At the moment only X86 supports this convention (both 32 and 64
bit).</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">webkit_jscc</span></code>&#8221; - WebKit&#8217;s JavaScript calling convention</dt>
<dd>This calling convention has been implemented for <a class="reference external" href="https://trac.webkit.org/wiki/FTLJIT">WebKit FTL JIT</a>. It passes arguments on the
stack right to left (as cdecl does), and returns a value in the
platform&#8217;s customary return register.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">anyregcc</span></code>&#8221; - Dynamic calling convention for code patching</dt>
<dd>This is a special convention that supports patching an arbitrary code
sequence in place of a call site. This convention forces the call
arguments into registers but allows them to be dynamically
allocated. This can currently only be used with calls to
llvm.experimental.patchpoint because only this intrinsic records
the location of its arguments in a side table. See <a class="reference internal" href="StackMaps.html"><span class="doc">Stack maps and patch points in LLVM</span></a>.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">preserve_mostcc</span></code>&#8221; - The <cite>PreserveMost</cite> calling convention</dt>
<dd><p class="first">This calling convention attempts to make the code in the caller as
unintrusive as possible. This convention behaves identically to the <cite>C</cite>
calling convention on how arguments and return values are passed, but it
uses a different set of caller/callee-saved registers. This alleviates the
burden of saving and recovering a large register set before and after the
call in the caller. If the arguments are passed in callee-saved registers,
then they will be preserved by the callee across the call. This doesn&#8217;t
apply for values returned in callee-saved registers.</p>
<ul class="simple">
<li>On X86-64 the callee preserves all general purpose registers, except for
R11. R11 can be used as a scratch register. Floating-point registers
(XMMs/YMMs) are not preserved and need to be saved by the caller.</li>
</ul>
<p>The idea behind this convention is to support calls to runtime functions
that have a hot path and a cold path. The hot path is usually a small piece
of code that doesn&#8217;t use many registers. The cold path might need to call out to
another function and therefore only needs to preserve the caller-saved
registers, which haven&#8217;t already been saved by the caller. The
<cite>PreserveMost</cite> calling convention is very similar to the <cite>cold</cite> calling
convention in terms of caller/callee-saved registers, but they are used for
different types of function calls. <cite>coldcc</cite> is for function calls that are
rarely executed, whereas <cite>preserve_mostcc</cite> function calls are intended to be
on the hot path and definitely executed a lot. Furthermore <cite>preserve_mostcc</cite>
doesn&#8217;t prevent the inliner from inlining the function call.</p>
<p class="last">This calling convention will be used by a future version of the ObjectiveC
runtime and should therefore still be considered experimental at this time.
Although this convention was created to optimize certain runtime calls to
the ObjectiveC runtime, it is not limited to this runtime and might be used
by other runtimes in the future too. The current implementation only
supports X86-64, but the intention is to support more architectures in the
future.</p>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">preserve_allcc</span></code>&#8221; - The <cite>PreserveAll</cite> calling convention</dt>
<dd><p class="first">This calling convention attempts to make the code in the caller even less
intrusive than the <cite>PreserveMost</cite> calling convention. This calling
convention also behaves identical to the <cite>C</cite> calling convention on how
arguments and return values are passed, but it uses a different set of
caller/callee-saved registers. This removes the burden of saving and
recovering a large register set before and after the call in the caller. If
the arguments are passed in callee-saved registers, then they will be
preserved by the callee across the call. This doesn&#8217;t apply for values
returned in callee-saved registers.</p>
<ul class="simple">
<li>On X86-64 the callee preserves all general purpose registers, except for
R11. R11 can be used as a scratch register. Furthermore it also preserves
all floating-point registers (XMMs/YMMs).</li>
</ul>
<p>The idea behind this convention is to support calls to runtime functions
that don&#8217;t need to call out to any other functions.</p>
<p class="last">This calling convention, like the <cite>PreserveMost</cite> calling convention, will be
used by a future version of the ObjectiveC runtime and should be considered
experimental at this time.</p>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cxx_fast_tlscc</span></code>&#8221; - The <cite>CXX_FAST_TLS</cite> calling convention for access functions</dt>
<dd><p class="first">Clang generates an access function to access C++-style TLS. The access
function generally has an entry block, an exit block and an initialization
block that is run at the first time. The entry and exit blocks can access
a few TLS IR variables, each access will be lowered to a platform-specific
sequence.</p>
<p>This calling convention aims to minimize overhead in the caller by
preserving as many registers as possible (all the registers that are
perserved on the fast path, composed of the entry and exit blocks).</p>
<p>This calling convention behaves identical to the <cite>C</cite> calling convention on
how arguments and return values are passed, but it uses a different set of
caller/callee-saved registers.</p>
<p>Given that each platform has its own lowering sequence, hence its own set
of preserved registers, we can&#8217;t use the existing <cite>PreserveMost</cite>.</p>
<ul class="last simple">
<li>On X86-64 the callee preserves all general purpose registers, except for
RDI and RAX.</li>
</ul>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cc</span> <span class="pre">&lt;n&gt;</span></code>&#8221; - Numbered convention</dt>
<dd>Any calling convention may be specified by number, allowing
target-specific calling conventions to be used. Target specific
calling conventions start at 64.</dd>
</dl>
<p>More calling conventions can be added/defined on an as-needed basis, to
support Pascal conventions or any other well-known target-independent
convention.</p>
</div>
<div class="section" id="visibility-styles">
<span id="visibilitystyles"></span><h3><a class="toc-backref" href="#id660">Visibility Styles</a><a class="headerlink" href="#visibility-styles" title="永久链接至标题">¶</a></h3>
<p>All Global Variables and Functions have one of the following visibility
styles:</p>
<dl class="docutils">
<dt>&#8220;<code class="docutils literal"><span class="pre">default</span></code>&#8221; - Default style</dt>
<dd>On targets that use the ELF object file format, default visibility
means that the declaration is visible to other modules and, in
shared libraries, means that the declared entity may be overridden.
On Darwin, default visibility means that the declaration is visible
to other modules. Default visibility corresponds to &#8220;external
linkage&#8221; in the language.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">hidden</span></code>&#8221; - Hidden style</dt>
<dd>Two declarations of an object with hidden visibility refer to the
same object if they are in the same shared object. Usually, hidden
visibility indicates that the symbol will not be placed into the
dynamic symbol table, so no other module (executable or shared
library) can reference it directly.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">protected</span></code>&#8221; - Protected style</dt>
<dd>On ELF, protected visibility indicates that the symbol will be
placed in the dynamic symbol table, but that references within the
defining module will bind to the local symbol. That is, the symbol
cannot be overridden by another module.</dd>
</dl>
<p>A symbol with <code class="docutils literal"><span class="pre">internal</span></code> or <code class="docutils literal"><span class="pre">private</span></code> linkage must have <code class="docutils literal"><span class="pre">default</span></code>
visibility.</p>
</div>
<div class="section" id="dll-storage-classes">
<span id="dllstorageclass"></span><h3><a class="toc-backref" href="#id661">DLL Storage Classes</a><a class="headerlink" href="#dll-storage-classes" title="永久链接至标题">¶</a></h3>
<p>All Global Variables, Functions and Aliases can have one of the following
DLL storage class:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dllimport</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">dllimport</span></code>&#8221; causes the compiler to reference a function or variable via
a global pointer to a pointer that is set up by the DLL exporting the
symbol. On Microsoft Windows targets, the pointer name is formed by
combining <code class="docutils literal"><span class="pre">__imp_</span></code> and the function or variable name.</dd>
<dt><code class="docutils literal"><span class="pre">dllexport</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">dllexport</span></code>&#8221; causes the compiler to provide a global pointer to a pointer
in a DLL, so that it can be referenced with the <code class="docutils literal"><span class="pre">dllimport</span></code> attribute. On
Microsoft Windows targets, the pointer name is formed by combining
<code class="docutils literal"><span class="pre">__imp_</span></code> and the function or variable name. Since this storage class
exists for defining a dll interface, the compiler, assembler and linker know
it is externally referenced and must refrain from deleting the symbol.</dd>
</dl>
</div>
<div class="section" id="thread-local-storage-models">
<span id="tls-model"></span><h3><a class="toc-backref" href="#id662">Thread Local Storage Models</a><a class="headerlink" href="#thread-local-storage-models" title="永久链接至标题">¶</a></h3>
<p>A variable may be defined as <code class="docutils literal"><span class="pre">thread_local</span></code>, which means that it will
not be shared by threads (each thread will have a separated copy of the
variable). Not all targets support thread-local variables. Optionally, a
TLS model may be specified:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">localdynamic</span></code></dt>
<dd>For variables that are only used within the current shared library.</dd>
<dt><code class="docutils literal"><span class="pre">initialexec</span></code></dt>
<dd>For variables in modules that will not be loaded dynamically.</dd>
<dt><code class="docutils literal"><span class="pre">localexec</span></code></dt>
<dd>For variables defined in the executable and only used within it.</dd>
</dl>
<p>If no explicit model is given, the &#8220;general dynamic&#8221; model is used.</p>
<p>The models correspond to the ELF TLS models; see <a class="reference external" href="http://people.redhat.com/drepper/tls.pdf">ELF Handling For
Thread-Local Storage</a> for
more information on under which circumstances the different models may
be used. The target may choose a different TLS model if the specified
model is not supported, or if a better choice of model can be made.</p>
<p>A model can also be specified in an alias, but then it only governs how
the alias is accessed. It will not have any effect in the aliasee.</p>
<p>For platforms without linker support of ELF TLS model, the -femulated-tls
flag can be used to generate GCC compatible emulated TLS code.</p>
</div>
<div class="section" id="structure-types">
<span id="namedtypes"></span><h3><a class="toc-backref" href="#id663">Structure Types</a><a class="headerlink" href="#structure-types" title="永久链接至标题">¶</a></h3>
<p>LLVM IR allows you to specify both &#8220;identified&#8221; and &#8220;literal&#8221; <a class="reference internal" href="#t-struct"><span class="std std-ref">structure
types</span></a>. Literal types are uniqued structurally, but identified types
are never uniqued. An <a class="reference internal" href="#t-opaque"><span class="std std-ref">opaque structural type</span></a> can also be used
to forward declare a type that is not yet available.</p>
<p>An example of an identified structure specification is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%mytype</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="nv">%mytype</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
</pre></div>
</div>
<p>Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only
literal types are uniqued in recent versions of LLVM.</p>
</div>
<div class="section" id="global-variables">
<span id="globalvars"></span><h3><a class="toc-backref" href="#id664">Global Variables</a><a class="headerlink" href="#global-variables" title="永久链接至标题">¶</a></h3>
<p>Global variables define regions of memory allocated at compilation time
instead of run-time.</p>
<p>Global variable definitions must be initialized.</p>
<p>Global variables in other translation units can also be declared, in which
case they don&#8217;t have an initializer.</p>
<p>Either global variable definitions or declarations may have an explicit section
to be placed in and may have an optional explicit alignment specified.</p>
<p>A variable may be defined as a global <code class="docutils literal"><span class="pre">constant</span></code>, which indicates that
the contents of the variable will <strong>never</strong> be modified (enabling better
optimization, allowing the global data to be placed in the read-only
section of an executable, etc). Note that variables that need runtime
initialization cannot be marked <code class="docutils literal"><span class="pre">constant</span></code> as there is a store to the
variable.</p>
<p>LLVM explicitly allows <em>declarations</em> of global variables to be marked
constant, even if the final definition of the global is not. This
capability can be used to enable slightly better optimization of the
program, but requires the language definition to guarantee that
optimizations based on the &#8216;constantness&#8217; are valid for the translation
units that do not include the definition.</p>
<p>As SSA values, global variables define pointer values that are in scope
(i.e. they dominate) all basic blocks in the program. Global variables
always define a pointer to their &#8220;content&#8221; type because they describe a
region of memory, and all memory objects in LLVM are accessed through
pointers.</p>
<p>Global variables can be marked with <code class="docutils literal"><span class="pre">unnamed_addr</span></code> which indicates
that the address is not significant, only the content. Constants marked
like this can be merged with other constants if they have the same
initializer. Note that a constant with significant address <em>can</em> be
merged with a <code class="docutils literal"><span class="pre">unnamed_addr</span></code> constant, the result being a constant
whose address is significant.</p>
<p>A global variable may be declared to reside in a target-specific
numbered address space. For targets that support them, address spaces
may affect how optimizations are performed and/or what target
instructions are used to access the variable. The default address space
is zero. The address space qualifier must precede any other attributes.</p>
<p>LLVM allows an explicit section to be specified for globals. If the
target supports it, it will emit globals to the section specified.
Additionally, the global can placed in a comdat if the target has the necessary
support.</p>
<p>By default, global initializers are optimized by assuming that global
variables defined within the module are not modified from their
initial values before the start of the global initializer. This is
true even for variables potentially accessible from outside the
module, including those with external linkage or appearing in
<code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> or dllexported variables. This assumption may be suppressed
by marking the variable with <code class="docutils literal"><span class="pre">externally_initialized</span></code>.</p>
<p>An explicit alignment may be specified for a global, which must be a
power of 2. If not present, or if the alignment is set to zero, the
alignment of the global is set by the target to whatever it feels
convenient. If an explicit alignment is specified, the global is forced
to have exactly that alignment. Targets and optimizers are not allowed
to over-align the global if the global has an assigned section. In this
case, the extra alignment could be observable: for example, code could
assume that the globals are densely packed in their section and try to
iterate over them as an array, alignment padding would break this
iteration. The maximum alignment is <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>.</p>
<p>Globals can also have a <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a>.</p>
<p>Variables and aliases can have a
<a class="reference internal" href="#tls-model"><span class="std std-ref">Thread Local Storage Model</span></a>.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>[@&lt;GlobalVarName&gt; =] [Linkage] [Visibility] [DLLStorageClass] [ThreadLocal]
                     [unnamed_addr] [AddrSpace] [ExternallyInitialized]
                     &lt;global | constant&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]
                     [, section &quot;name&quot;] [, comdat [($name)]]
                     [, align &lt;Alignment&gt;]
</pre></div>
</div>
<p>For example, the following defines a global in a numbered address space
with an initializer, section, and alignment:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="k">constant</span> <span class="kt">float</span> <span class="m">1.0</span><span class="p">,</span> <span class="k">section</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
</pre></div>
</div>
<p>The following example just declares a global variable</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i32</span>
</pre></div>
</div>
<p>The following example defines a thread-local global with the
<code class="docutils literal"><span class="pre">initialexec</span></code> TLS model:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">thread_local</span><span class="p">(</span><span class="k">initialexec</span><span class="p">)</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<span id="functionstructure"></span><h3><a class="toc-backref" href="#id665">Functions</a><a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h3>
<p>LLVM function definitions consist of the &#8220;<code class="docutils literal"><span class="pre">define</span></code>&#8221; keyword, an
optional <a class="reference internal" href="#linkage"><span class="std std-ref">linkage type</span></a>, an optional <a class="reference internal" href="BitCodeFormat.html#visibility"><span class="std std-ref">visibility
style</span></a>, an optional <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a>,
an optional <a class="reference internal" href="#callingconv"><span class="std std-ref">calling convention</span></a>,
an optional <code class="docutils literal"><span class="pre">unnamed_addr</span></code> attribute, a return type, an optional
<a class="reference internal" href="#paramattrs"><span class="std std-ref">parameter attribute</span></a> for the return type, a function
name, a (possibly empty) argument list (each with optional <a class="reference internal" href="#paramattrs"><span class="std std-ref">parameter
attributes</span></a>), optional <a class="reference internal" href="#fnattrs"><span class="std std-ref">function attributes</span></a>,
an optional section, an optional alignment,
an optional <a class="reference internal" href="#langref-comdats"><span class="std std-ref">comdat</span></a>,
an optional <a class="reference internal" href="#gc"><span class="std std-ref">garbage collector name</span></a>, an optional <a class="reference internal" href="#prefixdata"><span class="std std-ref">prefix</span></a>,
an optional <a class="reference internal" href="#prologuedata"><span class="std std-ref">prologue</span></a>,
an optional <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality</span></a>,
an optional list of attached <a class="reference internal" href="#metadata"><span class="std std-ref">metadata</span></a>,
an opening curly brace, a list of basic blocks, and a closing curly brace.</p>
<p>LLVM function declarations consist of the &#8220;<code class="docutils literal"><span class="pre">declare</span></code>&#8221; keyword, an
optional <a class="reference internal" href="#linkage"><span class="std std-ref">linkage type</span></a>, an optional <a class="reference internal" href="BitCodeFormat.html#visibility"><span class="std std-ref">visibility
style</span></a>, an optional <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a>,
an optional <a class="reference internal" href="#callingconv"><span class="std std-ref">calling convention</span></a>,
an optional <code class="docutils literal"><span class="pre">unnamed_addr</span></code> attribute, a return type, an optional
<a class="reference internal" href="#paramattrs"><span class="std std-ref">parameter attribute</span></a> for the return type, a function
name, a possibly empty list of arguments, an optional alignment, an optional
<a class="reference internal" href="#gc"><span class="std std-ref">garbage collector name</span></a>, an optional <a class="reference internal" href="#prefixdata"><span class="std std-ref">prefix</span></a>,
and an optional <a class="reference internal" href="#prologuedata"><span class="std std-ref">prologue</span></a>.</p>
<p>A function definition contains a list of basic blocks, forming the CFG (Control
Flow Graph) for the function. Each basic block may optionally start with a label
(giving the basic block a symbol table entry), contains a list of instructions,
and ends with a <a class="reference internal" href="#terminators"><span class="std std-ref">terminator</span></a> instruction (such as a branch or
function return). If an explicit label is not provided, a block is assigned an
implicit numbered label, using the next value from the same counter as used for
unnamed temporaries (<a class="reference internal" href="#identifiers"><span class="std std-ref">see above</span></a>). For example, if a function
entry block does not have an explicit label, it will be assigned label &#8220;%0&#8221;,
then the first unnamed temporary in that block will be &#8220;%1&#8221;, etc.</p>
<p>The first basic block in a function is special in two ways: it is
immediately executed on entrance to the function, and it is not allowed
to have predecessor basic blocks (i.e. there can not be any branches to
the entry block of a function). Because the block can have no
predecessors, it also cannot have any <a class="reference internal" href="#i-phi"><span class="std std-ref">PHI nodes</span></a>.</p>
<p>LLVM allows an explicit section to be specified for functions. If the
target supports it, it will emit functions to the section specified.
Additionally, the function can be placed in a COMDAT.</p>
<p>An explicit alignment may be specified for a function. If not present,
or if the alignment is set to zero, the alignment of the function is set
by the target to whatever it feels convenient. If an explicit alignment
is specified, the function is forced to have at least that much
alignment. All alignments must be a power of 2.</p>
<p>If the <code class="docutils literal"><span class="pre">unnamed_addr</span></code> attribute is given, the address is known to not
be significant and two identical functions can be merged.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>define [linkage] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])
       [unnamed_addr] [fn Attrs] [section &quot;name&quot;] [comdat [($name)]]
       [align N] [gc] [prefix Constant] [prologue Constant]
       [personality Constant] (!name !N)* { ... }
</pre></div>
</div>
<p>The argument list is a comma separated sequence of arguments where each
argument is of the following form:</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">parameter</span> <span class="n">Attrs</span><span class="p">]</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="aliases">
<span id="langref-aliases"></span><h3><a class="toc-backref" href="#id666">Aliases</a><a class="headerlink" href="#aliases" title="永久链接至标题">¶</a></h3>
<p>Aliases, unlike function or variables, don&#8217;t create any new data. They
are just a new symbol and metadata for an existing position.</p>
<p>Aliases have a name and an aliasee that is either a global value or a
constant expression.</p>
<p>Aliases may have an optional <a class="reference internal" href="#linkage"><span class="std std-ref">linkage type</span></a>, an optional
<a class="reference internal" href="BitCodeFormat.html#visibility"><span class="std std-ref">visibility style</span></a>, an optional <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a> and an optional <a class="reference internal" href="#tls-model"><span class="std std-ref">tls model</span></a>.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">@&lt;</span><span class="n">Name</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="n">Linkage</span><span class="p">]</span> <span class="p">[</span><span class="n">Visibility</span><span class="p">]</span> <span class="p">[</span><span class="n">DLLStorageClass</span><span class="p">]</span> <span class="p">[</span><span class="n">ThreadLocal</span><span class="p">]</span> <span class="p">[</span><span class="n">unnamed_addr</span><span class="p">]</span> <span class="n">alias</span> <span class="o">&lt;</span><span class="n">AliaseeTy</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">AliaseeTy</span><span class="o">&gt;*</span> <span class="o">@&lt;</span><span class="n">Aliasee</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The linkage must be one of <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">internal</span></code>, <code class="docutils literal"><span class="pre">linkonce</span></code>, <code class="docutils literal"><span class="pre">weak</span></code>,
<code class="docutils literal"><span class="pre">linkonce_odr</span></code>, <code class="docutils literal"><span class="pre">weak_odr</span></code>, <code class="docutils literal"><span class="pre">external</span></code>. Note that some system linkers
might not correctly handle dropping a weak symbol that is aliased.</p>
<p>Aliases that are not <code class="docutils literal"><span class="pre">unnamed_addr</span></code> are guaranteed to have the same address as
the aliasee expression. <code class="docutils literal"><span class="pre">unnamed_addr</span></code> ones are only guaranteed to point
to the same content.</p>
<p>Since aliases are only a second name, some restrictions apply, of which
some can only be checked when producing an object file:</p>
<ul class="simple">
<li>The expression defining the aliasee must be computable at assembly
time. Since it is just a name, no relocations can be used.</li>
<li>No alias in the expression can be weak as the possibility of the
intermediate alias being overridden cannot be represented in an
object file.</li>
<li>No global value in the expression can be a declaration, since that
would require a relocation, which is not possible.</li>
</ul>
</div>
<div class="section" id="comdats">
<span id="langref-comdats"></span><h3><a class="toc-backref" href="#id667">Comdats</a><a class="headerlink" href="#comdats" title="永久链接至标题">¶</a></h3>
<p>Comdat IR provides access to COFF and ELF object file COMDAT functionality.</p>
<p>Comdats have a name which represents the COMDAT key. All global objects that
specify this key will only end up in the final object file if the linker chooses
that key over some other key. Aliases are placed in the same COMDAT that their
aliasee computes to, if any.</p>
<p>Comdats have a selection kind to provide input on how the linker should
choose between keys in two different object files.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$&lt;Name&gt; = comdat SelectionKind
</pre></div>
</div>
<p>The selection kind must be one of the following:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">any</span></code></dt>
<dd>The linker may choose any COMDAT key, the choice is arbitrary.</dd>
<dt><code class="docutils literal"><span class="pre">exactmatch</span></code></dt>
<dd>The linker may choose any COMDAT key but the sections must contain the
same data.</dd>
<dt><code class="docutils literal"><span class="pre">largest</span></code></dt>
<dd>The linker will choose the section containing the largest COMDAT key.</dd>
<dt><code class="docutils literal"><span class="pre">noduplicates</span></code></dt>
<dd>The linker requires that only section with this COMDAT key exist.</dd>
<dt><code class="docutils literal"><span class="pre">samesize</span></code></dt>
<dd>The linker may choose any COMDAT key but the sections must contain the
same amount of data.</dd>
</dl>
<p>Note that the Mach-O platform doesn&#8217;t support COMDATs and ELF only supports
<code class="docutils literal"><span class="pre">any</span></code> as a selection kind.</p>
<p>Here is an example of a COMDAT group where a function will only be selected if
the COMDAT key&#8217;s section is the largest:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>$foo = comdat largest
@foo = global i32 2, comdat($foo)

define void @bar() comdat($foo) {
  ret void
}
</pre></div>
</div>
<p>As a syntactic sugar the <code class="docutils literal"><span class="pre">$name</span></code> can be omitted if the name is the same as
the global name:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>$foo = comdat any
@foo = global i32 2, comdat
</pre></div>
</div>
<p>In a COFF object file, this will create a COMDAT section with selection kind
<code class="docutils literal"><span class="pre">IMAGE_COMDAT_SELECT_LARGEST</span></code> containing the contents of the <code class="docutils literal"><span class="pre">&#64;foo</span></code> symbol
and another COMDAT section with selection kind
<code class="docutils literal"><span class="pre">IMAGE_COMDAT_SELECT_ASSOCIATIVE</span></code> which is associated with the first COMDAT
section and contains the contents of the <code class="docutils literal"><span class="pre">&#64;bar</span></code> symbol.</p>
<p>There are some restrictions on the properties of the global object.
It, or an alias to it, must have the same name as the COMDAT group when
targeting COFF.
The contents and size of this object may be used during link-time to determine
which COMDAT groups get selected depending on the selection kind.
Because the name of the object must match the name of the COMDAT group, the
linkage of the global object must not be local; local symbols can get renamed
if a collision occurs in the symbol table.</p>
<p>The combined use of COMDATS and section attributes may yield surprising results.
For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>$foo = comdat any
$bar = comdat any
@g1 = global i32 42, section &quot;sec&quot;, comdat($foo)
@g2 = global i32 42, section &quot;sec&quot;, comdat($bar)
</pre></div>
</div>
<p>From the object file perspective, this requires the creation of two sections
with the same name. This is necessary because both globals belong to different
COMDAT groups and COMDATs, at the object file level, are represented by
sections.</p>
<p>Note that certain IR constructs like global variables and functions may
create COMDATs in the object file in addition to any which are specified using
COMDAT IR. This arises when the code generator is configured to emit globals
in individual sections (e.g. when <cite>-data-sections</cite> or <cite>-function-sections</cite>
is supplied to <cite>llc</cite>).</p>
</div>
<div class="section" id="named-metadata">
<span id="namedmetadatastructure"></span><h3><a class="toc-backref" href="#id668">Named Metadata</a><a class="headerlink" href="#named-metadata" title="永久链接至标题">¶</a></h3>
<p>Named metadata is a collection of metadata. <a class="reference internal" href="#metadata"><span class="std std-ref">Metadata
nodes</span></a> (but not metadata strings) are the only valid
operands for a named metadata.</p>
<ol class="arabic simple">
<li>Named metadata are represented as a string of characters with the
metadata prefix. The rules for metadata names are the same as for
identifiers, but quoted names are not allowed. <code class="docutils literal"><span class="pre">&quot;\xx&quot;</span></code> type escapes
are still valid, which allows any character to be part of a name.</li>
</ol>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!&quot;zero&quot;}
!1 = !{!&quot;one&quot;}
!2 = !{!&quot;two&quot;}
; A named metadata.
!name = !{!0, !1, !2}
</pre></div>
</div>
</div>
<div class="section" id="parameter-attributes">
<span id="paramattrs"></span><h3><a class="toc-backref" href="#id669">Parameter Attributes</a><a class="headerlink" href="#parameter-attributes" title="永久链接至标题">¶</a></h3>
<p>The return type and each parameter of a function type may have a set of
<em>parameter attributes</em> associated with them. Parameter attributes are
used to communicate additional information about the result or
parameters of a function. Parameter attributes are considered to be part
of the function, not of the function type, so functions with different
parameter attributes can have the same function type.</p>
<p>Parameter attributes are simple keywords that follow the type specified.
If multiple parameter attributes are needed, they are space separated.
For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">declare</span> <span class="k">i32</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">noalias</span> <span class="k">nocapture</span><span class="p">,</span> <span class="p">...)</span>
<span class="k">declare</span> <span class="k">i32</span> <span class="vg">@atoi</span><span class="p">(</span><span class="k">i8</span> <span class="k">zeroext</span><span class="p">)</span>
<span class="k">declare</span> <span class="k">signext</span> <span class="k">i8</span> <span class="vg">@returns_signed_char</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that any attributes for the function result (<code class="docutils literal"><span class="pre">nounwind</span></code>,
<code class="docutils literal"><span class="pre">readonly</span></code>) come immediately after the argument list.</p>
<p>Currently, only the following parameter attributes are defined:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">zeroext</span></code></dt>
<dd>This indicates to the code generator that the parameter or return
value should be zero-extended to the extent required by the target&#8217;s
ABI (which is usually 32-bits, but is 8-bits for a i1 on x86-64) by
the caller (for a parameter) or the callee (for a return value).</dd>
<dt><code class="docutils literal"><span class="pre">signext</span></code></dt>
<dd>This indicates to the code generator that the parameter or return
value should be sign-extended to the extent required by the target&#8217;s
ABI (which is usually 32-bits) by the caller (for a parameter) or
the callee (for a return value).</dd>
<dt><code class="docutils literal"><span class="pre">inreg</span></code></dt>
<dd>This indicates that this parameter or return value should be treated
in a special target-dependent fashion while emitting code for
a function call or return (usually, by putting it in a register as
opposed to memory, though some targets use it to distinguish between
two different kinds of registers). Use of this attribute is
target-specific.</dd>
<dt><code class="docutils literal"><span class="pre">byval</span></code></dt>
<dd><p class="first">This indicates that the pointer parameter should really be passed by
value to the function. The attribute implies that a hidden copy of
the pointee is made between the caller and the callee, so the callee
is unable to modify the value in the caller. This attribute is only
valid on LLVM pointer arguments. It is generally used to pass
structs and arrays by value, but is also valid on pointers to
scalars. The copy is considered to belong to the caller not the
callee (for example, <code class="docutils literal"><span class="pre">readonly</span></code> functions should not write to
<code class="docutils literal"><span class="pre">byval</span></code> parameters). This is not a valid attribute for return
values.</p>
<p class="last">The byval attribute also supports specifying an alignment with the
align attribute. It indicates the alignment of the stack slot to
form and the known alignment of the pointer specified to the call
site. If the alignment is not specified, then the code generator
makes a target-specific assumption.</p>
</dd>
</dl>
<p id="attr-inalloca"><code class="docutils literal"><span class="pre">inalloca</span></code></p>
<blockquote>
<div><p>The <code class="docutils literal"><span class="pre">inalloca</span></code> argument attribute allows the caller to take the
address of outgoing stack arguments. An <code class="docutils literal"><span class="pre">inalloca</span></code> argument must
be a pointer to stack memory produced by an <code class="docutils literal"><span class="pre">alloca</span></code> instruction.
The alloca, or argument allocation, must also be tagged with the
inalloca keyword. Only the last argument may have the <code class="docutils literal"><span class="pre">inalloca</span></code>
attribute, and that argument is guaranteed to be passed in memory.</p>
<p>An argument allocation may be used by a call at most once because
the call may deallocate it. The <code class="docutils literal"><span class="pre">inalloca</span></code> attribute cannot be
used in conjunction with other attributes that affect argument
storage, like <code class="docutils literal"><span class="pre">inreg</span></code>, <code class="docutils literal"><span class="pre">nest</span></code>, <code class="docutils literal"><span class="pre">sret</span></code>, or <code class="docutils literal"><span class="pre">byval</span></code>. The
<code class="docutils literal"><span class="pre">inalloca</span></code> attribute also disables LLVM&#8217;s implicit lowering of
large aggregate return values, which means that frontend authors
must lower them with <code class="docutils literal"><span class="pre">sret</span></code> pointers.</p>
<p>When the call site is reached, the argument allocation must have
been the most recent stack allocation that is still live, or the
results are undefined. It is possible to allocate additional stack
space after an argument allocation and before its call site, but it
must be cleared off with <a class="reference internal" href="#int-stackrestore"><span class="std std-ref">llvm.stackrestore</span></a>.</p>
<p>See <a class="reference internal" href="InAlloca.html"><span class="doc">Design and Usage of the InAlloca Attribute</span></a> for more information on how to use this
attribute.</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sret</span></code></dt>
<dd>This indicates that the pointer parameter specifies the address of a
structure that is the return value of the function in the source
program. This pointer must be guaranteed by the caller to be valid:
loads and stores to the structure may be assumed by the callee
not to trap and to be properly aligned. This may only be applied to
the first parameter. This is not a valid attribute for return
values.</dd>
<dt><code class="docutils literal"><span class="pre">align</span> <span class="pre">&lt;n&gt;</span></code></dt>
<dd><p class="first">This indicates that the pointer value may be assumed by the optimizer to
have the specified alignment.</p>
<p class="last">Note that this attribute has additional semantics when combined with the
<code class="docutils literal"><span class="pre">byval</span></code> attribute.</p>
</dd>
</dl>
<dl class="docutils" id="noalias">
<dt><code class="docutils literal"><span class="pre">noalias</span></code></dt>
<dd><p class="first">This indicates that objects accessed via pointer values
<a class="reference internal" href="#pointeraliasing"><span class="std std-ref">based</span></a> on the argument or return value are not also
accessed, during the execution of the function, via pointer values not
<em>based</em> on the argument or return value. The attribute on a return value
also has additional semantics described below. The caller shares the
responsibility with the callee for ensuring that these requirements are met.
For further details, please see the discussion of the NoAlias response in
<a class="reference internal" href="AliasAnalysis.html#must-may-or-no"><span class="std std-ref">alias analysis</span></a>.</p>
<p>Note that this definition of <code class="docutils literal"><span class="pre">noalias</span></code> is intentionally similar
to the definition of <code class="docutils literal"><span class="pre">restrict</span></code> in C99 for function arguments.</p>
<p class="last">For function return values, C99&#8217;s <code class="docutils literal"><span class="pre">restrict</span></code> is not meaningful,
while LLVM&#8217;s <code class="docutils literal"><span class="pre">noalias</span></code> is. Furthermore, the semantics of the <code class="docutils literal"><span class="pre">noalias</span></code>
attribute on return values are stronger than the semantics of the attribute
when used on function arguments. On function return values, the <code class="docutils literal"><span class="pre">noalias</span></code>
attribute indicates that the function acts like a system memory allocation
function, returning a pointer to allocated storage disjoint from the
storage for any other object accessible to the caller.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">nocapture</span></code></dt>
<dd>This indicates that the callee does not make any copies of the
pointer that outlive the callee itself. This is not a valid
attribute for return values.</dd>
</dl>
<dl class="docutils" id="nest">
<dt><code class="docutils literal"><span class="pre">nest</span></code></dt>
<dd>This indicates that the pointer parameter can be excised using the
<a class="reference internal" href="#int-trampoline"><span class="std std-ref">trampoline intrinsics</span></a>. This is not a valid
attribute for return values and can only be applied to one parameter.</dd>
<dt><code class="docutils literal"><span class="pre">returned</span></code></dt>
<dd>This indicates that the function always returns the argument as its return
value. This is an optimization hint to the code generator when generating
the caller, allowing tail call optimization and omission of register saves
and restores in some cases; it is not checked or enforced when generating
the callee. The parameter and the function return type must be valid
operands for the <a class="reference internal" href="#i-bitcast"><span class="std std-ref">bitcast instruction</span></a>. This is not a
valid attribute for return values and can only be applied to one parameter.</dd>
<dt><code class="docutils literal"><span class="pre">nonnull</span></code></dt>
<dd>This indicates that the parameter or return pointer is not null. This
attribute may only be applied to pointer typed parameters. This is not
checked or enforced by LLVM, the caller must ensure that the pointer
passed in is non-null, or the callee must ensure that the returned pointer
is non-null.</dd>
<dt><code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code></dt>
<dd>This indicates that the parameter or return pointer is dereferenceable. This
attribute may only be applied to pointer typed parameters. A pointer that
is dereferenceable can be loaded from speculatively without a risk of
trapping. The number of bytes known to be dereferenceable must be provided
in parentheses. It is legal for the number of bytes to be less than the
size of the pointee type. The <code class="docutils literal"><span class="pre">nonnull</span></code> attribute does not imply
dereferenceability (consider a pointer to one element past the end of an
array), however <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code> does imply <code class="docutils literal"><span class="pre">nonnull</span></code> in
<code class="docutils literal"><span class="pre">addrspace(0)</span></code> (which is the default address space).</dd>
<dt><code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code></dt>
<dd>This indicates that the parameter or return value isn&#8217;t both
non-null and non-dereferenceable (up to <code class="docutils literal"><span class="pre">&lt;n&gt;</span></code> bytes) at the same
time. All non-null pointers tagged with
<code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code> are <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code>.
For address space 0 <code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code> implies that
a pointer is exactly one of <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code> or <code class="docutils literal"><span class="pre">null</span></code>,
and in other address spaces <code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code>
implies that a pointer is at least one of <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code>
or <code class="docutils literal"><span class="pre">null</span></code> (i.e. it may be both <code class="docutils literal"><span class="pre">null</span></code> and
<code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code>). This attribute may only be applied to
pointer typed parameters.</dd>
</dl>
</div>
<div class="section" id="garbage-collector-strategy-names">
<span id="gc"></span><h3><a class="toc-backref" href="#id670">Garbage Collector Strategy Names</a><a class="headerlink" href="#garbage-collector-strategy-names" title="永久链接至标题">¶</a></h3>
<p>Each function may specify a garbage collector strategy name, which is simply a
string:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">gc</span> <span class="s">&quot;name&quot;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>The supported values of <em>name</em> includes those <a class="reference internal" href="GarbageCollection.html#builtin-gc-strategies"><span class="std std-ref">built in to LLVM</span></a> and any provided by loaded plugins. Specifying a GC
strategy will cause the compiler to alter its output in order to support the
named garbage collection algorithm. Note that LLVM itself does not contain a
garbage collector, this functionality is restricted to generating machine code
which can interoperate with a collector provided externally.</p>
</div>
<div class="section" id="prefix-data">
<span id="prefixdata"></span><h3><a class="toc-backref" href="#id671">Prefix Data</a><a class="headerlink" href="#prefix-data" title="永久链接至标题">¶</a></h3>
<p>Prefix data is data associated with a function which the code
generator will emit immediately before the function&#8217;s entrypoint.
The purpose of this feature is to allow frontends to associate
language-specific runtime metadata with specific functions and make it
available through the function pointer while still allowing the
function pointer to be called.</p>
<p>To access the data for a given function, a program may bitcast the
function pointer to a pointer to the constant&#8217;s type and dereference
index -1. This implies that the IR symbol points just past the end of
the prefix data. For instance, take the example of a function annotated
with a single <code class="docutils literal"><span class="pre">i32</span></code>,</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">prefix</span> <span class="k">i32</span> <span class="m">123</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>The prefix data can be referenced as,</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">void</span><span class="p">*</span> <span class="p">()</span> <span class="vg">@f</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>
<span class="nv">%a</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">-1</span>
<span class="nv">%b</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%a</span>
</pre></div>
</div>
<p>Prefix data is laid out as if it were an initializer for a global variable
of the prefix data&#8217;s type. The function will be placed such that the
beginning of the prefix data is aligned. This means that if the size
of the prefix data is not a multiple of the alignment size, the
function&#8217;s entrypoint will not be aligned. If alignment of the
function&#8217;s entrypoint is desired, padding must be added to the prefix
data.</p>
<p>A function may have prefix data but no body. This has similar semantics
to the <code class="docutils literal"><span class="pre">available_externally</span></code> linkage in that the data may be used by the
optimizers but will not be emitted in the object file.</p>
</div>
<div class="section" id="prologue-data">
<span id="prologuedata"></span><h3><a class="toc-backref" href="#id672">Prologue Data</a><a class="headerlink" href="#prologue-data" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">prologue</span></code> attribute allows arbitrary code (encoded as bytes) to
be inserted prior to the function body. This can be used for enabling
function hot-patching and instrumentation.</p>
<p>To maintain the semantics of ordinary function calls, the prologue data must
have a particular format. Specifically, it must begin with a sequence of
bytes which decode to a sequence of machine instructions, valid for the
module&#8217;s target, which transfer control to the point immediately succeeding
the prologue data, without performing any other visible action. This allows
the inliner and other passes to reason about the semantics of the function
definition without needing to reason about the prologue data. Obviously this
makes the format of the prologue data highly target dependent.</p>
<p>A trivial example of valid prologue data for the x86 architecture is <code class="docutils literal"><span class="pre">i8</span> <span class="pre">144</span></code>,
which encodes the <code class="docutils literal"><span class="pre">nop</span></code> instruction:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>define void @f() prologue i8 144 { ... }
</pre></div>
</div>
<p>Generally prologue data can be formed by encoding a relative branch instruction
which skips the metadata, as in this example of valid prologue data for the
x86_64 architecture, where the first two bytes encode <code class="docutils literal"><span class="pre">jmp</span> <span class="pre">.+10</span></code>:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>%0 = type &lt;{ i8, i8, i8* }&gt;

define void @f() prologue %0 &lt;{ i8 235, i8 8, i8* @md}&gt; { ... }
</pre></div>
</div>
<p>A function may have prologue data but no body. This has similar semantics
to the <code class="docutils literal"><span class="pre">available_externally</span></code> linkage in that the data may be used by the
optimizers but will not be emitted in the object file.</p>
</div>
<div class="section" id="personality-function">
<span id="personalityfn"></span><h3><a class="toc-backref" href="#id673">Personality Function</a><a class="headerlink" href="#personality-function" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">personality</span></code> attribute permits functions to specify what function
to use for exception handling.</p>
</div>
<div class="section" id="attribute-groups">
<span id="attrgrp"></span><h3><a class="toc-backref" href="#id674">Attribute Groups</a><a class="headerlink" href="#attribute-groups" title="永久链接至标题">¶</a></h3>
<p>Attribute groups are groups of attributes that are referenced by objects within
the IR. They are important for keeping <code class="docutils literal"><span class="pre">.ll</span></code> files readable, because a lot of
functions will use the same set of attributes. In the degenerative case of a
<code class="docutils literal"><span class="pre">.ll</span></code> file that corresponds to a single <code class="docutils literal"><span class="pre">.c</span></code> file, the single attribute
group will capture the important command line flags used to build that file.</p>
<p>An attribute group is a module-level object. To use an attribute group, an
object references the attribute group&#8217;s ID (e.g. <code class="docutils literal"><span class="pre">#37</span></code>). An object may refer
to more than one attribute group. In that situation, the attributes from the
different groups are merged.</p>
<p>Here is an example of attribute groups for a function that should always be
inlined, has a stack alignment of 4, and which shouldn&#8217;t use SSE instructions:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Target-independent attributes:</span>
<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">alwaysinline</span> <span class="k">alignstack</span><span class="p">=</span><span class="m">4</span> <span class="p">}</span>

<span class="c">; Target-dependent attributes:</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;no-sse&quot;</span> <span class="p">}</span>

<span class="c">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="vg">#0</span> <span class="vg">#1</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-attributes">
<span id="fnattrs"></span><h3><a class="toc-backref" href="#id675">Function Attributes</a><a class="headerlink" href="#function-attributes" title="永久链接至标题">¶</a></h3>
<p>Function attributes are set to communicate additional information about
a function. Function attributes are considered to be part of the
function, not of the function type, so functions with different function
attributes can have the same function type.</p>
<p>Function attributes are simple keywords that follow the type specified.
If multiple attributes are needed, they are space separated. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">noinline</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">alwaysinline</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">alwaysinline</span> <span class="k">optsize</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">optsize</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">alignstack(&lt;n&gt;)</span></code></dt>
<dd>This attribute indicates that, when emitting the prologue and
epilogue, the backend should forcibly align the stack pointer.
Specify the desired alignment, which must be a power of two, in
parentheses.</dd>
<dt><code class="docutils literal"><span class="pre">alwaysinline</span></code></dt>
<dd>This attribute indicates that the inliner should attempt to inline
this function into callers whenever possible, ignoring any active
inlining size threshold for this caller.</dd>
<dt><code class="docutils literal"><span class="pre">builtin</span></code></dt>
<dd>This indicates that the callee function at a call site should be
recognized as a built-in function, even though the function&#8217;s declaration
uses the <code class="docutils literal"><span class="pre">nobuiltin</span></code> attribute. This is only valid at call sites for
direct calls to functions that are declared with the <code class="docutils literal"><span class="pre">nobuiltin</span></code>
attribute.</dd>
<dt><code class="docutils literal"><span class="pre">cold</span></code></dt>
<dd>This attribute indicates that this function is rarely called. When
computing edge weights, basic blocks post-dominated by a cold
function call are also considered to be cold; and, thus, given low
weight.</dd>
<dt><code class="docutils literal"><span class="pre">convergent</span></code></dt>
<dd>This attribute indicates that the callee is dependent on a convergent
thread execution pattern under certain parallel execution models.
Transformations that are execution model agnostic may not make the execution
of a convergent operation control dependent on any additional values.</dd>
<dt><code class="docutils literal"><span class="pre">inaccessiblememonly</span></code></dt>
<dd>This attribute indicates that the function may only access memory that
is not accessible by the module being compiled. This is a weaker form
of <code class="docutils literal"><span class="pre">readnone</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">inaccessiblemem_or_argmemonly</span></code></dt>
<dd>This attribute indicates that the function may only access memory that is
either not accessible by the module being compiled, or is pointed to
by its pointer arguments. This is a weaker form of  <code class="docutils literal"><span class="pre">argmemonly</span></code></dd>
<dt><code class="docutils literal"><span class="pre">inlinehint</span></code></dt>
<dd>This attribute indicates that the source code contained a hint that
inlining this function is desirable (such as the &#8220;inline&#8221; keyword in
C/C++). It is just a hint; it imposes no requirements on the
inliner.</dd>
<dt><code class="docutils literal"><span class="pre">jumptable</span></code></dt>
<dd>This attribute indicates that the function should be added to a
jump-instruction table at code-generation time, and that all address-taken
references to this function should be replaced with a reference to the
appropriate jump-instruction-table function pointer. Note that this creates
a new pointer for the original function, which means that code that depends
on function-pointer identity can break. So, any function annotated with
<code class="docutils literal"><span class="pre">jumptable</span></code> must also be <code class="docutils literal"><span class="pre">unnamed_addr</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">minsize</span></code></dt>
<dd>This attribute suggests that optimization passes and code generator
passes make choices that keep the code size of this function as small
as possible and perform optimizations that may sacrifice runtime
performance in order to minimize the size of the generated code.</dd>
<dt><code class="docutils literal"><span class="pre">naked</span></code></dt>
<dd>This attribute disables prologue / epilogue emission for the
function. This can have very system-specific consequences.</dd>
<dt><code class="docutils literal"><span class="pre">nobuiltin</span></code></dt>
<dd>This indicates that the callee function at a call site is not recognized as
a built-in function. LLVM will retain the original call and not replace it
with equivalent code based on the semantics of the built-in function, unless
the call site uses the <code class="docutils literal"><span class="pre">builtin</span></code> attribute. This is valid at call sites
and on function declarations and definitions.</dd>
<dt><code class="docutils literal"><span class="pre">noduplicate</span></code></dt>
<dd><p class="first">This attribute indicates that calls to the function cannot be
duplicated. A call to a <code class="docutils literal"><span class="pre">noduplicate</span></code> function may be moved
within its parent function, but may not be duplicated within
its parent function.</p>
<p class="last">A function containing a <code class="docutils literal"><span class="pre">noduplicate</span></code> call may still
be an inlining candidate, provided that the call is not
duplicated by inlining. That implies that the function has
internal linkage and only has one call site, so the original
call is dead after inlining.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">noimplicitfloat</span></code></dt>
<dd>This attributes disables implicit floating point instructions.</dd>
<dt><code class="docutils literal"><span class="pre">noinline</span></code></dt>
<dd>This attribute indicates that the inliner should never inline this
function in any situation. This attribute may not be used together
with the <code class="docutils literal"><span class="pre">alwaysinline</span></code> attribute.</dd>
<dt><code class="docutils literal"><span class="pre">nonlazybind</span></code></dt>
<dd>This attribute suppresses lazy symbol binding for the function. This
may make calls to the function faster, at the cost of extra program
startup time if the function is not called during program startup.</dd>
<dt><code class="docutils literal"><span class="pre">noredzone</span></code></dt>
<dd>This attribute indicates that the code generator should not use a
red zone, even if the target-specific ABI normally permits it.</dd>
<dt><code class="docutils literal"><span class="pre">noreturn</span></code></dt>
<dd>This function attribute indicates that the function never returns
normally. This produces undefined behavior at runtime if the
function ever does dynamically return.</dd>
<dt><code class="docutils literal"><span class="pre">norecurse</span></code></dt>
<dd>This function attribute indicates that the function does not call itself
either directly or indirectly down any possible call path. This produces
undefined behavior at runtime if the function ever does recurse.</dd>
<dt><code class="docutils literal"><span class="pre">nounwind</span></code></dt>
<dd>This function attribute indicates that the function never raises an
exception. If the function does raise an exception, its runtime
behavior is undefined. However, functions marked nounwind may still
trap or generate asynchronous exceptions. Exception handling schemes
that are recognized by LLVM to handle asynchronous exceptions, such
as SEH, will still provide their implementation defined semantics.</dd>
<dt><code class="docutils literal"><span class="pre">optnone</span></code></dt>
<dd><p class="first">This function attribute indicates that most optimization passes will skip
this function, with the exception of interprocedural optimization passes.
Code generation defaults to the &#8220;fast&#8221; instruction selector.
This attribute cannot be used together with the <code class="docutils literal"><span class="pre">alwaysinline</span></code>
attribute; this attribute is also incompatible
with the <code class="docutils literal"><span class="pre">minsize</span></code> attribute and the <code class="docutils literal"><span class="pre">optsize</span></code> attribute.</p>
<p class="last">This attribute requires the <code class="docutils literal"><span class="pre">noinline</span></code> attribute to be specified on
the function as well, so the function is never inlined into any caller.
Only functions with the <code class="docutils literal"><span class="pre">alwaysinline</span></code> attribute are valid
candidates for inlining into the body of this function.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">optsize</span></code></dt>
<dd>This attribute suggests that optimization passes and code generator
passes make choices that keep the code size of this function low,
and otherwise do optimizations specifically to reduce code size as
long as they do not significantly impact runtime performance.</dd>
<dt><code class="docutils literal"><span class="pre">readnone</span></code></dt>
<dd><p class="first">On a function, this attribute indicates that the function computes its
result (or decides to unwind an exception) based strictly on its arguments,
without dereferencing any pointer arguments or otherwise accessing
any mutable state (e.g. memory, control registers, etc) visible to
caller functions. It does not write through any pointer arguments
(including <code class="docutils literal"><span class="pre">byval</span></code> arguments) and never changes any state visible
to callers. This means that it cannot unwind exceptions by calling
the <code class="docutils literal"><span class="pre">C++</span></code> exception throwing methods.</p>
<p class="last">On an argument, this attribute indicates that the function does not
dereference that pointer argument, even though it may read or write the
memory that the pointer points to if accessed through other pointers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">readonly</span></code></dt>
<dd><p class="first">On a function, this attribute indicates that the function does not write
through any pointer arguments (including <code class="docutils literal"><span class="pre">byval</span></code> arguments) or otherwise
modify any state (e.g. memory, control registers, etc) visible to
caller functions. It may dereference pointer arguments and read
state that may be set in the caller. A readonly function always
returns the same value (or unwinds an exception identically) when
called with the same set of arguments and global state. It cannot
unwind an exception by calling the <code class="docutils literal"><span class="pre">C++</span></code> exception throwing
methods.</p>
<p class="last">On an argument, this attribute indicates that the function does not write
through this pointer argument, even though it may write to the memory that
the pointer points to.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">argmemonly</span></code></dt>
<dd>This attribute indicates that the only memory accesses inside function are
loads and stores from objects pointed to by its pointer-typed arguments,
with arbitrary offsets. Or in other words, all memory operations in the
function can refer to memory only using pointers based on its function
arguments.
Note that <code class="docutils literal"><span class="pre">argmemonly</span></code> can be used together with <code class="docutils literal"><span class="pre">readonly</span></code> attribute
in order to specify that function reads only from its arguments.</dd>
<dt><code class="docutils literal"><span class="pre">returns_twice</span></code></dt>
<dd>This attribute indicates that this function can return twice. The C
<code class="docutils literal"><span class="pre">setjmp</span></code> is an example of such a function. The compiler disables
some optimizations (like tail calls) in the caller of these
functions.</dd>
<dt><code class="docutils literal"><span class="pre">safestack</span></code></dt>
<dd><p class="first">This attribute indicates that
<a class="reference external" href="http://clang.llvm.org/docs/SafeStack.html">SafeStack</a>
protection is enabled for this function.</p>
<p class="last">If a function that has a <code class="docutils literal"><span class="pre">safestack</span></code> attribute is inlined into a
function that doesn&#8217;t have a <code class="docutils literal"><span class="pre">safestack</span></code> attribute or which has an
<code class="docutils literal"><span class="pre">ssp</span></code>, <code class="docutils literal"><span class="pre">sspstrong</span></code> or <code class="docutils literal"><span class="pre">sspreq</span></code> attribute, then the resulting
function will have a <code class="docutils literal"><span class="pre">safestack</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">sanitize_address</span></code></dt>
<dd>This attribute indicates that AddressSanitizer checks
(dynamic address safety analysis) are enabled for this function.</dd>
<dt><code class="docutils literal"><span class="pre">sanitize_memory</span></code></dt>
<dd>This attribute indicates that MemorySanitizer checks (dynamic detection
of accesses to uninitialized memory) are enabled for this function.</dd>
<dt><code class="docutils literal"><span class="pre">sanitize_thread</span></code></dt>
<dd>This attribute indicates that ThreadSanitizer checks
(dynamic thread safety analysis) are enabled for this function.</dd>
<dt><code class="docutils literal"><span class="pre">ssp</span></code></dt>
<dd><p class="first">This attribute indicates that the function should emit a stack
smashing protector. It is in the form of a &#8220;canary&#8221; &#8212; a random value
placed on the stack before the local variables that&#8217;s checked upon
return from the function to see if it has been overwritten. A
heuristic is used to determine if a function needs stack protectors
or not. The heuristic used will enable protectors for functions with:</p>
<ul class="simple">
<li>Character arrays larger than <code class="docutils literal"><span class="pre">ssp-buffer-size</span></code> (default 8).</li>
<li>Aggregates containing character arrays larger than <code class="docutils literal"><span class="pre">ssp-buffer-size</span></code>.</li>
<li>Calls to alloca() with variable sizes or constant sizes greater than
<code class="docutils literal"><span class="pre">ssp-buffer-size</span></code>.</li>
</ul>
<p>Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.</p>
<p class="last">If a function that has an <code class="docutils literal"><span class="pre">ssp</span></code> attribute is inlined into a
function that doesn&#8217;t have an <code class="docutils literal"><span class="pre">ssp</span></code> attribute, then the resulting
function will have an <code class="docutils literal"><span class="pre">ssp</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">sspreq</span></code></dt>
<dd><p class="first">This attribute indicates that the function should <em>always</em> emit a
stack smashing protector. This overrides the <code class="docutils literal"><span class="pre">ssp</span></code> function
attribute.</p>
<p>Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
The specific layout rules are:</p>
<ol class="arabic simple">
<li>Large arrays and structures containing large arrays
(<code class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">ssp-buffer-size</span></code>) are closest to the stack protector.</li>
<li>Small arrays and structures containing small arrays
(<code class="docutils literal"><span class="pre">&lt;</span> <span class="pre">ssp-buffer-size</span></code>) are 2nd closest to the protector.</li>
<li>Variables that have had their address taken are 3rd closest to the
protector.</li>
</ol>
<p class="last">If a function that has an <code class="docutils literal"><span class="pre">sspreq</span></code> attribute is inlined into a
function that doesn&#8217;t have an <code class="docutils literal"><span class="pre">sspreq</span></code> attribute or which has an
<code class="docutils literal"><span class="pre">ssp</span></code> or <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute, then the resulting function will have
an <code class="docutils literal"><span class="pre">sspreq</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">sspstrong</span></code></dt>
<dd><p class="first">This attribute indicates that the function should emit a stack smashing
protector. This attribute causes a strong heuristic to be used when
determining if a function needs stack protectors. The strong heuristic
will enable protectors for functions with:</p>
<ul class="simple">
<li>Arrays of any size and type</li>
<li>Aggregates containing an array of any size and type.</li>
<li>Calls to alloca().</li>
<li>Local variables that have had their address taken.</li>
</ul>
<p>Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
The specific layout rules are:</p>
<ol class="arabic simple">
<li>Large arrays and structures containing large arrays
(<code class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">ssp-buffer-size</span></code>) are closest to the stack protector.</li>
<li>Small arrays and structures containing small arrays
(<code class="docutils literal"><span class="pre">&lt;</span> <span class="pre">ssp-buffer-size</span></code>) are 2nd closest to the protector.</li>
<li>Variables that have had their address taken are 3rd closest to the
protector.</li>
</ol>
<p>This overrides the <code class="docutils literal"><span class="pre">ssp</span></code> function attribute.</p>
<p class="last">If a function that has an <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute is inlined into a
function that doesn&#8217;t have an <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute, then the
resulting function will have an <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">&quot;thunk&quot;</span></code></dt>
<dd>This attribute indicates that the function will delegate to some other
function with a tail call. The prototype of a thunk should not be used for
optimization purposes. The caller is expected to cast the thunk prototype to
match the thunk target prototype.</dd>
<dt><code class="docutils literal"><span class="pre">uwtable</span></code></dt>
<dd>This attribute indicates that the ABI being targeted requires that
an unwind table entry be produced for this function even if we can
show that no exceptions passes by it. This is normally the case for
the ELF x86-64 abi, but it can be disabled for some compilation
units.</dd>
</dl>
</div>
<div class="section" id="operand-bundles">
<span id="opbundles"></span><h3><a class="toc-backref" href="#id676">Operand Bundles</a><a class="headerlink" href="#operand-bundles" title="永久链接至标题">¶</a></h3>
<p>Note: operand bundles are a work in progress, and they should be
considered experimental at this time.</p>
<p>Operand bundles are tagged sets of SSA values that can be associated
with certain LLVM instructions (currently only <code class="docutils literal"><span class="pre">call</span></code> s and
<code class="docutils literal"><span class="pre">invoke</span></code> s).  In a way they are like metadata, but dropping them is
incorrect and will change program semantics.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operand</span> <span class="n">bundle</span> <span class="nb">set</span> <span class="p">::</span><span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="n">operand</span> <span class="n">bundle</span> <span class="p">(,</span> <span class="n">operand</span> <span class="n">bundle</span> <span class="p">)</span><span class="o">*</span> <span class="s1">&#39;]&#39;</span>
<span class="n">operand</span> <span class="n">bundle</span> <span class="p">::</span><span class="o">=</span> <span class="n">tag</span> <span class="s1">&#39;(&#39;</span> <span class="p">[</span> <span class="n">bundle</span> <span class="n">operand</span> <span class="p">]</span> <span class="p">(,</span> <span class="n">bundle</span> <span class="n">operand</span> <span class="p">)</span><span class="o">*</span> <span class="s1">&#39;)&#39;</span>
<span class="n">bundle</span> <span class="n">operand</span> <span class="p">::</span><span class="o">=</span> <span class="n">SSA</span> <span class="n">value</span>
<span class="n">tag</span> <span class="p">::</span><span class="o">=</span> <span class="n">string</span> <span class="n">constant</span>
</pre></div>
</div>
<p>Operand bundles are <strong>not</strong> part of a function&#8217;s signature, and a
given function may be called from multiple places with different kinds
of operand bundles.  This reflects the fact that the operand bundles
are conceptually a part of the <code class="docutils literal"><span class="pre">call</span></code> (or <code class="docutils literal"><span class="pre">invoke</span></code>), not the
callee being dispatched to.</p>
<p>Operand bundles are a generic mechanism intended to support
runtime-introspection-like functionality for managed languages.  While
the exact semantics of an operand bundle depend on the bundle tag,
there are certain limitations to how much the presence of an operand
bundle can influence the semantics of a program.  These restrictions
are described as the semantics of an &#8220;unknown&#8221; operand bundle.  As
long as the behavior of an operand bundle is describable within these
restrictions, LLVM does not need to have special knowledge of the
operand bundle to not miscompile programs containing it.</p>
<ul class="simple">
<li>The bundle operands for an unknown operand bundle escape in unknown
ways before control is transferred to the callee or invokee.</li>
<li>Calls and invokes with operand bundles have unknown read / write
effect on the heap on entry and exit (even if the call target is
<code class="docutils literal"><span class="pre">readnone</span></code> or <code class="docutils literal"><span class="pre">readonly</span></code>), unless they&#8217;re overriden with
callsite specific attributes.</li>
<li>An operand bundle at a call site cannot change the implementation
of the called function.  Inter-procedural optimizations work as
usual as long as they take into account the first two properties.</li>
</ul>
<p>More specific types of operand bundles are described below.</p>
<div class="section" id="deoptimization-operand-bundles">
<h4><a class="toc-backref" href="#id677">Deoptimization Operand Bundles</a><a class="headerlink" href="#deoptimization-operand-bundles" title="永久链接至标题">¶</a></h4>
<p>Deoptimization operand bundles are characterized by the <code class="docutils literal"><span class="pre">&quot;deopt&quot;</span></code>
operand bundle tag.  These operand bundles represent an alternate
&#8220;safe&#8221; continuation for the call site they&#8217;re attached to, and can be
used by a suitable runtime to deoptimize the compiled frame at the
specified call site.  There can be at most one <code class="docutils literal"><span class="pre">&quot;deopt&quot;</span></code> operand
bundle attached to a call site.  Exact details of deoptimization is
out of scope for the language reference, but it usually involves
rewriting a compiled frame into a set of interpreted frames.</p>
<p>From the compiler&#8217;s perspective, deoptimization operand bundles make
the call sites they&#8217;re attached to at least <code class="docutils literal"><span class="pre">readonly</span></code>.  They read
through all of their pointer typed operands (even if they&#8217;re not
otherwise escaped) and the entire visible heap.  Deoptimization
operand bundles do not capture their operands except during
deoptimization, in which case control will not be returned to the
compiled frame.</p>
<p>The inliner knows how to inline through calls that have deoptimization
operand bundles.  Just like inlining through a normal call site
involves composing the normal and exceptional continuations, inlining
through a call site with a deoptimization operand bundle needs to
appropriately compose the &#8220;safe&#8221; deoptimization continuation.  The
inliner does this by prepending the parent&#8217;s deoptimization
continuation to every deoptimization continuation in the inlined body.
E.g. inlining <code class="docutils literal"><span class="pre">&#64;f</span></code> into <code class="docutils literal"><span class="pre">&#64;g</span></code> in the following example</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@x</span><span class="p">()</span>  <span class="c">;; no deopt state</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">),</span> <span class="s">&quot;unknown&quot;</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">20</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will result in</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@x</span><span class="p">()</span>  <span class="c">;; still no deopt state</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">20</span><span class="p">,</span> <span class="k">i32</span> <span class="m">10</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">20</span><span class="p">,</span> <span class="k">i32</span> <span class="m">10</span><span class="p">),</span> <span class="s">&quot;unknown&quot;</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is the frontend&#8217;s responsibility to structure or encode the
deoptimization state in a way that syntactically prepending the
caller&#8217;s deoptimization state to the callee&#8217;s deoptimization state is
semantically equivalent to composing the caller&#8217;s deoptimization
continuation after the callee&#8217;s deoptimization continuation.</p>
</div>
<div class="section" id="funclet-operand-bundles">
<span id="ob-funclet"></span><h4><a class="toc-backref" href="#id678">Funclet Operand Bundles</a><a class="headerlink" href="#funclet-operand-bundles" title="永久链接至标题">¶</a></h4>
<p>Funclet operand bundles are characterized by the <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code>
operand bundle tag.  These operand bundles indicate that a call site
is within a particular funclet.  There can be at most one
<code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> operand bundle attached to a call site and it must have
exactly one bundle operand.</p>
<p>If any funclet EH pads have been &#8220;entered&#8221; but not &#8220;exited&#8221; (per the
<a class="reference external" href="ExceptionHandling.html#wineh-constraints">description in the EH doc</a>),
it is undefined behavior to execute a <code class="docutils literal"><span class="pre">call</span></code> or <code class="docutils literal"><span class="pre">invoke</span></code> which:</p>
<ul class="simple">
<li>does not have a <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> bundle and is not a <code class="docutils literal"><span class="pre">call</span></code> to a nounwind
intrinsic, or</li>
<li>has a <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> bundle whose operand is not the most-recently-entered
not-yet-exited funclet EH pad.</li>
</ul>
<p>Similarly, if no funclet EH pads have been entered-but-not-yet-exited,
executing a <code class="docutils literal"><span class="pre">call</span></code> or <code class="docutils literal"><span class="pre">invoke</span></code> with a <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> bundle is undefined behavior.</p>
</div>
</div>
<div class="section" id="module-level-inline-assembly">
<span id="moduleasm"></span><h3><a class="toc-backref" href="#id679">Module-Level Inline Assembly</a><a class="headerlink" href="#module-level-inline-assembly" title="永久链接至标题">¶</a></h3>
<p>Modules may contain &#8220;module-level inline asm&#8221; blocks, which corresponds
to the GCC &#8220;file scope inline asm&#8221; blocks. These blocks are internally
concatenated by LLVM and treated as a single unit, but may be separated
in the <code class="docutils literal"><span class="pre">.ll</span></code> file if desired. The syntax is very simple:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="k">asm</span> <span class="s">&quot;inline asm code goes here&quot;</span>
<span class="k">module</span> <span class="k">asm</span> <span class="s">&quot;more can go here&quot;</span>
</pre></div>
</div>
<p>The strings can contain any character by escaping non-printable
characters. The escape sequence used is simply &#8220;\xx&#8221; where &#8220;xx&#8221; is the
two digit hex code for the number.</p>
<p>Note that the assembly string <em>must</em> be parseable by LLVM&#8217;s integrated assembler
(unless it is disabled), even when emitting a <code class="docutils literal"><span class="pre">.s</span></code> file.</p>
</div>
<div class="section" id="data-layout">
<span id="langref-datalayout"></span><h3><a class="toc-backref" href="#id680">Data Layout</a><a class="headerlink" href="#data-layout" title="永久链接至标题">¶</a></h3>
<p>A module may specify a target specific data layout string that specifies
how data is to be laid out in memory. The syntax for the data layout is
simply:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">&quot;layout specification&quot;</span>
</pre></div>
</div>
<p>The <em>layout specification</em> consists of a list of specifications
separated by the minus sign character (&#8216;-&#8216;). Each specification starts
with a letter and may include other information after the letter to
define some aspect of the data layout. The specifications accepted are
as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">E</span></code></dt>
<dd>Specifies that the target lays out data in big-endian form. That is,
the bits with the most significance have the lowest address
location.</dd>
<dt><code class="docutils literal"><span class="pre">e</span></code></dt>
<dd>Specifies that the target lays out data in little-endian form. That
is, the bits with the least significance have the lowest address
location.</dd>
<dt><code class="docutils literal"><span class="pre">S&lt;size&gt;</span></code></dt>
<dd>Specifies the natural alignment of the stack in bits. Alignment
promotion of stack variables is limited to the natural stack
alignment to avoid dynamic stack realignment. The stack alignment
must be a multiple of 8-bits. If omitted, the natural stack
alignment defaults to &#8220;unspecified&#8221;, which does not prevent any
alignment promotions.</dd>
<dt><code class="docutils literal"><span class="pre">p[n]:&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the <em>size</em> of a pointer and its <code class="docutils literal"><span class="pre">&lt;abi&gt;</span></code> and
<code class="docutils literal"><span class="pre">&lt;pref&gt;</span></code>erred alignments for address space <code class="docutils literal"><span class="pre">n</span></code>. All sizes are in
bits. The address space, <code class="docutils literal"><span class="pre">n</span></code>, is optional, and if not specified,
denotes the default address space 0. The value of <code class="docutils literal"><span class="pre">n</span></code> must be
in the range [1,2^23).</dd>
<dt><code class="docutils literal"><span class="pre">i&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for an integer type of a given bit
<code class="docutils literal"><span class="pre">&lt;size&gt;</span></code>. The value of <code class="docutils literal"><span class="pre">&lt;size&gt;</span></code> must be in the range [1,2^23).</dd>
<dt><code class="docutils literal"><span class="pre">v&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for a vector type of a given bit
<code class="docutils literal"><span class="pre">&lt;size&gt;</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">f&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for a floating point type of a given bit
<code class="docutils literal"><span class="pre">&lt;size&gt;</span></code>. Only values of <code class="docutils literal"><span class="pre">&lt;size&gt;</span></code> that are supported by the target
will work. 32 (float) and 64 (double) are supported on all targets; 80
or 128 (different flavors of long double) are also supported on some
targets.</dd>
<dt><code class="docutils literal"><span class="pre">a:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for an object of aggregate type.</dd>
<dt><code class="docutils literal"><span class="pre">m:&lt;mangling&gt;</span></code></dt>
<dd><p class="first">If present, specifies that llvm names are mangled in the output. The
options are</p>
<ul class="last simple">
<li><code class="docutils literal"><span class="pre">e</span></code>: ELF mangling: Private symbols get a <code class="docutils literal"><span class="pre">.L</span></code> prefix.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: Mips mangling: Private symbols get a <code class="docutils literal"><span class="pre">$</span></code> prefix.</li>
<li><code class="docutils literal"><span class="pre">o</span></code>: Mach-O mangling: Private symbols get <code class="docutils literal"><span class="pre">L</span></code> prefix. Other
symbols get a <code class="docutils literal"><span class="pre">_</span></code> prefix.</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: Windows COFF prefix:  Similar to Mach-O, but stdcall and fastcall
functions also get a suffix based on the frame size.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Windows x86 COFF prefix:  Similar to Windows COFF, but use a <code class="docutils literal"><span class="pre">_</span></code>
prefix for <code class="docutils literal"><span class="pre">__cdecl</span></code> functions.</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</span></code></dt>
<dd>This specifies a set of native integer widths for the target CPU in
bits. For example, it might contain <code class="docutils literal"><span class="pre">n32</span></code> for 32-bit PowerPC,
<code class="docutils literal"><span class="pre">n32:64</span></code> for PowerPC 64, or <code class="docutils literal"><span class="pre">n8:16:32:64</span></code> for X86-64. Elements of
this set are considered to support most general arithmetic operations
efficiently.</dd>
</dl>
<p>On every specification that takes a <code class="docutils literal"><span class="pre">&lt;abi&gt;:&lt;pref&gt;</span></code>, specifying the
<code class="docutils literal"><span class="pre">&lt;pref&gt;</span></code> alignment is optional. If omitted, the preceding <code class="docutils literal"><span class="pre">:</span></code>
should be omitted too and <code class="docutils literal"><span class="pre">&lt;pref&gt;</span></code> will be equal to <code class="docutils literal"><span class="pre">&lt;abi&gt;</span></code>.</p>
<p>When constructing the data layout for a given target, LLVM starts with a
default set of specifications which are then (possibly) overridden by
the specifications in the <code class="docutils literal"><span class="pre">datalayout</span></code> keyword. The default
specifications are given in this list:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">E</span></code> - big endian</li>
<li><code class="docutils literal"><span class="pre">p:64:64:64</span></code> - 64-bit pointers with 64-bit alignment.</li>
<li><code class="docutils literal"><span class="pre">p[n]:64:64:64</span></code> - Other address spaces are assumed to be the
same as the default address space.</li>
<li><code class="docutils literal"><span class="pre">S0</span></code> - natural stack alignment is unspecified</li>
<li><code class="docutils literal"><span class="pre">i1:8:8</span></code> - i1 is 8-bit (byte) aligned</li>
<li><code class="docutils literal"><span class="pre">i8:8:8</span></code> - i8 is 8-bit (byte) aligned</li>
<li><code class="docutils literal"><span class="pre">i16:16:16</span></code> - i16 is 16-bit aligned</li>
<li><code class="docutils literal"><span class="pre">i32:32:32</span></code> - i32 is 32-bit aligned</li>
<li><code class="docutils literal"><span class="pre">i64:32:64</span></code> - i64 has ABI alignment of 32-bits but preferred
alignment of 64-bits</li>
<li><code class="docutils literal"><span class="pre">f16:16:16</span></code> - half is 16-bit aligned</li>
<li><code class="docutils literal"><span class="pre">f32:32:32</span></code> - float is 32-bit aligned</li>
<li><code class="docutils literal"><span class="pre">f64:64:64</span></code> - double is 64-bit aligned</li>
<li><code class="docutils literal"><span class="pre">f128:128:128</span></code> - quad is 128-bit aligned</li>
<li><code class="docutils literal"><span class="pre">v64:64:64</span></code> - 64-bit vector is 64-bit aligned</li>
<li><code class="docutils literal"><span class="pre">v128:128:128</span></code> - 128-bit vector is 128-bit aligned</li>
<li><code class="docutils literal"><span class="pre">a:0:64</span></code> - aggregates are 64-bit aligned</li>
</ul>
<p>When LLVM is determining the alignment for a given type, it uses the
following rules:</p>
<ol class="arabic simple">
<li>If the type sought is an exact match for one of the specifications,
that specification is used.</li>
<li>If no match is found, and the type sought is an integer type, then
the smallest integer type that is larger than the bitwidth of the
sought type is used. If none of the specifications are larger than
the bitwidth then the largest integer type is used. For example,
given the default specifications above, the i7 type will use the
alignment of i8 (next largest) while both i65 and i256 will use the
alignment of i64 (largest specified).</li>
<li>If no match is found, and the type sought is a vector type, then the
largest vector type that is smaller than the sought vector type will
be used as a fall back. This happens because &lt;128 x double&gt; can be
implemented in terms of 64 &lt;2 x double&gt;, for example.</li>
</ol>
<p>The function of the data layout string may not be what you expect.
Notably, this is not a specification from the frontend of what alignment
the code generator should use.</p>
<p>Instead, if specified, the target data layout is required to match what
the ultimate <em>code generator</em> expects. This string is used by the
mid-level optimizers to improve code, and this only works if it matches
what the ultimate code generator uses. There is no way to generate IR
that does not embed this target-specific detail into the IR. If you
don&#8217;t specify the string, the default specifications will be used to
generate a Data Layout and the optimization phases will operate
accordingly and introduce target specificity into the IR with respect to
these default specifications.</p>
</div>
<div class="section" id="target-triple">
<span id="langref-triple"></span><h3><a class="toc-backref" href="#id681">Target Triple</a><a class="headerlink" href="#target-triple" title="永久链接至标题">¶</a></h3>
<p>A module may specify a target triple string that describes the target
host. The syntax for the target triple is simply:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">&quot;x86_64-apple-macosx10.7.0&quot;</span>
</pre></div>
</div>
<p>The <em>target triple</em> string consists of a series of identifiers delimited
by the minus sign character (&#8216;-&#8216;). The canonical forms are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ARCHITECTURE</span><span class="o">-</span><span class="n">VENDOR</span><span class="o">-</span><span class="n">OPERATING_SYSTEM</span>
<span class="n">ARCHITECTURE</span><span class="o">-</span><span class="n">VENDOR</span><span class="o">-</span><span class="n">OPERATING_SYSTEM</span><span class="o">-</span><span class="n">ENVIRONMENT</span>
</pre></div>
</div>
<p>This information is passed along to the backend so that it generates
code for the proper architecture. It&#8217;s possible to override this on the
command line with the <code class="docutils literal"><span class="pre">-mtriple</span></code> command line option.</p>
</div>
<div class="section" id="pointer-aliasing-rules">
<span id="pointeraliasing"></span><h3><a class="toc-backref" href="#id682">Pointer Aliasing Rules</a><a class="headerlink" href="#pointer-aliasing-rules" title="永久链接至标题">¶</a></h3>
<p>Any memory access must be done through a pointer value associated with
an address range of the memory access, otherwise the behavior is
undefined. Pointer values are associated with address ranges according
to the following rules:</p>
<ul class="simple">
<li>A pointer value is associated with the addresses associated with any
value it is <em>based</em> on.</li>
<li>An address of a global variable is associated with the address range
of the variable&#8217;s storage.</li>
<li>The result value of an allocation instruction is associated with the
address range of the allocated storage.</li>
<li>A null pointer in the default address-space is associated with no
address.</li>
<li>An integer constant other than zero or a pointer value returned from
a function not defined within LLVM may be associated with address
ranges allocated through mechanisms other than those provided by
LLVM. Such ranges shall not overlap with any ranges of addresses
allocated by mechanisms provided by LLVM.</li>
</ul>
<p>A pointer value is <em>based</em> on another pointer value according to the
following rules:</p>
<ul class="simple">
<li>A pointer value formed from a <code class="docutils literal"><span class="pre">getelementptr</span></code> operation is <em>based</em>
on the first value operand of the <code class="docutils literal"><span class="pre">getelementptr</span></code>.</li>
<li>The result value of a <code class="docutils literal"><span class="pre">bitcast</span></code> is <em>based</em> on the operand of the
<code class="docutils literal"><span class="pre">bitcast</span></code>.</li>
<li>A pointer value formed by an <code class="docutils literal"><span class="pre">inttoptr</span></code> is <em>based</em> on all pointer
values that contribute (directly or indirectly) to the computation of
the pointer&#8217;s value.</li>
<li>The &#8220;<em>based</em> on&#8221; relationship is transitive.</li>
</ul>
<p>Note that this definition of <em>&#8220;based&#8221;</em> is intentionally similar to the
definition of <em>&#8220;based&#8221;</em> in C99, though it is slightly weaker.</p>
<p>LLVM IR does not associate types with memory. The result type of a
<code class="docutils literal"><span class="pre">load</span></code> merely indicates the size and alignment of the memory from
which to load, as well as the interpretation of the value. The first
operand type of a <code class="docutils literal"><span class="pre">store</span></code> similarly only indicates the size and
alignment of the store.</p>
<p>Consequently, type-based alias analysis, aka TBAA, aka
<code class="docutils literal"><span class="pre">-fstrict-aliasing</span></code>, is not applicable to general unadorned LLVM IR.
<a class="reference internal" href="#metadata"><span class="std std-ref">Metadata</span></a> may be used to encode additional information
which specialized optimization passes may use to implement type-based
alias analysis.</p>
</div>
<div class="section" id="volatile-memory-accesses">
<span id="volatile"></span><h3><a class="toc-backref" href="#id683">Volatile Memory Accesses</a><a class="headerlink" href="#volatile-memory-accesses" title="永久链接至标题">¶</a></h3>
<p>Certain memory accesses, such as <a class="reference internal" href="#i-load"><span class="std std-ref">load</span></a>&#8216;s,
<a class="reference internal" href="#i-store"><span class="std std-ref">store</span></a>&#8216;s, and <a class="reference internal" href="#int-memcpy"><span class="std std-ref">llvm.memcpy</span></a>&#8216;s may be
marked <code class="docutils literal"><span class="pre">volatile</span></code>. The optimizers must not change the number of
volatile operations or change their order of execution relative to other
volatile operations. The optimizers <em>may</em> change the order of volatile
operations relative to non-volatile operations. This is not Java&#8217;s
&#8220;volatile&#8221; and has no cross-thread synchronization behavior.</p>
<p>IR-level volatile loads and stores cannot safely be optimized into
llvm.memcpy or llvm.memmove intrinsics even when those intrinsics are
flagged volatile. Likewise, the backend should never split or merge
target-legal volatile load/store instructions.</p>
<div class="admonition-rationale admonition">
<p class="first admonition-title">Rationale</p>
<p class="last">Platforms may rely on volatile loads and stores of natively supported
data width to be executed as single instruction. For example, in C
this holds for an l-value of volatile primitive type with native
hardware support, but not necessarily for aggregate types. The
frontend upholds these expectations, which are intentionally
unspecified in the IR. The rules above ensure that IR transformations
do not violate the frontend&#8217;s contract with the language.</p>
</div>
</div>
<div class="section" id="memory-model-for-concurrent-operations">
<span id="memmodel"></span><h3><a class="toc-backref" href="#id684">Memory Model for Concurrent Operations</a><a class="headerlink" href="#memory-model-for-concurrent-operations" title="永久链接至标题">¶</a></h3>
<p>The LLVM IR does not define any way to start parallel threads of
execution or to register signal handlers. Nonetheless, there are
platform-specific ways to create them, and we define LLVM IR&#8217;s behavior
in their presence. This model is inspired by the C++0x memory model.</p>
<p>For a more informal introduction to this model, see the <a class="reference internal" href="Atomics.html"><span class="doc">LLVM Atomic Instructions and Concurrency Guide</span></a>.</p>
<p>We define a <em>happens-before</em> partial order as the least partial order
that</p>
<ul class="simple">
<li>Is a superset of single-thread program order, and</li>
<li>When a <em>synchronizes-with</em> <code class="docutils literal"><span class="pre">b</span></code>, includes an edge from <code class="docutils literal"><span class="pre">a</span></code> to
<code class="docutils literal"><span class="pre">b</span></code>. <em>Synchronizes-with</em> pairs are introduced by platform-specific
techniques, like pthread locks, thread creation, thread joining,
etc., and by atomic instructions. (See also <a class="reference internal" href="#ordering"><span class="std std-ref">Atomic Memory Ordering
Constraints</span></a>).</li>
</ul>
<p>Note that program order does not introduce <em>happens-before</em> edges
between a thread and signals executing inside that thread.</p>
<p>Every (defined) read operation (load instructions, memcpy, atomic
loads/read-modify-writes, etc.) R reads a series of bytes written by
(defined) write operations (store instructions, atomic
stores/read-modify-writes, memcpy, etc.). For the purposes of this
section, initialized globals are considered to have a write of the
initializer which is atomic and happens before any other read or write
of the memory in question. For each byte of a read R, R<sub>byte</sub>
may see any write to the same byte, except:</p>
<ul class="simple">
<li>If write<sub>1</sub>  happens before write<sub>2</sub>, and
write<sub>2</sub> happens before R<sub>byte</sub>, then
R<sub>byte</sub> does not see write<sub>1</sub>.</li>
<li>If R<sub>byte</sub> happens before write<sub>3</sub>, then
R<sub>byte</sub> does not see write<sub>3</sub>.</li>
</ul>
<p>Given that definition, R<sub>byte</sub> is defined as follows:</p>
<ul class="simple">
<li>If R is volatile, the result is target-dependent. (Volatile is
supposed to give guarantees which can support <code class="docutils literal"><span class="pre">sig_atomic_t</span></code> in
C/C++, and may be used for accesses to addresses that do not behave
like normal memory. It does not generally provide cross-thread
synchronization.)</li>
<li>Otherwise, if there is no write to the same byte that happens before
R<sub>byte</sub>, R<sub>byte</sub> returns <code class="docutils literal"><span class="pre">undef</span></code> for that byte.</li>
<li>Otherwise, if R<sub>byte</sub> may see exactly one write,
R<sub>byte</sub> returns the value written by that write.</li>
<li>Otherwise, if R is atomic, and all the writes R<sub>byte</sub> may
see are atomic, it chooses one of the values written. See the <a class="reference internal" href="#ordering"><span class="std std-ref">Atomic
Memory Ordering Constraints</span></a> section for additional
constraints on how the choice is made.</li>
<li>Otherwise R<sub>byte</sub> returns <code class="docutils literal"><span class="pre">undef</span></code>.</li>
</ul>
<p>R returns the value composed of the series of bytes it read. This
implies that some bytes within the value may be <code class="docutils literal"><span class="pre">undef</span></code> <strong>without</strong>
the entire value being <code class="docutils literal"><span class="pre">undef</span></code>. Note that this only defines the
semantics of the operation; it doesn&#8217;t mean that targets will emit more
than one instruction to read the series of bytes.</p>
<p>Note that in cases where none of the atomic intrinsics are used, this
model places only one restriction on IR transformations on top of what
is required for single-threaded execution: introducing a store to a byte
which might not otherwise be stored is not allowed in general.
(Specifically, in the case where another thread might write to and read
from an address, introducing a store can change a load that may see
exactly one write into a load that may see multiple writes.)</p>
</div>
<div class="section" id="atomic-memory-ordering-constraints">
<span id="ordering"></span><h3><a class="toc-backref" href="#id685">Atomic Memory Ordering Constraints</a><a class="headerlink" href="#atomic-memory-ordering-constraints" title="永久链接至标题">¶</a></h3>
<p>Atomic instructions (<a class="reference internal" href="#i-cmpxchg"><span class="std std-ref">cmpxchg</span></a>,
<a class="reference internal" href="#i-atomicrmw"><span class="std std-ref">atomicrmw</span></a>, <a class="reference internal" href="#i-fence"><span class="std std-ref">fence</span></a>,
<a class="reference internal" href="#i-load"><span class="std std-ref">atomic load</span></a>, and <a class="reference internal" href="#i-store"><span class="std std-ref">atomic store</span></a>) take
ordering parameters that determine which other atomic instructions on
the same address they <em>synchronize with</em>. These semantics are borrowed
from Java and C++0x, but are somewhat more colloquial. If these
descriptions aren&#8217;t precise enough, check those specs (see spec
references in the <a class="reference internal" href="Atomics.html"><span class="doc">atomics guide</span></a>).
<a class="reference internal" href="#i-fence"><span class="std std-ref">fence</span></a> instructions treat these orderings somewhat
differently since they don&#8217;t take an address. See that instruction&#8217;s
documentation for details.</p>
<p>For a simpler introduction to the ordering constraints, see the
<a class="reference internal" href="Atomics.html"><span class="doc">LLVM Atomic Instructions and Concurrency Guide</span></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unordered</span></code></dt>
<dd>The set of values that can be read is governed by the happens-before
partial order. A value cannot be read unless some operation wrote
it. This is intended to provide a guarantee strong enough to model
Java&#8217;s non-volatile shared variables. This ordering cannot be
specified for read-modify-write operations; it is not strong enough
to make them atomic in any interesting way.</dd>
<dt><code class="docutils literal"><span class="pre">monotonic</span></code></dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">unordered</span></code>, there is a single
total order for modifications by <code class="docutils literal"><span class="pre">monotonic</span></code> operations on each
address. All modification orders must be compatible with the
happens-before order. There is no guarantee that the modification
orders can be combined to a global total order for the whole program
(and this often will not be possible). The read in an atomic
read-modify-write operation (<a class="reference internal" href="#i-cmpxchg"><span class="std std-ref">cmpxchg</span></a> and
<a class="reference internal" href="#i-atomicrmw"><span class="std std-ref">atomicrmw</span></a>) reads the value in the modification
order immediately before the value it writes. If one atomic read
happens before another atomic read of the same address, the later
read must see the same value or a later value in the address&#8217;s
modification order. This disallows reordering of <code class="docutils literal"><span class="pre">monotonic</span></code> (or
stronger) operations on the same address. If an address is written
<code class="docutils literal"><span class="pre">monotonic</span></code>-ally by one thread, and other threads <code class="docutils literal"><span class="pre">monotonic</span></code>-ally
read that address repeatedly, the other threads must eventually see
the write. This corresponds to the C++0x/C1x
<code class="docutils literal"><span class="pre">memory_order_relaxed</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">acquire</span></code></dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">monotonic</span></code>, a
<em>synchronizes-with</em> edge may be formed with a <code class="docutils literal"><span class="pre">release</span></code> operation.
This is intended to model C++&#8217;s <code class="docutils literal"><span class="pre">memory_order_acquire</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">monotonic</span></code>, if this operation
writes a value which is subsequently read by an <code class="docutils literal"><span class="pre">acquire</span></code>
operation, it <em>synchronizes-with</em> that operation. (This isn&#8217;t a
complete description; see the C++0x definition of a release
sequence.) This corresponds to the C++0x/C1x
<code class="docutils literal"><span class="pre">memory_order_release</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">acq_rel</span></code> (acquire+release)</dt>
<dd>Acts as both an <code class="docutils literal"><span class="pre">acquire</span></code> and <code class="docutils literal"><span class="pre">release</span></code> operation on its
address. This corresponds to the C++0x/C1x <code class="docutils literal"><span class="pre">memory_order_acq_rel</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">seq_cst</span></code> (sequentially consistent)</dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">acq_rel</span></code> (<code class="docutils literal"><span class="pre">acquire</span></code> for an
operation that only reads, <code class="docutils literal"><span class="pre">release</span></code> for an operation that only
writes), there is a global total order on all
sequentially-consistent operations on all addresses, which is
consistent with the <em>happens-before</em> partial order and with the
modification orders of all the affected addresses. Each
sequentially-consistent read sees the last preceding write to the
same address in this global order. This corresponds to the C++0x/C1x
<code class="docutils literal"><span class="pre">memory_order_seq_cst</span></code> and Java volatile.</dd>
</dl>
<p id="singlethread">If an atomic operation is marked <code class="docutils literal"><span class="pre">singlethread</span></code>, it only <em>synchronizes
with</em> or participates in modification and seq_cst total orderings with
other operations running in the same thread (for example, in signal
handlers).</p>
</div>
<div class="section" id="fast-math-flags">
<span id="fastmath"></span><h3><a class="toc-backref" href="#id686">Fast-Math Flags</a><a class="headerlink" href="#fast-math-flags" title="永久链接至标题">¶</a></h3>
<p>LLVM IR floating-point binary ops (<a class="reference internal" href="#i-fadd"><span class="std std-ref">fadd</span></a>,
<a class="reference internal" href="#i-fsub"><span class="std std-ref">fsub</span></a>, <a class="reference internal" href="#i-fmul"><span class="std std-ref">fmul</span></a>, <a class="reference internal" href="#i-fdiv"><span class="std std-ref">fdiv</span></a>,
<a class="reference internal" href="#i-frem"><span class="std std-ref">frem</span></a>, <a class="reference internal" href="#i-fcmp"><span class="std std-ref">fcmp</span></a>) have the following flags that can
be set to enable otherwise unsafe floating point operations</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">nnan</span></code></dt>
<dd>No NaNs - Allow optimizations to assume the arguments and result are not
NaN. Such optimizations are required to retain defined behavior over
NaNs, but the value of the result is undefined.</dd>
<dt><code class="docutils literal"><span class="pre">ninf</span></code></dt>
<dd>No Infs - Allow optimizations to assume the arguments and result are not
+/-Inf. Such optimizations are required to retain defined behavior over
+/-Inf, but the value of the result is undefined.</dd>
<dt><code class="docutils literal"><span class="pre">nsz</span></code></dt>
<dd>No Signed Zeros - Allow optimizations to treat the sign of a zero
argument or result as insignificant.</dd>
<dt><code class="docutils literal"><span class="pre">arcp</span></code></dt>
<dd>Allow Reciprocal - Allow optimizations to use the reciprocal of an
argument rather than perform division.</dd>
<dt><code class="docutils literal"><span class="pre">fast</span></code></dt>
<dd>Fast - Allow algebraically equivalent transformations that may
dramatically change results in floating point (e.g. reassociate). This
flag implies all the others.</dd>
</dl>
</div>
<div class="section" id="use-list-order-directives">
<span id="uselistorder"></span><h3><a class="toc-backref" href="#id687">Use-list Order Directives</a><a class="headerlink" href="#use-list-order-directives" title="永久链接至标题">¶</a></h3>
<p>Use-list directives encode the in-memory order of each use-list, allowing the
order to be recreated. <code class="docutils literal"><span class="pre">&lt;order-indexes&gt;</span></code> is a comma-separated list of
indexes that are assigned to the referenced value&#8217;s uses. The referenced
value&#8217;s use-list is immediately sorted by these indexes.</p>
<p>Use-list directives may appear at function scope or global scope. They are not
instructions, and have no effect on the semantics of the IR. When they&#8217;re at
function scope, they must appear after the terminator of the final basic block.</p>
<p>If basic blocks have their address taken via <code class="docutils literal"><span class="pre">blockaddress()</span></code> expressions,
<code class="docutils literal"><span class="pre">uselistorder_bb</span></code> can be used to reorder their use-lists from outside their
function&#8217;s scope.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">uselistorder</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">order</span><span class="o">-</span><span class="n">indexes</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="n">uselistorder_bb</span> <span class="nd">@function</span><span class="p">,</span> <span class="o">%</span><span class="n">block</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">order</span><span class="o">-</span><span class="n">indexes</span><span class="o">&gt;</span> <span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">define</span> <span class="n">void</span> <span class="nd">@foo</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">arg1</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="p">;</span> <span class="o">...</span> <span class="n">instructions</span> <span class="o">...</span>
<span class="n">bb</span><span class="p">:</span>
  <span class="p">;</span> <span class="o">...</span> <span class="n">instructions</span> <span class="o">...</span>

  <span class="p">;</span> <span class="n">At</span> <span class="n">function</span> <span class="n">scope</span><span class="o">.</span>
  <span class="n">uselistorder</span> <span class="n">i32</span> <span class="o">%</span><span class="n">arg1</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span>
  <span class="n">uselistorder</span> <span class="n">label</span> <span class="o">%</span><span class="n">bb</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">;</span> <span class="n">At</span> <span class="k">global</span> <span class="n">scope</span><span class="o">.</span>
<span class="n">uselistorder</span> <span class="n">i32</span><span class="o">*</span> <span class="nd">@global</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">uselistorder</span> <span class="n">i32</span> <span class="mi">7</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">uselistorder</span> <span class="n">i32</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="nd">@bar</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">uselistorder_bb</span> <span class="nd">@foo</span><span class="p">,</span> <span class="o">%</span><span class="n">bb</span><span class="p">,</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-system">
<span id="typesystem"></span><h2><a class="toc-backref" href="#id688">Type System</a><a class="headerlink" href="#type-system" title="永久链接至标题">¶</a></h2>
<p>The LLVM type system is one of the most important features of the
intermediate representation. Being typed enables a number of
optimizations to be performed on the intermediate representation
directly, without having to do extra analyses on the side before the
transformation. A strong type system makes it easier to read the
generated code and enables novel analyses and transformations that are
not feasible to perform on normal three address code representations.</p>
<div class="section" id="void-type">
<span id="t-void"></span><h3><a class="toc-backref" href="#id689">Void Type</a><a class="headerlink" href="#void-type" title="永久链接至标题">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The void type does not represent any value and has no size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span>
</pre></div>
</div>
</div>
<div class="section" id="function-type">
<span id="t-function"></span><h3><a class="toc-backref" href="#id690">Function Type</a><a class="headerlink" href="#function-type" title="永久链接至标题">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The function type can be thought of as a function signature. It consists of a
return type and a list of formal parameter types. The return type of a function
type is a void type or first class type &#8212; except for <a class="reference internal" href="#t-label"><span class="std std-ref">label</span></a>
and <a class="reference internal" href="#t-metadata"><span class="std std-ref">metadata</span></a> types.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">returntype</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">parameter</span> <span class="nb">list</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>...where &#8216;<code class="docutils literal"><span class="pre">&lt;parameter</span> <span class="pre">list&gt;</span></code>&#8216; is a comma-separated list of type
specifiers. Optionally, the parameter list may include a type <code class="docutils literal"><span class="pre">...</span></code>, which
indicates that the function takes a variable number of arguments. Variable
argument functions can access their arguments with the <a class="reference internal" href="#int-varargs"><span class="std std-ref">variable argument
handling intrinsic</span></a> functions. &#8216;<code class="docutils literal"><span class="pre">&lt;returntype&gt;</span></code>&#8216; is any type
except <a class="reference internal" href="#t-label"><span class="std std-ref">label</span></a> and <a class="reference internal" href="#t-metadata"><span class="std std-ref">metadata</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i32)</span></code></td>
<td>function taking an <code class="docutils literal"><span class="pre">i32</span></code>, returning an <code class="docutils literal"><span class="pre">i32</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">float</span> <span class="pre">(i16,</span> <span class="pre">i32</span> <span class="pre">*)</span> <span class="pre">*</span></code></td>
<td><a class="reference internal" href="#t-pointer"><span class="std std-ref">Pointer</span></a> to a function that takes an <code class="docutils literal"><span class="pre">i16</span></code> and a <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to <code class="docutils literal"><span class="pre">i32</span></code>, returning <code class="docutils literal"><span class="pre">float</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i8*,</span> <span class="pre">...)</span></code></td>
<td>A vararg function that takes at least one <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to <code class="docutils literal"><span class="pre">i8</span></code> (char in C), which returns an integer. This is the signature for <code class="docutils literal"><span class="pre">printf</span></code> in LLVM.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">{i32,</span> <span class="pre">i32}</span> <span class="pre">(i32)</span></code></td>
<td>A function taking an <code class="docutils literal"><span class="pre">i32</span></code>, returning a <a class="reference internal" href="#t-struct"><span class="std std-ref">structure</span></a> containing two <code class="docutils literal"><span class="pre">i32</span></code> values</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="first-class-types">
<span id="t-firstclass"></span><h3><a class="toc-backref" href="#id691">First Class Types</a><a class="headerlink" href="#first-class-types" title="永久链接至标题">¶</a></h3>
<p>The <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> types are perhaps the most important.
Values of these types are the only ones which can be produced by
instructions.</p>
<div class="section" id="single-value-types">
<span id="t-single-value"></span><h4><a class="toc-backref" href="#id692">Single Value Types</a><a class="headerlink" href="#single-value-types" title="永久链接至标题">¶</a></h4>
<p>These are the types that are valid in registers from CodeGen&#8217;s perspective.</p>
<div class="section" id="integer-type">
<span id="t-integer"></span><h5><a class="toc-backref" href="#id693">Integer Type</a><a class="headerlink" href="#integer-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The integer type is a very simple type that simply specifies an
arbitrary bit width for the integer type desired. Any bit width from 1
bit to 2<sup>23</sup>-1 (about 8 million) can be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">iN</span>
</pre></div>
</div>
<p>The number of bits the integer will occupy is specified by the <code class="docutils literal"><span class="pre">N</span></code>
value.</p>
<div class="section" id="examples">
<h6>Examples:<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h6>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i1</span></code></td>
<td>a single-bit integer.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">i32</span></code></td>
<td>a 32-bit integer.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i1942652</span></code></td>
<td>a really big integer of over 1 million bits.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="floating-point-types">
<span id="t-floating"></span><h5><a class="toc-backref" href="#id694">Floating Point Types</a><a class="headerlink" href="#floating-point-types" title="永久链接至标题">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">half</span></code></td>
<td>16-bit floating point value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">float</span></code></td>
<td>32-bit floating point value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">double</span></code></td>
<td>64-bit floating point value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">fp128</span></code></td>
<td>128-bit floating point value (112-bit mantissa)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x86_fp80</span></code></td>
<td>80-bit floating point value (X87)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">ppc_fp128</span></code></td>
<td>128-bit floating point value (two 64-bits)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="x86-mmx-type">
<h5><a class="toc-backref" href="#id695">X86_mmx Type</a><a class="headerlink" href="#x86-mmx-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The x86_mmx type represents a value held in an MMX register on an x86
machine. The operations allowed on it are quite limited: parameters and
return values, load and store, and bitcast. User-specified MMX
instructions are represented as intrinsic or asm calls with arguments
and/or results of this type. There are no arrays, vectors or constants
of this type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x86_mmx</span>
</pre></div>
</div>
</div>
<div class="section" id="pointer-type">
<span id="t-pointer"></span><h5><a class="toc-backref" href="#id696">Pointer Type</a><a class="headerlink" href="#pointer-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The pointer type is used to specify memory locations. Pointers are
commonly used to reference objects in memory.</p>
<p>Pointer types may have an optional address space attribute defining the
numbered address space where the pointed-to object resides. The default
address space is number zero. The semantics of non-zero address spaces
are target-specific.</p>
<p>Note that LLVM does not permit pointers to void (<code class="docutils literal"><span class="pre">void*</span></code>) nor does it
permit pointers to labels (<code class="docutils literal"><span class="pre">label*</span></code>). Use <code class="docutils literal"><span class="pre">i8*</span></code> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i32]*</span></code></td>
<td>A <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to <a class="reference internal" href="#t-array"><span class="std std-ref">array</span></a> of four <code class="docutils literal"><span class="pre">i32</span></code> values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i32*)</span> <span class="pre">*</span></code></td>
<td>A <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to a <a class="reference internal" href="#t-function"><span class="std std-ref">function</span></a> that takes an <code class="docutils literal"><span class="pre">i32*</span></code>, returning an <code class="docutils literal"><span class="pre">i32</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">addrspace(5)*</span></code></td>
<td>A <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to an <code class="docutils literal"><span class="pre">i32</span></code> value that resides in address space #5.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vector-type">
<span id="t-vector"></span><h5><a class="toc-backref" href="#id697">Vector Type</a><a class="headerlink" href="#vector-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>A vector type is a simple derived type that represents a vector of
elements. Vector types are used when multiple primitive data are
operated in parallel using a single instruction (SIMD). A vector type
requires a size (number of elements) and an underlying primitive data
type. Vector types are considered <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span> <span class="o">&lt;</span><span class="c1"># elements&gt; x &lt;elementtype&gt; &gt;</span>
</pre></div>
</div>
<p>The number of elements is a constant integer value larger than 0;
elementtype may be any integer, floating point or pointer type. Vectors
of size zero are not allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i32&gt;</span></code></td>
<td>Vector of 4 32-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;8</span> <span class="pre">x</span> <span class="pre">float&gt;</span></code></td>
<td>Vector of 8 32-bit floating-point values.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;2</span> <span class="pre">x</span> <span class="pre">i64&gt;</span></code></td>
<td>Vector of 2 64-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i64*&gt;</span></code></td>
<td>Vector of 4 pointers to 64-bit integer values.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="label-type">
<span id="t-label"></span><h4><a class="toc-backref" href="#id698">Label Type</a><a class="headerlink" href="#label-type" title="永久链接至标题">¶</a></h4>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The label type represents code labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">label</span>
</pre></div>
</div>
</div>
<div class="section" id="token-type">
<span id="t-token"></span><h4><a class="toc-backref" href="#id699">Token Type</a><a class="headerlink" href="#token-type" title="永久链接至标题">¶</a></h4>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The token type is used when a value is associated with an instruction
but all uses of the value must not attempt to introspect or obscure it.
As such, it is not appropriate to have a <a class="reference internal" href="#i-phi"><span class="std std-ref">phi</span></a> or
<a class="reference internal" href="#i-select"><span class="std std-ref">select</span></a> of type token.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">token</span>
</pre></div>
</div>
</div>
<div class="section" id="metadata-type">
<span id="t-metadata"></span><h4><a class="toc-backref" href="#id700">Metadata Type</a><a class="headerlink" href="#metadata-type" title="永久链接至标题">¶</a></h4>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The metadata type represents embedded metadata. No derived types may be
created from metadata except for <a class="reference internal" href="#t-function"><span class="std std-ref">function</span></a> arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">metadata</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregate-types">
<span id="t-aggregate"></span><h4><a class="toc-backref" href="#id701">Aggregate Types</a><a class="headerlink" href="#aggregate-types" title="永久链接至标题">¶</a></h4>
<p>Aggregate Types are a subset of derived types that can contain multiple
member types. <a class="reference internal" href="#t-array"><span class="std std-ref">Arrays</span></a> and <a class="reference internal" href="#t-struct"><span class="std std-ref">structs</span></a> are
aggregate types. <a class="reference internal" href="#t-vector"><span class="std std-ref">Vectors</span></a> are not considered to be
aggregate types.</p>
<div class="section" id="array-type">
<span id="t-array"></span><h5><a class="toc-backref" href="#id702">Array Type</a><a class="headerlink" href="#array-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The array type is a very simple derived type that arranges elements
sequentially in memory. The array type requires a size (number of
elements) and an underlying data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">&lt;</span><span class="c1"># elements&gt; x &lt;elementtype&gt;]</span>
</pre></div>
</div>
<p>The number of elements is a constant integer value; <code class="docutils literal"><span class="pre">elementtype</span></code> may
be any type with a size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[40</span> <span class="pre">x</span> <span class="pre">i32]</span></code></td>
<td>Array of 40 32-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[41</span> <span class="pre">x</span> <span class="pre">i32]</span></code></td>
<td>Array of 41 32-bit integer values.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i8]</span></code></td>
<td>Array of 4 8-bit integer values.</td>
</tr>
</tbody>
</table>
<p>Here are some examples of multidimensional arrays:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[3</span> <span class="pre">x</span> <span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i32]]</span></code></td>
<td>3x4 array of 32-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[12</span> <span class="pre">x</span> <span class="pre">[10</span> <span class="pre">x</span> <span class="pre">float]]</span></code></td>
<td>12x10 array of single precision floating point values.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[2</span> <span class="pre">x</span> <span class="pre">[3</span> <span class="pre">x</span> <span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i16]]]</span></code></td>
<td>2x3x4 array of 16-bit integer values.</td>
</tr>
</tbody>
</table>
<p>There is no restriction on indexing beyond the end of the array implied
by a static type (though there are restrictions on indexing beyond the
bounds of an allocated object in some cases). This means that
single-dimension &#8216;variable sized array&#8217; addressing can be implemented in
LLVM with a zero length array type. An implementation of &#8216;pascal style
arrays&#8217; in LLVM could use the type &#8220;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i32,</span> <span class="pre">[0</span> <span class="pre">x</span> <span class="pre">float]}</span></code>&#8221;, for
example.</p>
</div>
<div class="section" id="structure-type">
<span id="t-struct"></span><h5><a class="toc-backref" href="#id703">Structure Type</a><a class="headerlink" href="#structure-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The structure type is used to represent a collection of data members
together in memory. The elements of a structure may be any type that has
a size.</p>
<p>Structures in memory are accessed using &#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; by
getting a pointer to a field with the &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction.
Structures in registers are accessed using the &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; and
&#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; instructions.</p>
<p>Structures may optionally be &#8220;packed&#8221; structures, which indicate that
the alignment of the struct is one byte, and that there is no padding
between the elements. In non-packed structs, padding between field types
is inserted as defined by the DataLayout string in the module, which is
required to match what the underlying code generator expects.</p>
<p>Structures can either be &#8220;literal&#8221; or &#8220;identified&#8221;. A literal structure
is defined inline with other types (e.g. <code class="docutils literal"><span class="pre">{i32,</span> <span class="pre">i32}*</span></code>) whereas
identified types are always defined at the top level with a name.
Literal types are uniqued by their contents and can never be recursive
or opaque since there is no way to write one. Identified types can be
recursive, can be opaqued, and are never uniqued.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">T1</span> <span class="o">=</span> <span class="nb">type</span> <span class="p">{</span> <span class="o">&lt;</span><span class="nb">type</span> <span class="nb">list</span><span class="o">&gt;</span> <span class="p">}</span>     <span class="p">;</span> <span class="n">Identified</span> <span class="n">normal</span> <span class="n">struct</span> <span class="nb">type</span>
<span class="o">%</span><span class="n">T2</span> <span class="o">=</span> <span class="nb">type</span> <span class="o">&lt;</span><span class="p">{</span> <span class="o">&lt;</span><span class="nb">type</span> <span class="nb">list</span><span class="o">&gt;</span> <span class="p">}</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">Identified</span> <span class="n">packed</span> <span class="n">struct</span> <span class="nb">type</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">{</span> <span class="pre">i32,</span> <span class="pre">i32,</span> <span class="pre">i32</span> <span class="pre">}</span></code></td>
<td>A triple of three <code class="docutils literal"><span class="pre">i32</span></code> values</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">{</span> <span class="pre">float,</span> <span class="pre">i32</span> <span class="pre">(i32)</span> <span class="pre">*</span> <span class="pre">}</span></code></td>
<td>A pair, where the first element is a <code class="docutils literal"><span class="pre">float</span></code> and the second element is a <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to a <a class="reference internal" href="#t-function"><span class="std std-ref">function</span></a> that takes an <code class="docutils literal"><span class="pre">i32</span></code>, returning an <code class="docutils literal"><span class="pre">i32</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;{</span> <span class="pre">i8,</span> <span class="pre">i32</span> <span class="pre">}&gt;</span></code></td>
<td>A packed struct known to be 5 bytes in size.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="opaque-structure-types">
<span id="t-opaque"></span><h5><a class="toc-backref" href="#id704">Opaque Structure Types</a><a class="headerlink" href="#opaque-structure-types" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Opaque structure types are used to represent named structure types that
do not have a body specified. This corresponds (for example) to the C
notion of a forward declared structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span> <span class="n">opaque</span>
<span class="o">%</span><span class="mi">52</span> <span class="o">=</span> <span class="nb">type</span> <span class="n">opaque</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">opaque</span></code></td>
<td>An opaque type.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="section" id="constants">
<span id="id3"></span><h2><a class="toc-backref" href="#id705">Constants</a><a class="headerlink" href="#constants" title="永久链接至标题">¶</a></h2>
<p>LLVM has several different basic types of constants. This section
describes them all and their syntax.</p>
<div class="section" id="simple-constants">
<h3><a class="toc-backref" href="#id706">Simple Constants</a><a class="headerlink" href="#simple-constants" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt><strong>Boolean constants</strong></dt>
<dd>The two strings &#8216;<code class="docutils literal"><span class="pre">true</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">false</span></code>&#8216; are both valid constants
of the <code class="docutils literal"><span class="pre">i1</span></code> type.</dd>
<dt><strong>Integer constants</strong></dt>
<dd>Standard integers (such as &#8216;4&#8217;) are constants of the
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> type. Negative numbers may be used with
integer types.</dd>
<dt><strong>Floating point constants</strong></dt>
<dd>Floating point constants use standard decimal notation (e.g.
123.421), exponential notation (e.g. 1.23421e+2), or a more precise
hexadecimal notation (see below). The assembler requires the exact
decimal value of a floating-point constant. For example, the
assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating
decimal in binary. Floating point constants must have a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type.</dd>
<dt><strong>Null pointer constants</strong></dt>
<dd>The identifier &#8216;<code class="docutils literal"><span class="pre">null</span></code>&#8216; is recognized as a null pointer constant
and must be of <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer type</span></a>.</dd>
<dt><strong>Token constants</strong></dt>
<dd>The identifier &#8216;<code class="docutils literal"><span class="pre">none</span></code>&#8216; is recognized as an empty token constant
and must be of <a class="reference internal" href="#t-token"><span class="std std-ref">token type</span></a>.</dd>
</dl>
<p>The one non-intuitive notation for constants is the hexadecimal form of
floating point constants. For example, the form
&#8216;<code class="docutils literal"><span class="pre">double</span>&nbsp;&nbsp;&nbsp; <span class="pre">0x432ff973cafa8000</span></code>&#8216; is equivalent to (but harder to read
than) &#8216;<code class="docutils literal"><span class="pre">double</span> <span class="pre">4.5e+15</span></code>&#8216;. The only time hexadecimal floating point
constants are required (and the only time that they are generated by the
disassembler) is when a floating point constant must be emitted but it
cannot be represented as a decimal floating point number in a reasonable
number of digits. For example, NaN&#8217;s, infinities, and other special
values are represented in their IEEE hexadecimal format so that assembly
and disassembly do not cause any bits to change in the constants.</p>
<p>When using the hexadecimal form, constants of types half, float, and
double are represented using the 16-digit form shown above (which
matches the IEEE754 representation for double); half and float values
must, however, be exactly representable as IEEE 754 half and single
precision, respectively. Hexadecimal format is always used for long
double, and there are three forms of long double. The 80-bit format used
by x86 is represented as <code class="docutils literal"><span class="pre">0xK</span></code> followed by 20 hexadecimal digits. The
128-bit format used by PowerPC (two adjacent doubles) is represented by
<code class="docutils literal"><span class="pre">0xM</span></code> followed by 32 hexadecimal digits. The IEEE 128-bit format is
represented by <code class="docutils literal"><span class="pre">0xL</span></code> followed by 32 hexadecimal digits. Long doubles
will only work if they match the long double format on your target.
The IEEE 16-bit format (half precision) is represented by <code class="docutils literal"><span class="pre">0xH</span></code>
followed by 4 hexadecimal digits. All hexadecimal formats are big-endian
(sign bit at the left).</p>
<p>There are no constants of type x86_mmx.</p>
</div>
<div class="section" id="complex-constants">
<span id="complexconstants"></span><h3><a class="toc-backref" href="#id707">Complex Constants</a><a class="headerlink" href="#complex-constants" title="永久链接至标题">¶</a></h3>
<p>Complex constants are a (potentially recursive) combination of simple
constants and smaller complex constants.</p>
<dl class="docutils">
<dt><strong>Structure constants</strong></dt>
<dd>Structure constants are represented with notation similar to
structure type definitions (a comma separated list of elements,
surrounded by braces (<code class="docutils literal"><span class="pre">{}</span></code>)). For example:
&#8220;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i32</span> <span class="pre">4,</span> <span class="pre">float</span> <span class="pre">17.0,</span> <span class="pre">i32*</span> <span class="pre">&#64;G</span> <span class="pre">}</span></code>&#8221;, where &#8220;<code class="docutils literal"><span class="pre">&#64;G</span></code>&#8221; is declared as
&#8220;<code class="docutils literal"><span class="pre">&#64;G</span> <span class="pre">=</span> <span class="pre">external</span> <span class="pre">global</span> <span class="pre">i32</span></code>&#8221;. Structure constants must have
<a class="reference internal" href="#t-struct"><span class="std std-ref">structure type</span></a>, and the number and types of elements
must match those specified by the type.</dd>
<dt><strong>Array constants</strong></dt>
<dd>Array constants are represented with notation similar to array type
definitions (a comma separated list of elements, surrounded by
square brackets (<code class="docutils literal"><span class="pre">[]</span></code>)). For example:
&#8220;<code class="docutils literal"><span class="pre">[</span> <span class="pre">i32</span> <span class="pre">42,</span> <span class="pre">i32</span> <span class="pre">11,</span> <span class="pre">i32</span> <span class="pre">74</span> <span class="pre">]</span></code>&#8221;. Array constants must have
<a class="reference internal" href="#t-array"><span class="std std-ref">array type</span></a>, and the number and types of elements must
match those specified by the type. As a special case, character array
constants may also be represented as a double-quoted string using the <code class="docutils literal"><span class="pre">c</span></code>
prefix. For example: &#8220;<code class="docutils literal"><span class="pre">c&quot;Hello</span> <span class="pre">World\0A\00&quot;</span></code>&#8221;.</dd>
<dt><strong>Vector constants</strong></dt>
<dd>Vector constants are represented with notation similar to vector
type definitions (a comma separated list of elements, surrounded by
less-than/greater-than&#8217;s (<code class="docutils literal"><span class="pre">&lt;&gt;</span></code>)). For example:
&#8220;<code class="docutils literal"><span class="pre">&lt;</span> <span class="pre">i32</span> <span class="pre">42,</span> <span class="pre">i32</span> <span class="pre">11,</span> <span class="pre">i32</span> <span class="pre">74,</span> <span class="pre">i32</span> <span class="pre">100</span> <span class="pre">&gt;</span></code>&#8221;. Vector constants
must have <a class="reference internal" href="#t-vector"><span class="std std-ref">vector type</span></a>, and the number and types of
elements must match those specified by the type.</dd>
<dt><strong>Zero initialization</strong></dt>
<dd>The string &#8216;<code class="docutils literal"><span class="pre">zeroinitializer</span></code>&#8216; can be used to zero initialize a
value to zero of <em>any</em> type, including scalar and
<a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> types. This is often used to avoid
having to print large zero initializers (e.g. for large arrays) and
is always exactly equivalent to using explicit zero initializers.</dd>
<dt><strong>Metadata node</strong></dt>
<dd>A metadata node is a constant tuple without types. For example:
&#8220;<code class="docutils literal"><span class="pre">!{!0,</span> <span class="pre">!{!2,</span> <span class="pre">!0},</span> <span class="pre">!&quot;test&quot;}</span></code>&#8221;. Metadata can reference constant values,
for example: &#8220;<code class="docutils literal"><span class="pre">!{!0,</span> <span class="pre">i32</span> <span class="pre">0,</span> <span class="pre">i8*</span> <span class="pre">&#64;global,</span> <span class="pre">i64</span> <span class="pre">(i64)*</span> <span class="pre">&#64;function,</span> <span class="pre">!&quot;str&quot;}</span></code>&#8221;.
Unlike other typed constants that are meant to be interpreted as part of
the instruction stream, metadata is a place to attach additional
information such as debug info.</dd>
</dl>
</div>
<div class="section" id="global-variable-and-function-addresses">
<h3><a class="toc-backref" href="#id708">Global Variable and Function Addresses</a><a class="headerlink" href="#global-variable-and-function-addresses" title="永久链接至标题">¶</a></h3>
<p>The addresses of <a class="reference internal" href="#globalvars"><span class="std std-ref">global variables</span></a> and
<a class="reference internal" href="#functionstructure"><span class="std std-ref">functions</span></a> are always implicitly valid
(link-time) constants. These constants are explicitly referenced when
the <a class="reference internal" href="#identifiers"><span class="std std-ref">identifier for the global</span></a> is used and always have
<a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> type. For example, the following is a legal LLVM
file:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@X</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">17</span>
<span class="vg">@Y</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">42</span>
<span class="vg">@Z</span> <span class="p">=</span> <span class="k">global</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">*]</span> <span class="p">[</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@X</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@Y</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="undefined-values">
<span id="undefvalues"></span><h3><a class="toc-backref" href="#id709">Undefined Values</a><a class="headerlink" href="#undefined-values" title="永久链接至标题">¶</a></h3>
<p>The string &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; can be used anywhere a constant is expected, and
indicates that the user of the value may receive an unspecified
bit-pattern. Undefined values may be of any type (other than &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216;
or &#8216;<code class="docutils literal"><span class="pre">void</span></code>&#8216;) and be used anywhere a constant is permitted.</p>
<p>Undefined values are useful because they indicate to the compiler that
the program is well defined no matter what value is used. This gives the
compiler more freedom to optimize. Here are some examples of
(potentially surprising) transformations that are valid (in pseudo IR):</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">add</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">sub</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">xor</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">undef</span>
</pre></div>
</div>
<p>This is safe because all of the output bits are affected by the undef
bits. Any output bit can have a zero or one depending on the input bits.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">or</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">and</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="m">-1</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="m">0</span>
<span class="nl">Unsafe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">undef</span>
</pre></div>
</div>
<p>These logical operations have bits that are not always affected by the
input. For example, if <code class="docutils literal"><span class="pre">%X</span></code> has a zero bit, then the output of the
&#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; operation will always be a zero for that bit, no matter what
the corresponding bit from the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; is. As such, it is unsafe to
optimize or assume that the result of the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; is &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;.
However, it is safe to assume that all bits of the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; could be
0, and optimize the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; to 0. Likewise, it is safe to assume that
all the bits of the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; operand to the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; could be set,
allowing the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; to be folded to -1.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">select</span> <span class="k">undef</span><span class="p">,</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%Y</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">select</span> <span class="k">undef</span><span class="p">,</span> <span class="m">42</span><span class="p">,</span> <span class="nv">%Y</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">select</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%Y</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="nv">%X</span>     <span class="p">(</span><span class="k">or</span> <span class="nv">%Y</span><span class="p">)</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="m">42</span>     <span class="p">(</span><span class="k">or</span> <span class="nv">%Y</span><span class="p">)</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="nv">%Y</span>
<span class="nl">Unsafe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">undef</span>
</pre></div>
</div>
<p>This set of examples shows that undefined &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; (and conditional
branch) conditions can go <em>either way</em>, but they have to come from one
of the two operands. In the <code class="docutils literal"><span class="pre">%A</span></code> example, if <code class="docutils literal"><span class="pre">%X</span></code> and <code class="docutils literal"><span class="pre">%Y</span></code> were
both known to have a clear low bit, then <code class="docutils literal"><span class="pre">%A</span></code> would have to have a
cleared low bit. However, in the <code class="docutils literal"><span class="pre">%C</span></code> example, the optimizer is
allowed to assume that the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; operand could be the same as
<code class="docutils literal"><span class="pre">%Y</span></code>, allowing the whole &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; to be eliminated.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  %A = xor undef, undef

  %B = undef
  %C = xor %B, %B

  %D = undef
  %E = icmp slt %D, 4
  %F = icmp gte %D, 4

Safe:
  %A = undef
  %B = undef
  %C = undef
  %D = undef
  %E = undef
  %F = undef
</pre></div>
</div>
<p>This example points out that two &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; operands are not
necessarily the same. This can be surprising to people (and also matches
C semantics) where they assume that &#8220;<code class="docutils literal"><span class="pre">X^X</span></code>&#8221; is always zero, even if
<code class="docutils literal"><span class="pre">X</span></code> is undefined. This isn&#8217;t true for a number of reasons, but the
short answer is that an &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; &#8220;variable&#8221; can arbitrarily change
its value over its &#8220;live range&#8221;. This is true because the variable
doesn&#8217;t actually <em>have a live range</em>. Instead, the value is logically
read from arbitrary registers that happen to be around when needed, so
the value is not necessarily consistent over time. In fact, <code class="docutils literal"><span class="pre">%A</span></code> and
<code class="docutils literal"><span class="pre">%C</span></code> need to have the same semantics or the core LLVM &#8220;replace all
uses with&#8221; concept would not hold.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">fdiv</span> <span class="k">undef</span><span class="p">,</span> <span class="nv">%X</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">fdiv</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
<span class="nl">b:</span> <span class="k">unreachable</span>
</pre></div>
</div>
<p>These examples show the crucial difference between an <em>undefined value</em>
and <em>undefined behavior</em>. An undefined value (like &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;) is
allowed to have an arbitrary bit-pattern. This means that the <code class="docutils literal"><span class="pre">%A</span></code>
operation can be constant folded to &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;, because the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;
could be an SNaN, and <code class="docutils literal"><span class="pre">fdiv</span></code> is not (currently) defined on SNaN&#8217;s.
However, in the second example, we can make a more aggressive
assumption: because the <code class="docutils literal"><span class="pre">undef</span></code> is allowed to be an arbitrary value,
we are allowed to assume that it could be zero. Since a divide by zero
has <em>undefined behavior</em>, we are allowed to assume that the operation
does not execute at all. This allows us to delete the divide and all
code after it. Because the undefined operation &#8220;can&#8217;t happen&#8221;, the
optimizer can assume that it occurs in dead code.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>a:  store undef -&gt; %X
b:  store %X -&gt; undef
Safe:
a: &lt;deleted&gt;
b: unreachable
</pre></div>
</div>
<p>These examples reiterate the <code class="docutils literal"><span class="pre">fdiv</span></code> example: a store <em>of</em> an undefined
value can be assumed to not have any effect; we can assume that the
value is overwritten with bits that happen to match what was already
there. However, a store <em>to</em> an undefined location could clobber
arbitrary memory, therefore, it has undefined behavior.</p>
</div>
<div class="section" id="poison-values">
<span id="poisonvalues"></span><h3><a class="toc-backref" href="#id710">Poison Values</a><a class="headerlink" href="#poison-values" title="永久链接至标题">¶</a></h3>
<p>Poison values are similar to <a class="reference internal" href="#undefvalues"><span class="std std-ref">undef values</span></a>, however
they also represent the fact that an instruction or constant expression
that cannot evoke side effects has nevertheless detected a condition
that results in undefined behavior.</p>
<p>There is currently no way of representing a poison value in the IR; they
only exist when produced by operations such as <a class="reference internal" href="#i-add"><span class="std std-ref">add</span></a> with
the <code class="docutils literal"><span class="pre">nsw</span></code> flag.</p>
<p>Poison value behavior is defined in terms of value <em>dependence</em>:</p>
<ul class="simple">
<li>Values other than <a class="reference internal" href="#i-phi"><span class="std std-ref">phi</span></a> nodes depend on their operands.</li>
<li><a class="reference internal" href="#i-phi"><span class="std std-ref">Phi</span></a> nodes depend on the operand corresponding to
their dynamic predecessor basic block.</li>
<li>Function arguments depend on the corresponding actual argument values
in the dynamic callers of their functions.</li>
<li><a class="reference internal" href="#i-call"><span class="std std-ref">Call</span></a> instructions depend on the <a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a>
instructions that dynamically transfer control back to them.</li>
<li><a class="reference internal" href="#i-invoke"><span class="std std-ref">Invoke</span></a> instructions depend on the
<a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a>, <a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a>, or exception-throwing
call instructions that dynamically transfer control back to them.</li>
<li>Non-volatile loads and stores depend on the most recent stores to all
of the referenced memory addresses, following the order in the IR
(including loads and stores implied by intrinsics such as
<a class="reference internal" href="#int-memcpy"><span class="std std-ref">&#64;llvm.memcpy</span></a>.)</li>
<li>An instruction with externally visible side effects depends on the
most recent preceding instruction with externally visible side
effects, following the order in the IR. (This includes <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.)</li>
<li>An instruction <em>control-depends</em> on a <a class="reference internal" href="#terminators"><span class="std std-ref">terminator
instruction</span></a> if the terminator instruction has
multiple successors and the instruction is always executed when
control transfers to one of the successors, and may not be executed
when control is transferred to another.</li>
<li>Additionally, an instruction also <em>control-depends</em> on a terminator
instruction if the set of instructions it otherwise depends on would
be different if the terminator had transferred control to a different
successor.</li>
<li>Dependence is transitive.</li>
</ul>
<p>Poison values have the same behavior as <a class="reference internal" href="#undefvalues"><span class="std std-ref">undef values</span></a>,
with the additional effect that any instruction that has a <em>dependence</em>
on a poison value has undefined behavior.</p>
<p>Here are some examples:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
  <span class="nv">%poison</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">nuw</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>           <span class="c">; Results in a poison value.</span>
  <span class="nv">%still_poison</span> <span class="p">=</span> <span class="k">and</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="m">0</span>   <span class="c">; 0, but also poison.</span>
  <span class="nv">%poison_yet_again</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@h</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%still_poison</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%poison_yet_again</span>  <span class="c">; memory at @h[0] is poisoned</span>

  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>           <span class="c">; Poison value stored to memory.</span>
  <span class="nv">%poison2</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>         <span class="c">; Poison value loaded back from memory.</span>

  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>  <span class="c">; External observation; undefined behavior.</span>

  <span class="nv">%narrowaddr</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span> <span class="k">to</span> <span class="k">i16</span><span class="p">*</span>
  <span class="nv">%wideaddr</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span> <span class="k">to</span> <span class="k">i64</span><span class="p">*</span>
  <span class="nv">%poison3</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i16</span><span class="p">,</span> <span class="k">i16</span><span class="p">*</span> <span class="nv">%narrowaddr</span> <span class="c">; Returns a poison value.</span>
  <span class="nv">%poison4</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%wideaddr</span>  <span class="c">; Returns a poison value.</span>

  <span class="nv">%cmp</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">slt</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="m">0</span>       <span class="c">; Returns a poison value.</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%true</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%end</span>  <span class="c">; Branch to either destination.</span>

<span class="nl">true:</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>        <span class="c">; This is control-dependent on %cmp, so</span>
                                       <span class="c">; it has undefined behavior.</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%end</span>

<span class="nl">end:</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%entry</span> <span class="p">],</span> <span class="p">[</span> <span class="m">1</span><span class="p">,</span> <span class="nv">%true</span> <span class="p">]</span>
                                       <span class="c">; Both edges into this PHI are</span>
                                       <span class="c">; control-dependent on %cmp, so this</span>
                                       <span class="c">; always results in a poison value.</span>

  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>        <span class="c">; This would depend on the store in %true</span>
                                       <span class="c">; if %cmp is true, or the store in %entry</span>
                                       <span class="c">; otherwise, so this is undefined behavior.</span>

  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%second_true</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%second_end</span>
                                       <span class="c">; The same branch again, but this time the</span>
                                       <span class="c">; true block doesn&#39;t have side effects.</span>

<span class="nl">second_true:</span>
  <span class="c">; No side effects!</span>
  <span class="k">ret</span> <span class="kt">void</span>

<span class="nl">second_end:</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>        <span class="c">; This time, the instruction always depends</span>
                                       <span class="c">; on the store in %end. Also, it is</span>
                                       <span class="c">; control-equivalent to %end, so this is</span>
                                       <span class="c">; well-defined (ignoring earlier undefined</span>
                                       <span class="c">; behavior in this example).</span>
</pre></div>
</div>
</div>
<div class="section" id="addresses-of-basic-blocks">
<span id="blockaddress"></span><h3><a class="toc-backref" href="#id711">Addresses of Basic Blocks</a><a class="headerlink" href="#addresses-of-basic-blocks" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">blockaddress(&#64;function,</span> <span class="pre">%block)</span></code></p>
<p>The &#8216;<code class="docutils literal"><span class="pre">blockaddress</span></code>&#8216; constant computes the address of the specified
basic block in the specified function, and always has an <code class="docutils literal"><span class="pre">i8*</span></code> type.
Taking the address of the entry block is illegal.</p>
<p>This value only has defined behavior when used as an operand to the
&#8216;<a class="reference internal" href="#i-indirectbr"><span class="std std-ref">indirectbr</span></a>&#8216; instruction, or for comparisons
against null. Pointer equality tests between labels addresses results in
undefined behavior &#8212; though, again, comparison against null is ok, and
no label is equal to the null pointer. This may be passed around as an
opaque pointer sized value as long as the bits are not inspected. This
allows <code class="docutils literal"><span class="pre">ptrtoint</span></code> and arithmetic to be performed on these values so
long as the original value is reconstituted before the <code class="docutils literal"><span class="pre">indirectbr</span></code>
instruction.</p>
<p>Finally, some targets may provide defined semantics when using the value
as the operand to an inline assembly, but that is target specific.</p>
</div>
<div class="section" id="constant-expressions">
<span id="constantexprs"></span><h3><a class="toc-backref" href="#id712">Constant Expressions</a><a class="headerlink" href="#constant-expressions" title="永久链接至标题">¶</a></h3>
<p>Constant expressions are used to allow expressions involving other
constants to be used as constants. Constant expressions may be of any
<a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type and may involve any LLVM operation
that does not have side effects (e.g. load and call are not supported).
The following is the syntax for constant expressions:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">trunc</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Truncate a constant to another type. The bit size of CST must be
larger than the bit size of TYPE. Both types must be integers.</dd>
<dt><code class="docutils literal"><span class="pre">zext</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Zero extend a constant to another type. The bit size of CST must be
smaller than the bit size of TYPE. Both types must be integers.</dd>
<dt><code class="docutils literal"><span class="pre">sext</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Sign extend a constant to another type. The bit size of CST must be
smaller than the bit size of TYPE. Both types must be integers.</dd>
<dt><code class="docutils literal"><span class="pre">fptrunc</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Truncate a floating point constant to another floating point type.
The size of CST must be larger than the size of TYPE. Both types
must be floating point.</dd>
<dt><code class="docutils literal"><span class="pre">fpext</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Floating point extend a constant to another type. The size of CST
must be smaller or equal to the size of TYPE. Both types must be
floating point.</dd>
<dt><code class="docutils literal"><span class="pre">fptoui</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a floating point constant to the corresponding unsigned
integer constant. TYPE must be a scalar or vector integer type. CST
must be of scalar or vector floating point type. Both CST and TYPE
must be scalars, or vectors of the same number of elements. If the
value won&#8217;t fit in the integer type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">fptosi</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a floating point constant to the corresponding signed
integer constant. TYPE must be a scalar or vector integer type. CST
must be of scalar or vector floating point type. Both CST and TYPE
must be scalars, or vectors of the same number of elements. If the
value won&#8217;t fit in the integer type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">uitofp</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert an unsigned integer constant to the corresponding floating
point constant. TYPE must be a scalar or vector floating point type.
CST must be of scalar or vector integer type. Both CST and TYPE must
be scalars, or vectors of the same number of elements. If the value
won&#8217;t fit in the floating point type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">sitofp</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a signed integer constant to the corresponding floating
point constant. TYPE must be a scalar or vector floating point type.
CST must be of scalar or vector integer type. Both CST and TYPE must
be scalars, or vectors of the same number of elements. If the value
won&#8217;t fit in the floating point type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">ptrtoint</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a pointer typed constant to the corresponding integer
constant. <code class="docutils literal"><span class="pre">TYPE</span></code> must be an integer type. <code class="docutils literal"><span class="pre">CST</span></code> must be of
pointer type. The <code class="docutils literal"><span class="pre">CST</span></code> value is zero extended, truncated, or
unchanged to make it fit in <code class="docutils literal"><span class="pre">TYPE</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">inttoptr</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert an integer constant to a pointer constant. TYPE must be a
pointer type. CST must be of integer type. The CST value is zero
extended, truncated, or unchanged to make it fit in a pointer size.
This one is <em>really</em> dangerous!</dd>
<dt><code class="docutils literal"><span class="pre">bitcast</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a constant, CST, to another TYPE. The constraints of the
operands are the same as those for the <a class="reference internal" href="#i-bitcast"><span class="std std-ref">bitcast
instruction</span></a>.</dd>
<dt><code class="docutils literal"><span class="pre">addrspacecast</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a constant pointer or constant vector of pointer, CST, to another
TYPE in a different address space. The constraints of the operands are the
same as those for the <a class="reference internal" href="#i-addrspacecast"><span class="std std-ref">addrspacecast instruction</span></a>.</dd>
<dt><code class="docutils literal"><span class="pre">getelementptr</span> <span class="pre">(TY,</span> <span class="pre">CSTPTR,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code>, <code class="docutils literal"><span class="pre">getelementptr</span> <span class="pre">inbounds</span> <span class="pre">(TY,</span> <span class="pre">CSTPTR,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr operation</span></a> on
constants. As with the <a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr</span></a>
instruction, the index list may have zero or more indexes, which are
required to make sense for the type of &#8220;pointer to TY&#8221;.</dd>
<dt><code class="docutils literal"><span class="pre">select</span> <span class="pre">(COND,</span> <span class="pre">VAL1,</span> <span class="pre">VAL2)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-select"><span class="std std-ref">select operation</span></a> on constants.</dd>
<dt><code class="docutils literal"><span class="pre">icmp</span> <span class="pre">COND</span> <span class="pre">(VAL1,</span> <span class="pre">VAL2)</span></code></dt>
<dd>Performs the <a class="reference internal" href="#i-icmp"><span class="std std-ref">icmp operation</span></a> on constants.</dd>
<dt><code class="docutils literal"><span class="pre">fcmp</span> <span class="pre">COND</span> <span class="pre">(VAL1,</span> <span class="pre">VAL2)</span></code></dt>
<dd>Performs the <a class="reference internal" href="#i-fcmp"><span class="std std-ref">fcmp operation</span></a> on constants.</dd>
<dt><code class="docutils literal"><span class="pre">extractelement</span> <span class="pre">(VAL,</span> <span class="pre">IDX)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-extractelement"><span class="std std-ref">extractelement operation</span></a> on
constants.</dd>
<dt><code class="docutils literal"><span class="pre">insertelement</span> <span class="pre">(VAL,</span> <span class="pre">ELT,</span> <span class="pre">IDX)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-insertelement"><span class="std std-ref">insertelement operation</span></a> on
constants.</dd>
<dt><code class="docutils literal"><span class="pre">shufflevector</span> <span class="pre">(VEC1,</span> <span class="pre">VEC2,</span> <span class="pre">IDXMASK)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-shufflevector"><span class="std std-ref">shufflevector operation</span></a> on
constants.</dd>
<dt><code class="docutils literal"><span class="pre">extractvalue</span> <span class="pre">(VAL,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-extractvalue"><span class="std std-ref">extractvalue operation</span></a> on
constants. The index list is interpreted in a similar manner as
indices in a &#8216;<a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr</span></a>&#8216; operation. At
least one index value must be specified.</dd>
<dt><code class="docutils literal"><span class="pre">insertvalue</span> <span class="pre">(VAL,</span> <span class="pre">ELT,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-insertvalue"><span class="std std-ref">insertvalue operation</span></a> on constants.
The index list is interpreted in a similar manner as indices in a
&#8216;<a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr</span></a>&#8216; operation. At least one index
value must be specified.</dd>
<dt><code class="docutils literal"><span class="pre">OPCODE</span> <span class="pre">(LHS,</span> <span class="pre">RHS)</span></code></dt>
<dd>Perform the specified operation of the LHS and RHS constants. OPCODE
may be any of the <a class="reference internal" href="#binaryops"><span class="std std-ref">binary</span></a> or <a class="reference internal" href="#bitwiseops"><span class="std std-ref">bitwise
binary</span></a> operations. The constraints on operands are
the same as those for the corresponding instruction (e.g. no bitwise
operations on floating point values are allowed).</dd>
</dl>
</div>
</div>
<div class="section" id="other-values">
<h2><a class="toc-backref" href="#id713">Other Values</a><a class="headerlink" href="#other-values" title="永久链接至标题">¶</a></h2>
<div class="section" id="inline-assembler-expressions">
<span id="inlineasmexprs"></span><h3><a class="toc-backref" href="#id714">Inline Assembler Expressions</a><a class="headerlink" href="#inline-assembler-expressions" title="永久链接至标题">¶</a></h3>
<p>LLVM supports inline assembler expressions (as opposed to <a class="reference internal" href="#moduleasm"><span class="std std-ref">Module-Level
Inline Assembly</span></a>) through the use of a special value. This value
represents the inline assembler as a template string (containing the
instructions to emit), a list of operand constraints (stored as a string), a
flag that indicates whether or not the inline asm expression has side effects,
and a flag indicating whether the function containing the asm needs to align its
stack conservatively.</p>
<p>The template string supports argument substitution of the operands using &#8220;<code class="docutils literal"><span class="pre">$</span></code>&#8221;
followed by a number, to indicate substitution of the given register/memory
location, as specified by the constraint string. &#8220;<code class="docutils literal"><span class="pre">${NUM:MODIFIER}</span></code>&#8221; may also
be used, where <code class="docutils literal"><span class="pre">MODIFIER</span></code> is a target-specific annotation for how to print the
operand (See <a class="reference internal" href="#inline-asm-modifiers"><span class="std std-ref">Asm template argument modifiers</span></a>).</p>
<p>A literal &#8220;<code class="docutils literal"><span class="pre">$</span></code>&#8221; may be included by using &#8220;<code class="docutils literal"><span class="pre">$$</span></code>&#8221; in the template. To include
other special characters into the output, the usual &#8220;<code class="docutils literal"><span class="pre">\XX</span></code>&#8221; escapes may be
used, just as in other strings. Note that after template substitution, the
resulting assembly string is parsed by LLVM&#8217;s integrated assembler unless it is
disabled &#8211; even when emitting a <code class="docutils literal"><span class="pre">.s</span></code> file &#8211; and thus must contain assembly
syntax known to LLVM.</p>
<p>LLVM&#8217;s support for inline asm is modeled closely on the requirements of Clang&#8217;s
GCC-compatible inline-asm support. Thus, the feature-set and the constraint and
modifier codes listed here are similar or identical to those in GCC&#8217;s inline asm
support. However, to be clear, the syntax of the template and constraint strings
described here is <em>not</em> the same as the syntax accepted by GCC and Clang, and,
while most constraint letters are passed through as-is by Clang, some get
translated to other codes when converting from the C source to the LLVM
assembly.</p>
<p>An example inline assembler expression is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">i32</span> <span class="p">(</span><span class="k">i32</span><span class="p">)</span> <span class="k">asm</span> <span class="s">&quot;bswap $0&quot;</span><span class="p">,</span> <span class="s">&quot;=r,r&quot;</span>
</pre></div>
</div>
<p>Inline assembler expressions may <strong>only</strong> be used as the callee operand
of a <a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a> or an <a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a> instruction.
Thus, typically we have:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i32</span> <span class="k">asm</span> <span class="s">&quot;bswap $0&quot;</span><span class="p">,</span> <span class="s">&quot;=r,r&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Inline asms with side effects not visible in the constraint list must be
marked as having side effects. This is done through the use of the
&#8216;<code class="docutils literal"><span class="pre">sideeffect</span></code>&#8216; keyword, like so:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">sideeffect</span> <span class="s">&quot;eieio&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">()</span>
</pre></div>
</div>
<p>In some cases inline asms will contain code that will not work unless
the stack is aligned in some way, such as calls or SSE instructions on
x86, yet will not contain code that does that alignment within the asm.
The compiler should make conservative assumptions about what the asm
might contain and should generate its usual stack alignment code in the
prologue if the &#8216;<code class="docutils literal"><span class="pre">alignstack</span></code>&#8216; keyword is present:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">alignstack</span> <span class="s">&quot;eieio&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">()</span>
</pre></div>
</div>
<p>Inline asms also support using non-standard assembly dialects. The
assumed dialect is ATT. When the &#8216;<code class="docutils literal"><span class="pre">inteldialect</span></code>&#8216; keyword is present,
the inline asm is using the Intel dialect. Currently, ATT and Intel are
the only supported dialects. An example is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">inteldialect</span> <span class="s">&quot;eieio&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">()</span>
</pre></div>
</div>
<p>If multiple keywords appear the &#8216;<code class="docutils literal"><span class="pre">sideeffect</span></code>&#8216; keyword must come
first, the &#8216;<code class="docutils literal"><span class="pre">alignstack</span></code>&#8216; keyword second and the &#8216;<code class="docutils literal"><span class="pre">inteldialect</span></code>&#8216;
keyword last.</p>
<div class="section" id="inline-asm-constraint-string">
<h4><a class="toc-backref" href="#id715">Inline Asm Constraint String</a><a class="headerlink" href="#inline-asm-constraint-string" title="永久链接至标题">¶</a></h4>
<p>The constraint list is a comma-separated string, each element containing one or
more constraint codes.</p>
<p>For each element in the constraint list an appropriate register or memory
operand will be chosen, and it will be made available to assembly template
string expansion as <code class="docutils literal"><span class="pre">$0</span></code> for the first constraint in the list, <code class="docutils literal"><span class="pre">$1</span></code> for the
second, etc.</p>
<p>There are three different types of constraints, which are distinguished by a
prefix symbol in front of the constraint code: Output, Input, and Clobber. The
constraints must always be given in that order: outputs first, then inputs, then
clobbers. They cannot be intermingled.</p>
<p>There are also three different categories of constraint codes:</p>
<ul class="simple">
<li>Register constraint. This is either a register class, or a fixed physical
register. This kind of constraint will allocate a register, and if necessary,
bitcast the argument or result to the appropriate type.</li>
<li>Memory constraint. This kind of constraint is for use with an instruction
taking a memory operand. Different constraints allow for different addressing
modes used by the target.</li>
<li>Immediate value constraint. This kind of constraint is for an integer or other
immediate value which can be rendered directly into an instruction. The
various target-specific constraints allow the selection of a value in the
proper range for the instruction you wish to use it with.</li>
</ul>
<div class="section" id="output-constraints">
<h5><a class="toc-backref" href="#id716">Output constraints</a><a class="headerlink" href="#output-constraints" title="永久链接至标题">¶</a></h5>
<p>Output constraints are specified by an &#8220;<code class="docutils literal"><span class="pre">=</span></code>&#8221; prefix (e.g. &#8220;<code class="docutils literal"><span class="pre">=r</span></code>&#8221;). This
indicates that the assembly will write to this operand, and the operand will
then be made available as a return value of the <code class="docutils literal"><span class="pre">asm</span></code> expression. Output
constraints do not consume an argument from the call instruction. (Except, see
below about indirect outputs).</p>
<p>Normally, it is expected that no output locations are written to by the assembly
expression until <em>all</em> of the inputs have been read. As such, LLVM may assign
the same register to an output and an input. If this is not safe (e.g. if the
assembly contains two instructions, where the first writes to one output, and
the second reads an input and writes to a second output), then the &#8220;<code class="docutils literal"><span class="pre">&amp;</span></code>&#8221;
modifier must be used (e.g. &#8220;<code class="docutils literal"><span class="pre">=&amp;r</span></code>&#8221;) to specify that the output is an
&#8220;early-clobber&#8221; output. Marking an ouput as &#8220;early-clobber&#8221; ensures that LLVM
will not use the same register for any inputs (other than an input tied to this
output).</p>
</div>
<div class="section" id="input-constraints">
<h5><a class="toc-backref" href="#id717">Input constraints</a><a class="headerlink" href="#input-constraints" title="永久链接至标题">¶</a></h5>
<p>Input constraints do not have a prefix &#8211; just the constraint codes. Each input
constraint will consume one argument from the call instruction. It is not
permitted for the asm to write to any input register or memory location (unless
that input is tied to an output). Note also that multiple inputs may all be
assigned to the same register, if LLVM can determine that they necessarily all
contain the same value.</p>
<p>Instead of providing a Constraint Code, input constraints may also &#8220;tie&#8221;
themselves to an output constraint, by providing an integer as the constraint
string. Tied inputs still consume an argument from the call instruction, and
take up a position in the asm template numbering as is usual &#8211; they will simply
be constrained to always use the same register as the output they&#8217;ve been tied
to. For example, a constraint string of &#8220;<code class="docutils literal"><span class="pre">=r,0</span></code>&#8221; says to assign a register for
output, and use that register as an input as well (it being the 0&#8217;th
constraint).</p>
<p>It is permitted to tie an input to an &#8220;early-clobber&#8221; output. In that case, no
<em>other</em> input may share the same register as the input tied to the early-clobber
(even when the other input has the same value).</p>
<p>You may only tie an input to an output which has a register constraint, not a
memory constraint. Only a single input may be tied to an output.</p>
<p>There is also an &#8220;interesting&#8221; feature which deserves a bit of explanation: if a
register class constraint allocates a register which is too small for the value
type operand provided as input, the input value will be split into multiple
registers, and all of them passed to the inline asm.</p>
<p>However, this feature is often not as useful as you might think.</p>
<p>Firstly, the registers are <em>not</em> guaranteed to be consecutive. So, on those
architectures that have instructions which operate on multiple consecutive
instructions, this is not an appropriate way to support them. (e.g. the 32-bit
SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The
hardware then loads into both the named register, and the next register. This
feature of inline asm would not be useful to support that.)</p>
<p>A few of the targets provide a template string modifier allowing explicit access
to the second register of a two-register operand (e.g. MIPS <code class="docutils literal"><span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">M</span></code>, and
<code class="docutils literal"><span class="pre">D</span></code>). On such an architecture, you can actually access the second allocated
register (yet, still, not any subsequent ones). But, in that case, you&#8217;re still
probably better off simply splitting the value into two separate operands, for
clarity. (e.g. see the description of the <code class="docutils literal"><span class="pre">A</span></code> constraint on X86, which,
despite existing only for use with this feature, is not really a good idea to
use)</p>
</div>
<div class="section" id="indirect-inputs-and-outputs">
<h5><a class="toc-backref" href="#id718">Indirect inputs and outputs</a><a class="headerlink" href="#indirect-inputs-and-outputs" title="永久链接至标题">¶</a></h5>
<p>Indirect output or input constraints can be specified by the &#8220;<code class="docutils literal"><span class="pre">*</span></code>&#8221; modifier
(which goes after the &#8220;<code class="docutils literal"><span class="pre">=</span></code>&#8221; in case of an output). This indicates that the asm
will write to or read from the contents of an <em>address</em> provided as an input
argument. (Note that in this way, indirect outputs act more like an <em>input</em> than
an output: just like an input, they consume an argument of the call expression,
rather than producing a return value. An indirect output constraint is an
&#8220;output&#8221; only in that the asm is expected to write to the contents of the input
memory location, instead of just read from it).</p>
<p>This is most typically used for memory constraint, e.g. &#8220;<code class="docutils literal"><span class="pre">=*m</span></code>&#8221;, to pass the
address of a variable as a value.</p>
<p>It is also possible to use an indirect <em>register</em> constraint, but only on output
(e.g. &#8220;<code class="docutils literal"><span class="pre">=*r</span></code>&#8221;). This will cause LLVM to allocate a register for an output
value normally, and then, separately emit a store to the address provided as
input, after the provided inline asm. (It&#8217;s not clear what value this
functionality provides, compared to writing the store explicitly after the asm
statement, and it can only produce worse code, since it bypasses many
optimization passes. I would recommend not using it.)</p>
</div>
<div class="section" id="clobber-constraints">
<h5><a class="toc-backref" href="#id719">Clobber constraints</a><a class="headerlink" href="#clobber-constraints" title="永久链接至标题">¶</a></h5>
<p>A clobber constraint is indicated by a &#8220;<code class="docutils literal"><span class="pre">~</span></code>&#8221; prefix. A clobber does not
consume an input operand, nor generate an output. Clobbers cannot use any of the
general constraint code letters &#8211; they may use only explicit register
constraints, e.g. &#8220;<code class="docutils literal"><span class="pre">~{eax}</span></code>&#8221;. The one exception is that a clobber string of
&#8220;<code class="docutils literal"><span class="pre">~{memory}</span></code>&#8221; indicates that the assembly writes to arbitrary undeclared
memory locations &#8211; not only the memory pointed to by a declared indirect
output.</p>
</div>
<div class="section" id="constraint-codes">
<h5><a class="toc-backref" href="#id720">Constraint Codes</a><a class="headerlink" href="#constraint-codes" title="永久链接至标题">¶</a></h5>
<p>After a potential prefix comes constraint code, or codes.</p>
<p>A Constraint Code is either a single letter (e.g. &#8220;<code class="docutils literal"><span class="pre">r</span></code>&#8221;), a &#8220;<code class="docutils literal"><span class="pre">^</span></code>&#8221; character
followed by two letters (e.g. &#8220;<code class="docutils literal"><span class="pre">^wc</span></code>&#8221;), or &#8220;<code class="docutils literal"><span class="pre">{</span></code>&#8221; register-name &#8220;<code class="docutils literal"><span class="pre">}</span></code>&#8221;
(e.g. &#8220;<code class="docutils literal"><span class="pre">{eax}</span></code>&#8221;).</p>
<p>The one and two letter constraint codes are typically chosen to be the same as
GCC&#8217;s constraint codes.</p>
<p>A single constraint may include one or more than constraint code in it, leaving
it up to LLVM to choose which one to use. This is included mainly for
compatibility with the translation of GCC inline asm coming from clang.</p>
<p>There are two ways to specify alternatives, and either or both may be used in an
inline asm constraint list:</p>
<ol class="arabic simple">
<li>Append the codes to each other, making a constraint code set. E.g. &#8220;<code class="docutils literal"><span class="pre">im</span></code>&#8221;
or &#8220;<code class="docutils literal"><span class="pre">{eax}m</span></code>&#8221;. This means &#8220;choose any of the options in the set&#8221;. The
choice of constraint is made independently for each constraint in the
constraint list.</li>
<li>Use &#8220;<code class="docutils literal"><span class="pre">|</span></code>&#8221; between constraint code sets, creating alternatives. Every
constraint in the constraint list must have the same number of alternative
sets. With this syntax, the same alternative in <em>all</em> of the items in the
constraint list will be chosen together.</li>
</ol>
<p>Putting those together, you might have a two operand constraint string like
<code class="docutils literal"><span class="pre">&quot;rm|r,ri|rm&quot;</span></code>. This indicates that if operand 0 is <code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">m</span></code>, then
operand 1 may be one of <code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">i</span></code>. If operand 0 is <code class="docutils literal"><span class="pre">r</span></code>, then operand 1
may be one of <code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">m</span></code>. But, operand 0 and 1 cannot both be of type m.</p>
<p>However, the use of either of the alternatives features is <em>NOT</em> recommended, as
LLVM is not able to make an intelligent choice about which one to use. (At the
point it currently needs to choose, not enough information is available to do so
in a smart way.) Thus, it simply tries to make a choice that&#8217;s most likely to
compile, not one that will be optimal performance. (e.g., given &#8220;<code class="docutils literal"><span class="pre">rm</span></code>&#8221;, it&#8217;ll
always choose to use memory, not registers). And, if given multiple registers,
or multiple register classes, it will simply choose the first one. (In fact, it
doesn&#8217;t currently even ensure explicitly specified physical registers are
unique, so specifying multiple physical registers as alternatives, like
<code class="docutils literal"><span class="pre">{r11}{r12},{r11}{r12}</span></code>, will assign r11 to both operands, not at all what was
intended.)</p>
</div>
<div class="section" id="supported-constraint-code-list">
<h5><a class="toc-backref" href="#id721">Supported Constraint Code List</a><a class="headerlink" href="#supported-constraint-code-list" title="永久链接至标题">¶</a></h5>
<p>The constraint codes are, in general, expected to behave the same way they do in
GCC. LLVM&#8217;s support is often implemented on an &#8216;as-needed&#8217; basis, to support C
inline asm code which was supported by GCC. A mismatch in behavior between LLVM
and GCC likely indicates a bug in LLVM.</p>
<p>Some constraint codes are typically supported by all targets:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: A register in the target&#8217;s general purpose register class.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: A memory address operand. It is target-specific what addressing modes
are supported, typical examples are register, or register + register offset,
or register + immediate offset (of some target-specific size).</li>
<li><code class="docutils literal"><span class="pre">i</span></code>: An integer constant (of target-specific width). Allows either a simple
immediate, or a relocatable value.</li>
<li><code class="docutils literal"><span class="pre">n</span></code>: An integer constant &#8211; <em>not</em> including relocatable values.</li>
<li><code class="docutils literal"><span class="pre">s</span></code>: An integer constant, but allowing <em>only</em> relocatable values.</li>
<li><code class="docutils literal"><span class="pre">X</span></code>: Allows an operand of any kind, no constraint whatsoever. Typically
useful to pass a label for an asm branch or call.</li>
<li><code class="docutils literal"><span class="pre">{register-name}</span></code>: Requires exactly the named physical register.</li>
</ul>
<p>Other constraints are target-specific:</p>
<p>AArch64:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">z</span></code>: An immediate integer 0. Outputs <code class="docutils literal"><span class="pre">WZR</span></code> or <code class="docutils literal"><span class="pre">XZR</span></code>, as appropriate.</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer valid for an <code class="docutils literal"><span class="pre">ADD</span></code> or <code class="docutils literal"><span class="pre">SUB</span></code> instruction,
i.e. 0 to 4095 with optional shift by 12.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer that, when negated, is valid for an <code class="docutils literal"><span class="pre">ADD</span></code> or
<code class="docutils literal"><span class="pre">SUB</span></code> instruction, i.e. -1 to -4095 with optional left shift by 12.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate integer that is valid for the &#8216;bitmask immediate 32&#8217; of a
logical instruction like <code class="docutils literal"><span class="pre">AND</span></code>, <code class="docutils literal"><span class="pre">EOR</span></code>, or <code class="docutils literal"><span class="pre">ORR</span></code> with a 32-bit register.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer that is valid for the &#8216;bitmask immediate 64&#8217; of a
logical instruction like <code class="docutils literal"><span class="pre">AND</span></code>, <code class="docutils literal"><span class="pre">EOR</span></code>, or <code class="docutils literal"><span class="pre">ORR</span></code> with a 64-bit register.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer for use with the <code class="docutils literal"><span class="pre">MOV</span></code> assembly alias on a
32-bit register. This is a superset of <code class="docutils literal"><span class="pre">K</span></code>: in addition to the bitmask
immediate, also allows immediate integers which can be loaded with a single
<code class="docutils literal"><span class="pre">MOVZ</span></code> or <code class="docutils literal"><span class="pre">MOVL</span></code> instruction.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer for use with the <code class="docutils literal"><span class="pre">MOV</span></code> assembly alias on a
64-bit register. This is a superset of <code class="docutils literal"><span class="pre">L</span></code>.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>: Memory address operand must be in a single register (no
offsets). (However, LLVM currently does this for the <code class="docutils literal"><span class="pre">m</span></code> constraint as
well.)</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit integer register (W* or X*).</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: A 32, 64, or 128-bit floating-point/SIMD register.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: A lower 128-bit floating-point/SIMD register (<code class="docutils literal"><span class="pre">V0</span></code> to <code class="docutils literal"><span class="pre">V15</span></code>).</li>
</ul>
<p>AMDGPU:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">[0-9]v</span></code>: The 32-bit VGPR register, number 0-9.</li>
<li><code class="docutils literal"><span class="pre">[0-9]s</span></code>: The 32-bit SGPR register, number 0-9.</li>
</ul>
<p>All ARM modes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">Um</span></code>, <code class="docutils literal"><span class="pre">Un</span></code>, <code class="docutils literal"><span class="pre">Uq</span></code>, <code class="docutils literal"><span class="pre">Us</span></code>, <code class="docutils literal"><span class="pre">Ut</span></code>, <code class="docutils literal"><span class="pre">Uv</span></code>, <code class="docutils literal"><span class="pre">Uy</span></code>: Memory address
operand. Treated the same as operand <code class="docutils literal"><span class="pre">m</span></code>, at the moment.</li>
</ul>
<p>ARM and ARM&#8217;s Thumb2 mode:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">j</span></code>: An immediate integer between 0 and 65535 (valid for <code class="docutils literal"><span class="pre">MOVW</span></code>)</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer valid for a data-processing instruction.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer between -4095 and 4095.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate integer whose bitwise inverse is valid for a
data-processing instruction. (Can be used with template modifier &#8220;<code class="docutils literal"><span class="pre">B</span></code>&#8221; to
print the inverted value).</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer whose negation is valid for a data-processing
instruction. (Can be used with template modifier &#8220;<code class="docutils literal"><span class="pre">n</span></code>&#8221; to print the negated
value).</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: A power of two or a integer between 0 and 32.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: Invalid immediate constraint.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: Invalid immediate constraint.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A general-purpose 32-bit integer register (<code class="docutils literal"><span class="pre">r0-r15</span></code>).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: In Thumb2 mode, low 32-bit GPR registers (<code class="docutils literal"><span class="pre">r0-r7</span></code>). In ARM mode, same
as <code class="docutils literal"><span class="pre">r</span></code>.</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: In Thumb2 mode, a high 32-bit GPR register (<code class="docutils literal"><span class="pre">r8-r15</span></code>). In ARM mode,
invalid.</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s31</span></code>,
<code class="docutils literal"><span class="pre">d0-d31</span></code>, or <code class="docutils literal"><span class="pre">q0-q15</span></code>.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s15</span></code>,
<code class="docutils literal"><span class="pre">d0-d7</span></code>, or <code class="docutils literal"><span class="pre">q0-q3</span></code>.</li>
<li><code class="docutils literal"><span class="pre">t</span></code>: A floating-point/SIMD register, only supports 32-bit values:
<code class="docutils literal"><span class="pre">s0-s31</span></code>.</li>
</ul>
<p>ARM&#8217;s Thumb1 mode:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer between 0 and 255.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer between -255 and -1.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate integer between 0 and 255, with optional left-shift by
some amount.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer between -7 and 7.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer which is a multiple of 4 between 0 and 1020.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer between 0 and 31.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: An immediate integer which is a multiple of 4 between -508 and 508.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A low 32-bit GPR register (<code class="docutils literal"><span class="pre">r0-r7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: A low 32-bit GPR register (<code class="docutils literal"><span class="pre">r0-r7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: A high GPR register (<code class="docutils literal"><span class="pre">r0-r7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s31</span></code>,
<code class="docutils literal"><span class="pre">d0-d31</span></code>, or <code class="docutils literal"><span class="pre">q0-q15</span></code>.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s15</span></code>,
<code class="docutils literal"><span class="pre">d0-d7</span></code>, or <code class="docutils literal"><span class="pre">q0-q3</span></code>.</li>
<li><code class="docutils literal"><span class="pre">t</span></code>: A floating-point/SIMD register, only supports 32-bit values:
<code class="docutils literal"><span class="pre">s0-s31</span></code>.</li>
</ul>
<p>Hexagon:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">o</span></code>, <code class="docutils literal"><span class="pre">v</span></code>: A memory address operand, treated the same as constraint <code class="docutils literal"><span class="pre">m</span></code>,
at the moment.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit register.</li>
</ul>
<p>MSP430:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: An 8 or 16-bit register.</li>
</ul>
<p>MIPS:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate signed 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer zero.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate unsigned 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate 32-bit integer, where the lower 16 bits are 0.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer between -65535 and -1.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: An immediate signed 15-bit integer.</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: An immediate integer between 1 and 65535.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: A memory address operand. In MIPS-SE mode, allows a base address
register plus 16-bit immediate offset. In MIPS mode, just a base register.</li>
<li><code class="docutils literal"><span class="pre">R</span></code>: A memory address operand. In MIPS-SE mode, allows a base address
register plus a 9-bit signed offset. In MIPS mode, the same as constraint
<code class="docutils literal"><span class="pre">m</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ZC</span></code>: A memory address operand, suitable for use in a <code class="docutils literal"><span class="pre">pref</span></code>, <code class="docutils literal"><span class="pre">ll</span></code>, or
<code class="docutils literal"><span class="pre">sc</span></code> instruction on the given subtarget (details vary).</li>
<li><code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">d</span></code>,  <code class="docutils literal"><span class="pre">y</span></code>: A 32 or 64-bit GPR register.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32 or 64-bit FPU register (<code class="docutils literal"><span class="pre">F0-F31</span></code>), or a 128-bit MSA register
(<code class="docutils literal"><span class="pre">W0-W31</span></code>). In the case of MSA registers, it is recommended to use the <code class="docutils literal"><span class="pre">w</span></code>
argument modifier for compatibility with GCC.</li>
<li><code class="docutils literal"><span class="pre">c</span></code>: A 32-bit or 64-bit GPR register suitable for indirect jump (always
<code class="docutils literal"><span class="pre">25</span></code>).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: The <code class="docutils literal"><span class="pre">lo</span></code> register, 32 or 64-bit.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Invalid.</li>
</ul>
<p>NVPTX:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">b</span></code>: A 1-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">c</span></code> or <code class="docutils literal"><span class="pre">h</span></code>: A 16-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">l</span></code> or <code class="docutils literal"><span class="pre">N</span></code>: A 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32-bit float register.</li>
<li><code class="docutils literal"><span class="pre">d</span></code>: A 64-bit float register.</li>
</ul>
<p>PowerPC:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate signed 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate unsigned 16-bit integer, shifted left 16 bits.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate unsigned 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate signed 16-bit integer, shifted left 16 bits.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer greater than 31.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer that is an exact power of 2.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: The immediate integer constant 0.</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: An immediate integer constant whose negation is a signed 16-bit
constant.</li>
<li><code class="docutils literal"><span class="pre">es</span></code>, <code class="docutils literal"><span class="pre">o</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">Z</span></code>, <code class="docutils literal"><span class="pre">Zy</span></code>: A memory address operand, currently
treated the same as <code class="docutils literal"><span class="pre">m</span></code>.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">b</span></code>: A 32 or 64-bit integer register, excluding <code class="docutils literal"><span class="pre">R0</span></code> (that is:
<code class="docutils literal"><span class="pre">R1-R31</span></code>).</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32 or 64-bit float register (<code class="docutils literal"><span class="pre">F0-F31</span></code>), or when QPX is enabled, a
128 or 256-bit QPX register (<code class="docutils literal"><span class="pre">Q0-Q31</span></code>; aliases the <code class="docutils literal"><span class="pre">F</span></code> registers).</li>
<li><code class="docutils literal"><span class="pre">v</span></code>: For <code class="docutils literal"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">f32</span></code> or <code class="docutils literal"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">f64</span></code> types, when QPX is enabled, a
128 or 256-bit QPX register (<code class="docutils literal"><span class="pre">Q0-Q31</span></code>), otherwise a 128-bit
altivec vector register (<code class="docutils literal"><span class="pre">V0-V31</span></code>).</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: Condition register (<code class="docutils literal"><span class="pre">CR0-CR7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">wc</span></code>: An individual CR bit in a CR register.</li>
<li><code class="docutils literal"><span class="pre">wa</span></code>, <code class="docutils literal"><span class="pre">wd</span></code>, <code class="docutils literal"><span class="pre">wf</span></code>: Any 128-bit VSX vector register, from the full VSX
register set (overlapping both the floating-point and vector register files).</li>
<li><code class="docutils literal"><span class="pre">ws</span></code>: A 32 or 64-bit floating point register, from the full VSX register
set.</li>
</ul>
<p>Sparc:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate 13-bit signed integer.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32-bit integer register.</li>
</ul>
<p>SystemZ:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate unsigned 8-bit integer.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate unsigned 12-bit integer.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate signed 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate signed 20-bit integer.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer 0x7fffffff.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">T</span></code>: A memory address operand, treated the same as
<code class="docutils literal"><span class="pre">m</span></code>, at the moment.</li>
<li><code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">d</span></code>: A 32, 64, or 128-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">a</span></code>: A 32, 64, or 128-bit integer address register (excludes R0, which in an
address context evaluates as zero).</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: A 32-bit value in the high part of a 64bit data register
(LLVM-specific)</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32, 64, or 128-bit floating point register.</li>
</ul>
<p>X86:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer between 0 and 31.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer between 0 and 64.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate signed 8-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer, 0xff or 0xffff or (in 64-bit mode only)
0xffffffff.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer between 0 and 3.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate unsigned 8-bit integer.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: An immediate integer between 0 and 127.</li>
<li><code class="docutils literal"><span class="pre">e</span></code>: An immediate 32-bit signed integer.</li>
<li><code class="docutils literal"><span class="pre">Z</span></code>: An immediate 32-bit unsigned integer.</li>
<li><code class="docutils literal"><span class="pre">o</span></code>, <code class="docutils literal"><span class="pre">v</span></code>: Treated the same as <code class="docutils literal"><span class="pre">m</span></code>, at the moment.</li>
<li><code class="docutils literal"><span class="pre">q</span></code>: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit
<code class="docutils literal"><span class="pre">l</span></code> integer register. On X86-32, this is the <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code>, and <code class="docutils literal"><span class="pre">d</span></code>
registers, and on X86-64, it is all of the integer registers.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit
<code class="docutils literal"><span class="pre">h</span></code> integer register. This is the <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code>, and <code class="docutils literal"><span class="pre">d</span></code> registers.</li>
<li><code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">l</span></code>: An 8, 16, 32, or 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">R</span></code>: An 8, 16, 32, or 64-bit &#8220;legacy&#8221; integer register &#8211; one which has
existed since i386, and can be accessed without the REX prefix.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32, 64, or 80-bit &#8216;387 FPU stack pseudo-register.</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: A 64-bit MMX register, if MMX is enabled.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector
operand in a SSE register. If AVX is also enabled, can also be a 256-bit
vector operand in an AVX register. If AVX-512 is also enabled, can also be a
512-bit vector operand in an AVX512 register, Otherwise, an error.</li>
<li><code class="docutils literal"><span class="pre">Y</span></code>: The same as <code class="docutils literal"><span class="pre">x</span></code>, if <em>SSE2</em> is enabled, otherwise an error.</li>
<li><code class="docutils literal"><span class="pre">A</span></code>: Special case: allocates EAX first, then EDX, for a single operand (in
32-bit mode, a 64-bit integer operand will get split into two registers). It
is not recommended to use this constraint, as in 64-bit mode, the 64-bit
operand will get allocated only to RAX &#8211; if two 32-bit operands are needed,
you&#8217;re better off splitting it yourself, before passing it to the asm
statement.</li>
</ul>
<p>XCore:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32-bit integer register.</li>
</ul>
</div>
</div>
<div class="section" id="asm-template-argument-modifiers">
<span id="inline-asm-modifiers"></span><h4><a class="toc-backref" href="#id722">Asm template argument modifiers</a><a class="headerlink" href="#asm-template-argument-modifiers" title="永久链接至标题">¶</a></h4>
<p>In the asm template string, modifiers can be used on the operand reference, like
&#8220;<code class="docutils literal"><span class="pre">${0:n}</span></code>&#8221;.</p>
<p>The modifiers are, in general, expected to behave the same way they do in
GCC. LLVM&#8217;s support is often implemented on an &#8216;as-needed&#8217; basis, to support C
inline asm code which was supported by GCC. A mismatch in behavior between LLVM
and GCC likely indicates a bug in LLVM.</p>
<p>Target-independent:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">c</span></code>: Print an immediate integer constant unadorned, without
the target-specific immediate punctuation (e.g. no <code class="docutils literal"><span class="pre">$</span></code> prefix).</li>
<li><code class="docutils literal"><span class="pre">n</span></code>: Negate and print immediate integer constant unadorned, without the
target-specific immediate punctuation (e.g. no <code class="docutils literal"><span class="pre">$</span></code> prefix).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: Print as an unadorned label, without the target-specific label
punctuation (e.g. no <code class="docutils literal"><span class="pre">$</span></code> prefix).</li>
</ul>
<p>AArch64:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">w</span></code>: Print a GPR register with a <code class="docutils literal"><span class="pre">w*</span></code> name instead of <code class="docutils literal"><span class="pre">x*</span></code> name. E.g.,
instead of <code class="docutils literal"><span class="pre">x30</span></code>, print <code class="docutils literal"><span class="pre">w30</span></code>.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Print a GPR register with a <code class="docutils literal"><span class="pre">x*</span></code> name. (this is the default, anyhow).</li>
<li><code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, <code class="docutils literal"><span class="pre">q</span></code>: Print a floating-point/SIMD register with a
<code class="docutils literal"><span class="pre">b*</span></code>, <code class="docutils literal"><span class="pre">h*</span></code>, <code class="docutils literal"><span class="pre">s*</span></code>, <code class="docutils literal"><span class="pre">d*</span></code>, or <code class="docutils literal"><span class="pre">q*</span></code> name, rather than the default of
<code class="docutils literal"><span class="pre">v*</span></code>.</li>
</ul>
<p>AMDGPU:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: No effect.</li>
</ul>
<p>ARM:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">a</span></code>: Print an operand as an address (with <code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code> surrounding a
register).</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: No effect.</li>
<li><code class="docutils literal"><span class="pre">q</span></code>: No effect.</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: Print a VFP single-precision register as an indexed double (e.g. print
as <code class="docutils literal"><span class="pre">d4[1]</span></code> instead of <code class="docutils literal"><span class="pre">s9</span></code>)</li>
<li><code class="docutils literal"><span class="pre">B</span></code>: Bitwise invert and print an immediate integer constant without <code class="docutils literal"><span class="pre">#</span></code>
prefix.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the low 16-bits of an immediate integer constant.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: Print as a register set suitable for ldm/stm. Also prints <em>all</em>
register operands subsequent to the specified one (!), so use carefully.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>: Print the low-order register of a register-pair, or the low-order
register of a two-register operand.</li>
<li><code class="docutils literal"><span class="pre">R</span></code>: Print the high-order register of a register-pair, or the high-order
register of a two-register operand.</li>
<li><code class="docutils literal"><span class="pre">H</span></code>: Print the second register of a register-pair. (On a big-endian system,
<code class="docutils literal"><span class="pre">H</span></code> is equivalent to <code class="docutils literal"><span class="pre">Q</span></code>, and on little-endian system, <code class="docutils literal"><span class="pre">H</span></code> is equivalent
to <code class="docutils literal"><span class="pre">R</span></code>.)</li>
<li><code class="docutils literal"><span class="pre">e</span></code>: Print the low doubleword register of a NEON quad register.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: Print the high doubleword register of a NEON quad register.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: Print the base register of a memory operand without the <code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code>
adornment.</li>
</ul>
<p>Hexagon:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the second register of a two-register operand. Requires that it
has been allocated consecutively to the first.</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: Print the letter &#8216;i&#8217; if the operand is an integer constant, otherwise
nothing. Used to print &#8216;addi&#8217; vs &#8216;add&#8217; instructions.</li>
</ul>
<p>MSP430:</p>
<p>No additional modifiers.</p>
<p>MIPS:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code>: Print an immediate integer as hexadecimal</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Print the low 16 bits of an immediate integer as hexadecimal.</li>
<li><code class="docutils literal"><span class="pre">d</span></code>: Print an immediate integer as decimal.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: Subtract one and print an immediate integer as decimal.</li>
<li><code class="docutils literal"><span class="pre">z</span></code>: Print $0 if an immediate zero, otherwise print normally.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the low-order register of a two-register operand, or prints the
address of the low-order word of a double-word memory operand.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: Print the high-order register of a two-register operand, or prints the
address of the high-order word of a double-word memory operand.</li>
<li><code class="docutils literal"><span class="pre">D</span></code>: Print the second register of a two-register operand, or prints the
second word of a double-word memory operand. (On a big-endian system, <code class="docutils literal"><span class="pre">D</span></code> is
equivalent to <code class="docutils literal"><span class="pre">L</span></code>, and on little-endian system, <code class="docutils literal"><span class="pre">D</span></code> is equivalent to
<code class="docutils literal"><span class="pre">M</span></code>.)</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: No effect. Provided for compatibility with GCC which requires this
modifier in order to print MSA registers (<code class="docutils literal"><span class="pre">W0-W31</span></code>) with the <code class="docutils literal"><span class="pre">f</span></code>
constraint.</li>
</ul>
<p>NVPTX:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: No effect.</li>
</ul>
<p>PowerPC:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the second register of a two-register operand. Requires that it
has been allocated consecutively to the first.</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: Print the letter &#8216;i&#8217; if the operand is an integer constant, otherwise
nothing. Used to print &#8216;addi&#8217; vs &#8216;add&#8217; instructions.</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: For a memory operand, prints formatter for a two-register X-form
instruction. (Currently always prints <code class="docutils literal"><span class="pre">r0,OPERAND</span></code>).</li>
<li><code class="docutils literal"><span class="pre">U</span></code>: Prints &#8216;u&#8217; if the memory operand is an update form, and nothing
otherwise. (NOTE: LLVM does not support update form, so this will currently
always print nothing)</li>
<li><code class="docutils literal"><span class="pre">X</span></code>: Prints &#8216;x&#8217; if the memory operand is an indexed form. (NOTE: LLVM does
not support indexed form, so this will currently always print nothing)</li>
</ul>
<p>Sparc:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: No effect.</li>
</ul>
<p>SystemZ:</p>
<p>SystemZ implements only <code class="docutils literal"><span class="pre">n</span></code>, and does <em>not</em> support any of the other
target-independent modifiers.</p>
<p>X86:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">c</span></code>: Print an unadorned integer or symbol name. (The latter is
target-specific behavior for this typically target-independent modifier).</li>
<li><code class="docutils literal"><span class="pre">A</span></code>: Print a register name with a &#8216;<code class="docutils literal"><span class="pre">*</span></code>&#8216; before it.</li>
<li><code class="docutils literal"><span class="pre">b</span></code>: Print an 8-bit register name (e.g. <code class="docutils literal"><span class="pre">al</span></code>); do nothing on a memory
operand.</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: Print the upper 8-bit register name (e.g. <code class="docutils literal"><span class="pre">ah</span></code>); do nothing on a
memory operand.</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: Print the 16-bit register name (e.g. <code class="docutils literal"><span class="pre">ax</span></code>); do nothing on a memory
operand.</li>
<li><code class="docutils literal"><span class="pre">k</span></code>: Print the 32-bit register name (e.g. <code class="docutils literal"><span class="pre">eax</span></code>); do nothing on a memory
operand.</li>
<li><code class="docutils literal"><span class="pre">q</span></code>: Print the 64-bit register name (e.g. <code class="docutils literal"><span class="pre">rax</span></code>), if 64-bit registers are
available, otherwise the 32-bit register name; do nothing on a memory operand.</li>
<li><code class="docutils literal"><span class="pre">n</span></code>: Negate and print an unadorned integer, or, for operands other than an
immediate integer (e.g. a relocatable symbol expression), print a &#8216;-&#8216; before
the operand. (The behavior for relocatable symbol expressions is a
target-specific behavior for this typically target-independent modifier)</li>
<li><code class="docutils literal"><span class="pre">H</span></code>: Print a memory reference with additional offset +8.</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: Print a memory reference or operand for use as the argument of a call
instruction. (E.g. omit <code class="docutils literal"><span class="pre">(rip)</span></code>, even though it&#8217;s PC-relative.)</li>
</ul>
<p>XCore:</p>
<p>No additional modifiers.</p>
</div>
<div class="section" id="inline-asm-metadata">
<h4><a class="toc-backref" href="#id723">Inline Asm Metadata</a><a class="headerlink" href="#inline-asm-metadata" title="永久链接至标题">¶</a></h4>
<p>The call instructions that wrap inline asm nodes may have a
&#8220;<code class="docutils literal"><span class="pre">!srcloc</span></code>&#8221; MDNode attached to it that contains a list of constant
integers. If present, the code generator will use the integer as the
location cookie value when report errors through the <code class="docutils literal"><span class="pre">LLVMContext</span></code>
error reporting mechanisms. This allows a front-end to correlate backend
errors that occur with inline asm back to the source code that produced
it. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">sideeffect</span> <span class="s">&quot;something bad&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">(),</span> <span class="nv">!srcloc</span> <span class="nv nv-Anonymous">!42</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!42</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">1234567</span> <span class="p">}</span>
</pre></div>
</div>
<p>It is up to the front-end to make sense of the magic numbers it places
in the IR. If the MDNode contains multiple constants, the code generator
will use the one that corresponds to the line of the asm that the error
occurs on.</p>
</div>
</div>
</div>
<div class="section" id="metadata">
<span id="id4"></span><h2><a class="toc-backref" href="#id724">Metadata</a><a class="headerlink" href="#metadata" title="永久链接至标题">¶</a></h2>
<p>LLVM IR allows metadata to be attached to instructions in the program
that can convey extra information about the code to the optimizers and
code generator. One example application of metadata is source-level
debug information. There are two metadata primitives: strings and nodes.</p>
<p>Metadata does not have a type, and is not a value. If referenced from a
<code class="docutils literal"><span class="pre">call</span></code> instruction, it uses the <code class="docutils literal"><span class="pre">metadata</span></code> type.</p>
<p>All metadata are identified in syntax by a exclamation point (&#8216;<code class="docutils literal"><span class="pre">!</span></code>&#8216;).</p>
<div class="section" id="metadata-nodes-and-metadata-strings">
<span id="metadata-string"></span><h3><a class="toc-backref" href="#id725">Metadata Nodes and Metadata Strings</a><a class="headerlink" href="#metadata-nodes-and-metadata-strings" title="永久链接至标题">¶</a></h3>
<p>A metadata string is a string surrounded by double quotes. It can
contain any character by escaping non-printable characters with
&#8220;<code class="docutils literal"><span class="pre">\xx</span></code>&#8221; where &#8220;<code class="docutils literal"><span class="pre">xx</span></code>&#8221; is the two digit hex code. For example:
&#8220;<code class="docutils literal"><span class="pre">!&quot;test\00&quot;</span></code>&#8221;.</p>
<p>Metadata nodes are represented with notation similar to structure
constants (a comma separated list of elements, surrounded by braces and
preceded by an exclamation point). Metadata nodes can have any values as
their operand. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="p">!{</span> <span class="nv">!&quot;test\00&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">10</span><span class="p">}</span>
</pre></div>
</div>
<p>Metadata nodes that aren&#8217;t uniqued use the <code class="docutils literal"><span class="pre">distinct</span></code> keyword. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = distinct !{!&quot;test\00&quot;, i32 10}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">distinct</span></code> nodes are useful when nodes shouldn&#8217;t be merged based on their
content. They can also occur when transformations cause uniquing collisions
when metadata operands change.</p>
<p>A <a class="reference internal" href="#namedmetadatastructure"><span class="std std-ref">named metadata</span></a> is a collection of
metadata nodes, which can be looked up in the module symbol table. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">!foo</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nv nv-Anonymous">!3</span><span class="p">}</span>
</pre></div>
</div>
<p>Metadata can be used as function arguments. Here <code class="docutils literal"><span class="pre">llvm.dbg.value</span></code>
function is using two metadata arguments:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="kt">metadata</span> <span class="nv nv-Anonymous">!24</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="kt">metadata</span> <span class="nv nv-Anonymous">!25</span><span class="p">)</span>
</pre></div>
</div>
<p>Metadata can be attached to an instruction. Here metadata <code class="docutils literal"><span class="pre">!21</span></code> is attached
to the <code class="docutils literal"><span class="pre">add</span></code> instruction using the <code class="docutils literal"><span class="pre">!dbg</span></code> identifier:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%indvar.next</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%indvar</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!21</span>
</pre></div>
</div>
<p>Metadata can also be attached to a function definition. Here metadata <code class="docutils literal"><span class="pre">!22</span></code>
is attached to the <code class="docutils literal"><span class="pre">foo</span></code> function using the <code class="docutils literal"><span class="pre">!dbg</span></code> identifier:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!22</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More information about specific metadata nodes recognized by the
optimizers and code generator is found below.</p>
<div class="section" id="specialized-metadata-nodes">
<span id="specialized-metadata"></span><h4><a class="toc-backref" href="#id726">Specialized Metadata Nodes</a><a class="headerlink" href="#specialized-metadata-nodes" title="永久链接至标题">¶</a></h4>
<p>Specialized metadata nodes are custom data structures in metadata (as opposed
to generic tuples). Their fields are labelled, and can be specified in any
order.</p>
<p>These aren&#8217;t inherently debug info centric, but currently all the specialized
metadata nodes are related to debug info.</p>
<div class="section" id="dicompileunit">
<span id="id5"></span><h5><a class="toc-backref" href="#id727">DICompileUnit</a><a class="headerlink" href="#dicompileunit" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DICompileUnit</span></code> nodes represent a compile unit. The <code class="docutils literal"><span class="pre">enums:</span></code>,
<code class="docutils literal"><span class="pre">retainedTypes:</span></code>, <code class="docutils literal"><span class="pre">subprograms:</span></code>, <code class="docutils literal"><span class="pre">globals:</span></code>, <code class="docutils literal"><span class="pre">imports:</span></code> and <code class="docutils literal"><span class="pre">macros:</span></code>
fields are tuples containing the debug info to be emitted along with the compile
unit, regardless of code optimizations (some nodes are only emitted if there are
references to them from instructions).</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: &quot;clang&quot;,
                    isOptimized: true, flags: &quot;-O2&quot;, runtimeVersion: 2,
                    splitDebugFilename: &quot;abc.debug&quot;, emissionKind: 1,
                    enums: !2, retainedTypes: !3, subprograms: !4,
                    globals: !5, imports: !6, macros: !7, dwoId: 0x0abcd)
</pre></div>
</div>
<p>Compile unit descriptors provide the root scope for objects declared in a
specific compilation unit. File descriptors are defined using this scope.
These descriptors are collected by a named metadata <code class="docutils literal"><span class="pre">!llvm.dbg.cu</span></code>. They
keep track of subprograms, global variables, type information, and imported
entities (declarations and namespaces).</p>
</div>
<div class="section" id="difile">
<span id="id6"></span><h5><a class="toc-backref" href="#id728">DIFile</a><a class="headerlink" href="#difile" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIFile</span></code> nodes represent files. The <code class="docutils literal"><span class="pre">filename:</span></code> can include slashes.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DIFile</span><span class="p">(</span><span class="nl">filename:</span> <span class="s">&quot;path/to/file&quot;</span><span class="p">,</span> <span class="nl">directory:</span> <span class="s">&quot;/path/to/dir&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Files are sometimes used in <code class="docutils literal"><span class="pre">scope:</span></code> fields, and are the only valid target
for <code class="docutils literal"><span class="pre">file:</span></code> fields.</p>
</div>
<div class="section" id="dibasictype">
<span id="id7"></span><h5><a class="toc-backref" href="#id729">DIBasicType</a><a class="headerlink" href="#dibasictype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIBasicType</span></code> nodes represent primitive types, such as <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">bool</span></code> and
<code class="docutils literal"><span class="pre">float</span></code>. <code class="docutils literal"><span class="pre">tag:</span></code> defaults to <code class="docutils literal"><span class="pre">DW_TAG_base_type</span></code>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIBasicType(name: &quot;unsigned char&quot;, size: 8, align: 8,
                  encoding: DW_ATE_unsigned_char)
!1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: &quot;decltype(nullptr)&quot;)
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">encoding:</span></code> describes the details of the type. Usually it&#8217;s one of the
following:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>DW_ATE_address       = 1
DW_ATE_boolean       = 2
DW_ATE_float         = 4
DW_ATE_signed        = 5
DW_ATE_signed_char   = 6
DW_ATE_unsigned      = 7
DW_ATE_unsigned_char = 8
</pre></div>
</div>
</div>
<div class="section" id="disubroutinetype">
<span id="id8"></span><h5><a class="toc-backref" href="#id730">DISubroutineType</a><a class="headerlink" href="#disubroutinetype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DISubroutineType</span></code> nodes represent subroutine types. Their <code class="docutils literal"><span class="pre">types:</span></code> field
refers to a tuple; the first operand is the return type, while the rest are the
types of the formal arguments in order. If the first operand is <code class="docutils literal"><span class="pre">null</span></code>, that
represents a function with no return value (such as <code class="docutils literal"><span class="pre">void</span> <span class="pre">foo()</span> <span class="pre">{}</span></code> in C++).</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !BasicType(name: &quot;int&quot;, size: 32, align: 32, DW_ATE_signed)
!1 = !BasicType(name: &quot;char&quot;, size: 8, align: 8, DW_ATE_signed_char)
!2 = !DISubroutineType(types: !{null, !0, !1}) ; void (int, char)
</pre></div>
</div>
</div>
<div class="section" id="diderivedtype">
<span id="id9"></span><h5><a class="toc-backref" href="#id731">DIDerivedType</a><a class="headerlink" href="#diderivedtype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIDerivedType</span></code> nodes represent types derived from other types, such as
qualified types.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIBasicType(name: &quot;unsigned char&quot;, size: 8, align: 8,
                  encoding: DW_ATE_unsigned_char)
!1 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !0, size: 32,
                    align: 32)
</pre></div>
</div>
<p>The following <code class="docutils literal"><span class="pre">tag:</span></code> values are valid:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>DW_TAG_formal_parameter   = 5
DW_TAG_member             = 13
DW_TAG_pointer_type       = 15
DW_TAG_reference_type     = 16
DW_TAG_typedef            = 22
DW_TAG_ptr_to_member_type = 31
DW_TAG_const_type         = 38
DW_TAG_volatile_type      = 53
DW_TAG_restrict_type      = 55
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">DW_TAG_member</span></code> is used to define a member of a <a class="reference internal" href="#dicompositetype"><span class="std std-ref">composite type</span></a> or <a class="reference internal" href="#disubprogram"><span class="std std-ref">subprogram</span></a>. The type of the member
is the <code class="docutils literal"><span class="pre">baseType:</span></code>. The <code class="docutils literal"><span class="pre">offset:</span></code> is the member&#8217;s bit offset.
<code class="docutils literal"><span class="pre">DW_TAG_formal_parameter</span></code> is used to define a member which is a formal
argument of a subprogram.</p>
<p><code class="docutils literal"><span class="pre">DW_TAG_typedef</span></code> is used to provide a name for the <code class="docutils literal"><span class="pre">baseType:</span></code>.</p>
<p><code class="docutils literal"><span class="pre">DW_TAG_pointer_type</span></code>, <code class="docutils literal"><span class="pre">DW_TAG_reference_type</span></code>, <code class="docutils literal"><span class="pre">DW_TAG_const_type</span></code>,
<code class="docutils literal"><span class="pre">DW_TAG_volatile_type</span></code> and <code class="docutils literal"><span class="pre">DW_TAG_restrict_type</span></code> are used to qualify the
<code class="docutils literal"><span class="pre">baseType:</span></code>.</p>
<p>Note that the <code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></code> type is expressed as a type derived from NULL.</p>
</div>
<div class="section" id="dicompositetype">
<span id="id10"></span><h5><a class="toc-backref" href="#id732">DICompositeType</a><a class="headerlink" href="#dicompositetype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DICompositeType</span></code> nodes represent types composed of other types, like
structures and unions. <code class="docutils literal"><span class="pre">elements:</span></code> points to a tuple of the composed types.</p>
<p>If the source language supports ODR, the <code class="docutils literal"><span class="pre">identifier:</span></code> field gives the unique
identifier used for type merging between modules. When specified, other types
can refer to composite types indirectly via a <a class="reference internal" href="#metadata-string"><span class="std std-ref">metadata string</span></a> that matches their identifier.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIEnumerator(name: &quot;SixKind&quot;, value: 7)
!1 = !DIEnumerator(name: &quot;SevenKind&quot;, value: 7)
!2 = !DIEnumerator(name: &quot;NegEightKind&quot;, value: -8)
!3 = !DICompositeType(tag: DW_TAG_enumeration_type, name: &quot;Enum&quot;, file: !12,
                      line: 2, size: 32, align: 32, identifier: &quot;_M4Enum&quot;,
                      elements: !{!0, !1, !2})
</pre></div>
</div>
<p>The following <code class="docutils literal"><span class="pre">tag:</span></code> values are valid:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>DW_TAG_array_type       = 1
DW_TAG_class_type       = 2
DW_TAG_enumeration_type = 4
DW_TAG_structure_type   = 19
DW_TAG_union_type       = 23
DW_TAG_subroutine_type  = 21
DW_TAG_inheritance      = 28
</pre></div>
</div>
<p>For <code class="docutils literal"><span class="pre">DW_TAG_array_type</span></code>, the <code class="docutils literal"><span class="pre">elements:</span></code> should be <a class="reference internal" href="#disubrange"><span class="std std-ref">subrange
descriptors</span></a>, each representing the range of subscripts at that
level of indexing. The <code class="docutils literal"><span class="pre">DIFlagVector</span></code> flag to <code class="docutils literal"><span class="pre">flags:</span></code> indicates that an
array type is a native packed vector.</p>
<p>For <code class="docutils literal"><span class="pre">DW_TAG_enumeration_type</span></code>, the <code class="docutils literal"><span class="pre">elements:</span></code> should be <a class="reference internal" href="#dienumerator"><span class="std std-ref">enumerator
descriptors</span></a>, each representing the definition of an enumeration
value for the set. All enumeration type descriptors are collected in the
<code class="docutils literal"><span class="pre">enums:</span></code> field of the <a class="reference internal" href="#dicompileunit"><span class="std std-ref">compile unit</span></a>.</p>
<p>For <code class="docutils literal"><span class="pre">DW_TAG_structure_type</span></code>, <code class="docutils literal"><span class="pre">DW_TAG_class_type</span></code>, and
<code class="docutils literal"><span class="pre">DW_TAG_union_type</span></code>, the <code class="docutils literal"><span class="pre">elements:</span></code> should be <a class="reference internal" href="#diderivedtype"><span class="std std-ref">derived types</span></a> with <code class="docutils literal"><span class="pre">tag:</span> <span class="pre">DW_TAG_member</span></code> or <code class="docutils literal"><span class="pre">tag:</span> <span class="pre">DW_TAG_inheritance</span></code>.</p>
</div>
<div class="section" id="disubrange">
<span id="id11"></span><h5><a class="toc-backref" href="#id733">DISubrange</a><a class="headerlink" href="#disubrange" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DISubrange</span></code> nodes are the elements for <code class="docutils literal"><span class="pre">DW_TAG_array_type</span></code> variants of
<a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a>. <code class="docutils literal"><span class="pre">count:</span> <span class="pre">-1</span></code> indicates an empty array.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DISubrange</span><span class="p">(</span><span class="nl">count:</span> <span class="m">5</span><span class="p">,</span> <span class="nl">lowerBound:</span> <span class="m">0</span><span class="p">)</span> <span class="c">; array counting from 0</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="nv">!DISubrange</span><span class="p">(</span><span class="nl">count:</span> <span class="m">5</span><span class="p">,</span> <span class="nl">lowerBound:</span> <span class="m">1</span><span class="p">)</span> <span class="c">; array counting from 1</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="nv">!DISubrange</span><span class="p">(</span><span class="nl">count:</span> <span class="m">-1</span><span class="p">)</span> <span class="c">; empty array.</span>
</pre></div>
</div>
</div>
<div class="section" id="dienumerator">
<span id="id12"></span><h5><a class="toc-backref" href="#id734">DIEnumerator</a><a class="headerlink" href="#dienumerator" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIEnumerator</span></code> nodes are the elements for <code class="docutils literal"><span class="pre">DW_TAG_enumeration_type</span></code>
variants of <a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DIEnumerator</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;SixKind&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="m">7</span><span class="p">)</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="nv">!DIEnumerator</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;SevenKind&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="m">7</span><span class="p">)</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="nv">!DIEnumerator</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;NegEightKind&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="m">-8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ditemplatetypeparameter">
<h5><a class="toc-backref" href="#id735">DITemplateTypeParameter</a><a class="headerlink" href="#ditemplatetypeparameter" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DITemplateTypeParameter</span></code> nodes represent type parameters to generic source
language constructs. They are used (optionally) in <a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a> and
<a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a> <code class="docutils literal"><span class="pre">templateParams:</span></code> fields.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DITemplateTypeParameter</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;Ty&quot;</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ditemplatevalueparameter">
<h5><a class="toc-backref" href="#id736">DITemplateValueParameter</a><a class="headerlink" href="#ditemplatevalueparameter" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DITemplateValueParameter</span></code> nodes represent value parameters to generic source
language constructs. <code class="docutils literal"><span class="pre">tag:</span></code> defaults to <code class="docutils literal"><span class="pre">DW_TAG_template_value_parameter</span></code>,
but if specified can also be set to <code class="docutils literal"><span class="pre">DW_TAG_GNU_template_template_param</span></code> or
<code class="docutils literal"><span class="pre">DW_TAG_GNU_template_param_pack</span></code>. They are used (optionally) in
<a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a> and <a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a> <code class="docutils literal"><span class="pre">templateParams:</span></code> fields.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DITemplateValueParameter</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;Ty&quot;</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">value:</span> <span class="k">i32</span> <span class="m">7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dinamespace">
<h5><a class="toc-backref" href="#id737">DINamespace</a><a class="headerlink" href="#dinamespace" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DINamespace</span></code> nodes represent namespaces in the source language.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DINamespace</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;myawesomeproject&quot;</span><span class="p">,</span> <span class="nl">scope:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="diglobalvariable">
<h5><a class="toc-backref" href="#id738">DIGlobalVariable</a><a class="headerlink" href="#diglobalvariable" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIGlobalVariable</span></code> nodes represent global variables in the source language.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DIGlobalVariable</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="nl">linkageName:</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="nl">scope:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span>
                       <span class="nl">file:</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nl">isLocal:</span> <span class="k">true</span><span class="p">,</span>
                       <span class="nl">isDefinition:</span> <span class="k">false</span><span class="p">,</span> <span class="nl">variable:</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@foo</span><span class="p">,</span>
                       <span class="nl">declaration:</span> <span class="nv nv-Anonymous">!4</span><span class="p">)</span>
</pre></div>
</div>
<p>All global variables should be referenced by the <cite>globals:</cite> field of a
<a class="reference internal" href="#dicompileunit"><span class="std std-ref">compile unit</span></a>.</p>
</div>
<div class="section" id="disubprogram">
<span id="id13"></span><h5><a class="toc-backref" href="#id739">DISubprogram</a><a class="headerlink" href="#disubprogram" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DISubprogram</span></code> nodes represent functions from the source language. A
<code class="docutils literal"><span class="pre">DISubprogram</span></code> may be attached to a function definition using <code class="docutils literal"><span class="pre">!dbg</span></code>
metadata. The <code class="docutils literal"><span class="pre">variables:</span></code> field points at <a class="reference internal" href="#dilocalvariable"><span class="std std-ref">variables</span></a>
that must be retained, even if their IR counterparts are optimized out of
the IR. The <code class="docutils literal"><span class="pre">type:</span></code> field must point at an <a class="reference internal" href="#disubroutinetype"><span class="std std-ref">DISubroutineType</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>define void @_Z3foov() !dbg !0 {
  ...
}

!0 = distinct !DISubprogram(name: &quot;foo&quot;, linkageName: &quot;_Zfoov&quot;, scope: !1,
                            file: !2, line: 7, type: !3, isLocal: true,
                            isDefinition: false, scopeLine: 8,
                            containingType: !4,
                            virtuality: DW_VIRTUALITY_pure_virtual,
                            virtualIndex: 10, flags: DIFlagPrototyped,
                            isOptimized: true, templateParams: !5,
                            declaration: !6, variables: !7)
</pre></div>
</div>
</div>
<div class="section" id="dilexicalblock">
<span id="id14"></span><h5><a class="toc-backref" href="#id740">DILexicalBlock</a><a class="headerlink" href="#dilexicalblock" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILexicalBlock</span></code> nodes describe nested blocks within a <a class="reference internal" href="#disubprogram"><span class="std std-ref">subprogram</span></a>. The line number and column numbers are used to distinguish
two lexical blocks at same depth. They are valid targets for <code class="docutils literal"><span class="pre">scope:</span></code>
fields.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = distinct !DILexicalBlock(scope: !1, file: !2, line: 7, column: 35)
</pre></div>
</div>
<p>Usually lexical blocks are <code class="docutils literal"><span class="pre">distinct</span></code> to prevent node merging based on
operands.</p>
</div>
<div class="section" id="dilexicalblockfile">
<span id="id15"></span><h5><a class="toc-backref" href="#id741">DILexicalBlockFile</a><a class="headerlink" href="#dilexicalblockfile" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILexicalBlockFile</span></code> nodes are used to discriminate between sections of a
<a class="reference internal" href="#dilexicalblock"><span class="std std-ref">lexical block</span></a>. The <code class="docutils literal"><span class="pre">file:</span></code> field can be changed to
indicate textual inclusion, or the <code class="docutils literal"><span class="pre">discriminator:</span></code> field can be used to
discriminate between control flow within a single block in the source language.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DILexicalBlock</span><span class="p">(</span><span class="nl">scope:</span> <span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">column:</span> <span class="m">35</span><span class="p">)</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="nv">!DILexicalBlockFile</span><span class="p">(</span><span class="nl">scope:</span> <span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nl">discriminator:</span> <span class="m">0</span><span class="p">)</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="nv">!DILexicalBlockFile</span><span class="p">(</span><span class="nl">scope:</span> <span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nl">discriminator:</span> <span class="m">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dilocation">
<span id="id16"></span><h5><a class="toc-backref" href="#id742">DILocation</a><a class="headerlink" href="#dilocation" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILocation</span></code> nodes represent source debug locations. The <code class="docutils literal"><span class="pre">scope:</span></code> field is
mandatory, and points at an <a class="reference internal" href="#dilexicalblockfile"><span class="std std-ref">DILexicalBlockFile</span></a>, an
<a class="reference internal" href="#dilexicalblock"><span class="std std-ref">DILexicalBlock</span></a>, or an <a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DILocation</span><span class="p">(</span><span class="nl">line:</span> <span class="m">2900</span><span class="p">,</span> <span class="nl">column:</span> <span class="m">42</span><span class="p">,</span> <span class="nl">scope:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">inlinedAt:</span> <span class="nv nv-Anonymous">!2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dilocalvariable">
<span id="id17"></span><h5><a class="toc-backref" href="#id743">DILocalVariable</a><a class="headerlink" href="#dilocalvariable" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILocalVariable</span></code> nodes represent local variables in the source language. If
the <code class="docutils literal"><span class="pre">arg:</span></code> field is set to non-zero, then this variable is a subprogram
parameter, and it will be included in the <code class="docutils literal"><span class="pre">variables:</span></code> field of its
<a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DILocalVariable(name: &quot;this&quot;, arg: 1, scope: !3, file: !2, line: 7,
                      type: !3, flags: DIFlagArtificial)
!1 = !DILocalVariable(name: &quot;x&quot;, arg: 2, scope: !4, file: !2, line: 7,
                      type: !3)
!2 = !DILocalVariable(name: &quot;y&quot;, scope: !5, file: !2, line: 7, type: !3)
</pre></div>
</div>
</div>
<div class="section" id="diexpression">
<h5><a class="toc-backref" href="#id744">DIExpression</a><a class="headerlink" href="#diexpression" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIExpression</span></code> nodes represent DWARF expression sequences. They are used in
<a class="reference internal" href="#dbg-intrinsics"><span class="std std-ref">debug intrinsics</span></a> (such as <code class="docutils literal"><span class="pre">llvm.dbg.declare</span></code>) to
describe how the referenced LLVM variable relates to the source language
variable.</p>
<p>The current supported vocabulary is limited:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">DW_OP_deref</span></code> dereferences the working expression.</li>
<li><code class="docutils literal"><span class="pre">DW_OP_plus,</span> <span class="pre">93</span></code> adds <code class="docutils literal"><span class="pre">93</span></code> to the working expression.</li>
<li><code class="docutils literal"><span class="pre">DW_OP_bit_piece,</span> <span class="pre">16,</span> <span class="pre">8</span></code> specifies the offset and size (<code class="docutils literal"><span class="pre">16</span></code> and <code class="docutils literal"><span class="pre">8</span></code>
here, respectively) of the variable piece from the working expression.</li>
</ul>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIExpression(DW_OP_deref)
!1 = !DIExpression(DW_OP_plus, 3)
!2 = !DIExpression(DW_OP_bit_piece, 3, 7)
!3 = !DIExpression(DW_OP_deref, DW_OP_plus, 3, DW_OP_bit_piece, 3, 7)
</pre></div>
</div>
</div>
<div class="section" id="diobjcproperty">
<h5><a class="toc-backref" href="#id745">DIObjCProperty</a><a class="headerlink" href="#diobjcproperty" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIObjCProperty</span></code> nodes represent Objective-C property nodes.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="nv">!DIObjCProperty</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">setter:</span> <span class="s">&quot;setFoo&quot;</span><span class="p">,</span>
                     <span class="nl">getter:</span> <span class="s">&quot;getFoo&quot;</span><span class="p">,</span> <span class="nl">attributes:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="diimportedentity">
<h5><a class="toc-backref" href="#id746">DIImportedEntity</a><a class="headerlink" href="#diimportedentity" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIImportedEntity</span></code> nodes represent entities (such as modules) imported into a
compile unit.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!2 = !DIImportedEntity(tag: DW_TAG_imported_module, name: &quot;foo&quot;, scope: !0,
                       entity: !1, line: 7)
</pre></div>
</div>
</div>
<div class="section" id="dimacro">
<h5><a class="toc-backref" href="#id747">DIMacro</a><a class="headerlink" href="#dimacro" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIMacro</span></code> nodes represent definition or undefinition of a macro identifiers.
The <code class="docutils literal"><span class="pre">name:</span></code> field is the macro identifier, followed by macro parameters when
definining a function-like macro, and the <code class="docutils literal"><span class="pre">value</span></code> field is the token-string
used to expand the macro identifier.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!2 = !DIMacro(macinfo: DW_MACINFO_define, line: 7, name: &quot;foo(x)&quot;,
              value: &quot;((x) + 1)&quot;)
!3 = !DIMacro(macinfo: DW_MACINFO_undef, line: 30, name: &quot;foo&quot;)
</pre></div>
</div>
</div>
<div class="section" id="dimacrofile">
<h5><a class="toc-backref" href="#id748">DIMacroFile</a><a class="headerlink" href="#dimacrofile" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIMacroFile</span></code> nodes represent inclusion of source files.
The <code class="docutils literal"><span class="pre">nodes:</span></code> field is a list of <code class="docutils literal"><span class="pre">DIMacro</span></code> and <code class="docutils literal"><span class="pre">DIMacroFile</span></code> nodes that
appear in the included source file.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!2 = !DIMacroFile(macinfo: DW_MACINFO_start_file, line: 7, file: !2,
                  nodes: !3)
</pre></div>
</div>
</div>
</div>
<div class="section" id="tbaa-metadata">
<h4><a class="toc-backref" href="#id749">&#8216;<code class="docutils literal"><span class="pre">tbaa</span></code>&#8216; Metadata</a><a class="headerlink" href="#tbaa-metadata" title="永久链接至标题">¶</a></h4>
<p>In LLVM IR, memory does not have types, so LLVM&#8217;s own type system is not
suitable for doing TBAA. Instead, metadata is added to the IR to
describe a type system of a higher level language. This can be used to
implement typical C/C++ TBAA, but it can also be used to implement
custom alias analysis behavior for other languages.</p>
<p>The current metadata format is very simple. TBAA metadata nodes have up
to three fields, e.g.:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;an example type tree&quot;</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;int&quot;</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;float&quot;</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;const float&quot;</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="k">i64</span> <span class="m">1</span> <span class="p">}</span>
</pre></div>
</div>
<p>The first field is an identity field. It can be any value, usually a
metadata string, which uniquely identifies the type. The most important
name in the tree is the name of the root node. Two trees with different
root node names are entirely disjoint, even if they have leaves with
common names.</p>
<p>The second field identifies the type&#8217;s parent node in the tree, or is
null or omitted for a root node. A type is considered to alias all of
its descendants and all of its ancestors in the tree. Also, a type is
considered to alias all types in other trees, so that bitcode produced
from multiple front-ends is handled conservatively.</p>
<p>If the third field is present, it&#8217;s an integer which if equal to 1
indicates that the type is &#8220;constant&#8221; (meaning
<code class="docutils literal"><span class="pre">pointsToConstantMemory</span></code> should return true; see <a class="reference external" href="AliasAnalysis.html#OtherItfs">other useful
AliasAnalysis methods</a>).</p>
</div>
<div class="section" id="tbaa-struct-metadata">
<h4><a class="toc-backref" href="#id750">&#8216;<code class="docutils literal"><span class="pre">tbaa.struct</span></code>&#8216; Metadata</a><a class="headerlink" href="#tbaa-struct-metadata" title="永久链接至标题">¶</a></h4>
<p>The <a class="reference internal" href="#int-memcpy"><span class="std std-ref">llvm.memcpy</span></a> is often used to implement
aggregate assignment operations in C and similar languages, however it
is defined to copy a contiguous region of memory, which is more than
strictly necessary for aggregate types which contain holes due to
padding. Also, it doesn&#8217;t contain any TBAA information about the fields
of the aggregate.</p>
<p><code class="docutils literal"><span class="pre">!tbaa.struct</span></code> metadata can describe which memory subregions in a
memcpy are padding and what the TBAA tags of the struct are.</p>
<p>The current metadata format is very simple. <code class="docutils literal"><span class="pre">!tbaa.struct</span></code> metadata
nodes are a list of operands which are in conceptual groups of three.
For each group of three, the first operand gives the byte offset of a
field in bytes, the second gives its size in bytes, and the third gives
its tbaa tag. e.g.:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!4</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">4</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="k">i64</span> <span class="m">8</span><span class="p">,</span> <span class="k">i64</span> <span class="m">4</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span> <span class="p">}</span>
</pre></div>
</div>
<p>This describes a struct with two fields. The first is at offset 0 bytes
with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes
and has size 4 bytes and has tbaa tag !2.</p>
<p>Note that the fields need not be contiguous. In this example, there is a
4 byte gap between the two fields. This gap represents padding which
does not carry useful data and need not be preserved.</p>
</div>
<div class="section" id="noalias-and-alias-scope-metadata">
<h4><a class="toc-backref" href="#id751">&#8216;<code class="docutils literal"><span class="pre">noalias</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">alias.scope</span></code>&#8216; Metadata</a><a class="headerlink" href="#noalias-and-alias-scope-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">noalias</span></code> and <code class="docutils literal"><span class="pre">alias.scope</span></code> metadata provide the ability to specify generic
noalias memory-access sets. This means that some collection of memory access
instructions (loads, stores, memory-accessing calls, etc.) that carry
<code class="docutils literal"><span class="pre">noalias</span></code> metadata can specifically be specified not to alias with some other
collection of memory access instructions that carry <code class="docutils literal"><span class="pre">alias.scope</span></code> metadata.
Each type of metadata specifies a list of scopes where each scope has an id and
a domain. When evaluating an aliasing query, if for some domain, the set
of scopes with that domain in one instruction&#8217;s <code class="docutils literal"><span class="pre">alias.scope</span></code> list is a
subset of (or equal to) the set of scopes for that domain in another
instruction&#8217;s <code class="docutils literal"><span class="pre">noalias</span></code> list, then the two memory accesses are assumed not to
alias.</p>
<p>The metadata identifying each domain is itself a list containing one or two
entries. The first entry is the name of the domain. Note that if the name is a
string then it can be combined across functions and translation units. A
self-reference can be used to create globally unique domain names. A
descriptive string may optionally be provided as a second list entry.</p>
<p>The metadata identifying each scope is also itself a list containing two or
three entries. The first entry is the name of the scope. Note that if the name
is a string then it can be combined across functions and translation units. A
self-reference can be used to create globally unique scope names. A metadata
reference to the scope&#8217;s domain is the second entry. A descriptive string may
optionally be provided as a third list entry.</p>
<p>For example,</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Two scope domains:</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span>

<span class="c">; Some scopes in these domains:</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!4</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">}</span>

<span class="c">; Some scope lists:</span>
<span class="nv nv-Anonymous">!5</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">}</span> <span class="c">; A list containing only scope !4</span>
<span class="nv nv-Anonymous">!6</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">}</span>
<span class="nv nv-Anonymous">!7</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!3</span><span class="p">}</span>

<span class="c">; These two instructions don&#39;t alias:</span>
<span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%c</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!alias.scope</span> <span class="nv nv-Anonymous">!5</span>
<span class="k">store</span> <span class="kt">float</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%arrayidx.i</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!noalias</span> <span class="nv nv-Anonymous">!5</span>

<span class="c">; These two instructions also don&#39;t alias (for domain !1, the set of scopes</span>
<span class="c">; in the !alias.scope equals that in the !noalias list):</span>
<span class="nv nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%c</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!alias.scope</span> <span class="nv nv-Anonymous">!5</span>
<span class="k">store</span> <span class="kt">float</span> <span class="nv nv-Anonymous">%2</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%arrayidx.i2</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!noalias</span> <span class="nv nv-Anonymous">!6</span>

<span class="c">; These two instructions may alias (for domain !0, the set of scopes in</span>
<span class="c">; the !noalias list is not a superset of, or equal to, the scopes in the</span>
<span class="c">; !alias.scope list):</span>
<span class="nv nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%c</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!alias.scope</span> <span class="nv nv-Anonymous">!6</span>
<span class="k">store</span> <span class="kt">float</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%arrayidx.i</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!noalias</span> <span class="nv nv-Anonymous">!7</span>
</pre></div>
</div>
</div>
<div class="section" id="fpmath-metadata">
<h4><a class="toc-backref" href="#id752">&#8216;<code class="docutils literal"><span class="pre">fpmath</span></code>&#8216; Metadata</a><a class="headerlink" href="#fpmath-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">fpmath</span></code> metadata may be attached to any instruction of floating point
type. It can be used to express the maximum acceptable error in the
result of that instruction, in ULPs, thus potentially allowing the
compiler to use a more efficient but less accurate method of computing
it. ULP is defined as follows:</p>
<blockquote>
<div>If <code class="docutils literal"><span class="pre">x</span></code> is a real number that lies between two finite consecutive
floating-point numbers <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>, without being equal to one
of them, then <code class="docutils literal"><span class="pre">ulp(x)</span> <span class="pre">=</span> <span class="pre">|b</span> <span class="pre">-</span> <span class="pre">a|</span></code>, otherwise <code class="docutils literal"><span class="pre">ulp(x)</span></code> is the
distance between the two non-equal finite floating-point numbers
nearest <code class="docutils literal"><span class="pre">x</span></code>. Moreover, <code class="docutils literal"><span class="pre">ulp(NaN)</span></code> is <code class="docutils literal"><span class="pre">NaN</span></code>.</div></blockquote>
<p>The metadata node shall consist of a single positive floating point
number representing the maximum relative error, for example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="kt">float</span> <span class="m">2.5</span> <span class="p">}</span> <span class="c">; maximum acceptable inaccuracy is 2.5 ULPs</span>
</pre></div>
</div>
</div>
<div class="section" id="range-metadata">
<span id="id18"></span><h4><a class="toc-backref" href="#id753">&#8216;<code class="docutils literal"><span class="pre">range</span></code>&#8216; Metadata</a><a class="headerlink" href="#range-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">range</span></code> metadata may be attached only to <code class="docutils literal"><span class="pre">load</span></code>, <code class="docutils literal"><span class="pre">call</span></code> and <code class="docutils literal"><span class="pre">invoke</span></code> of
integer types. It expresses the possible ranges the loaded value or the value
returned by the called function at this call site is in. The ranges are
represented with a flattened list of integers. The loaded value or the value
returned is known to be in the union of the ranges defined by each consecutive
pair. Each pair has the following properties:</p>
<ul class="simple">
<li>The type must match the type loaded by the instruction.</li>
<li>The pair <code class="docutils literal"><span class="pre">a,b</span></code> represents the range <code class="docutils literal"><span class="pre">[a,b)</span></code>.</li>
<li>Both <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are constants.</li>
<li>The range is allowed to wrap.</li>
<li>The range should not represent the full or empty set. That is,
<code class="docutils literal"><span class="pre">a!=b</span></code>.</li>
</ul>
<p>In addition, the pairs must be in signed order of the lower bound and
they must be non-contiguous.</p>
<p>Examples:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%a</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%x</span><span class="p">,</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!range</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can only be 0 or 1</span>
  <span class="nv">%b</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%y</span><span class="p">,</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!range</span> <span class="nv nv-Anonymous">!1</span> <span class="c">; Can only be 255 (-1), 0 or 1</span>
  <span class="nv">%c</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span> <span class="vg">@foo</span><span class="p">(),</span>       <span class="nv">!range</span> <span class="nv nv-Anonymous">!2</span> <span class="c">; Can only be 0, 1, 3, 4 or 5</span>
  <span class="nv">%d</span> <span class="p">=</span> <span class="k">invoke</span> <span class="k">i8</span> <span class="vg">@bar</span><span class="p">()</span> <span class="k">to</span> <span class="kt">label</span> <span class="nv">%cont</span>
         <span class="k">unwind</span> <span class="kt">label</span> <span class="nv">%lpad</span><span class="p">,</span> <span class="nv">!range</span> <span class="nv nv-Anonymous">!3</span> <span class="c">; Can only be -2, -1, 3, 4 or 5</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">0</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">255</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">0</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span><span class="p">,</span> <span class="k">i8</span> <span class="m">3</span><span class="p">,</span> <span class="k">i8</span> <span class="m">6</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">-2</span><span class="p">,</span> <span class="k">i8</span> <span class="m">0</span><span class="p">,</span> <span class="k">i8</span> <span class="m">3</span><span class="p">,</span> <span class="k">i8</span> <span class="m">6</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unpredictable-metadata">
<h4><a class="toc-backref" href="#id754">&#8216;<code class="docutils literal"><span class="pre">unpredictable</span></code>&#8216; Metadata</a><a class="headerlink" href="#unpredictable-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">unpredictable</span></code> metadata may be attached to any branch or switch
instruction. It can be used to express the unpredictability of control
flow. Similar to the llvm.expect intrinsic, it may be used to alter
optimizations related to compare and branch instructions. The metadata
is treated as a boolean value; if it exists, it signals that the branch
or switch that it is attached to is completely unpredictable.</p>
</div>
<div class="section" id="llvm-loop">
<h4><a class="toc-backref" href="#id755">&#8216;<code class="docutils literal"><span class="pre">llvm.loop</span></code>&#8216;</a><a class="headerlink" href="#llvm-loop" title="永久链接至标题">¶</a></h4>
<p>It is sometimes useful to attach information to loop constructs. Currently,
loop metadata is implemented as metadata attached to the branch instruction
in the loop latch block. This type of metadata refer to a metadata node that is
guaranteed to be separate for each loop. The loop identifier metadata is
specified with the name <code class="docutils literal"><span class="pre">llvm.loop</span></code>.</p>
<p>The loop identifier metadata is implemented using a metadata that refers to
itself to avoid merging it with any other identifier metadata, e.g.,
during module linkage or function inlining. That is, each loop should refer
to their own identification metadata even if they reside in separate functions.
The following example contains loop identifier metadata for two separate loop
constructs:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span>
</pre></div>
</div>
<p>The loop identifier metadata can be used to specify additional
per-loop metadata. Any operands after the first operand can be treated
as user-defined metadata. For example the <code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code>
suggests an unroll factor to the loop unroller:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%._crit_edge</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%.lr.ph</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!0</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.count&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-vectorize-and-llvm-loop-interleave">
<h4><a class="toc-backref" href="#id756">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code>&#8216;</a><a class="headerlink" href="#llvm-loop-vectorize-and-llvm-loop-interleave" title="永久链接至标题">¶</a></h4>
<p>Metadata prefixed with <code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code> or <code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code> are
used to control per-loop vectorization and interleaving parameters such as
vectorization width and interleave count. These metadata should be used in
conjunction with <code class="docutils literal"><span class="pre">llvm.loop</span></code> loop identification metadata. The
<code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code> and <code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code> metadata are only
optimization hints and the optimizer will only interleave and vectorize loops if
it believes it is safe to do so. The <code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata
which contains information about loop-carried memory dependencies can be helpful
in determining the safety of these transformations.</p>
</div>
<div class="section" id="llvm-loop-interleave-count-metadata">
<h4><a class="toc-backref" href="#id757">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-interleave-count-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests an interleave count to the loop interleaver.
The first operand is the string <code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code> and the
second operand is an integer specifying the interleave count. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.interleave.count&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that setting <code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code> to 1 disables interleaving
multiple iterations of the loop. If <code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code> is set to 0
then the interleave count will be determined automatically.</p>
</div>
<div class="section" id="llvm-loop-vectorize-enable-metadata">
<h4><a class="toc-backref" href="#id758">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.enable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-vectorize-enable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata selectively enables or disables vectorization for the loop. The
first operand is the string <code class="docutils literal"><span class="pre">llvm.loop.vectorize.enable</span></code> and the second operand
is a bit. If the bit operand value is 1 vectorization is enabled. A value of
0 disables vectorization:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.vectorize.enable&quot;</span><span class="p">,</span> <span class="k">i1</span> <span class="m">0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.vectorize.enable&quot;</span><span class="p">,</span> <span class="k">i1</span> <span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-vectorize-width-metadata">
<h4><a class="toc-backref" href="#id759">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-vectorize-width-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata sets the target width of the vectorizer. The first
operand is the string <code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code> and the second
operand is an integer specifying the width. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.vectorize.width&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that setting <code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code> to 1 disables
vectorization of the loop. If <code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code> is set to
0 or if the loop does not have this metadata the width will be
determined automatically.</p>
</div>
<div class="section" id="llvm-loop-unroll">
<h4><a class="toc-backref" href="#id760">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code>&#8216;</a><a class="headerlink" href="#llvm-loop-unroll" title="永久链接至标题">¶</a></h4>
<p>Metadata prefixed with <code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code> are loop unrolling
optimization hints such as the unroll factor. <code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code>
metadata should be used in conjunction with <code class="docutils literal"><span class="pre">llvm.loop</span></code> loop
identification metadata. The <code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code> metadata are only
optimization hints and the unrolling will only be performed if the
optimizer believes it is safe to do so.</p>
</div>
<div class="section" id="llvm-loop-unroll-count-metadata">
<h4><a class="toc-backref" href="#id761">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-count-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests an unroll factor to the loop unroller. The
first operand is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code> and the second
operand is a positive integer specifying the unroll factor. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.count&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
<p>If the trip count of the loop is less than the unroll count the loop
will be partially unrolled.</p>
</div>
<div class="section" id="llvm-loop-unroll-disable-metadata">
<h4><a class="toc-backref" href="#id762">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.disable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-disable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata disables loop unrolling. The metadata has a single operand
which is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.disable</span></code>. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.disable&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-unroll-runtime-disable-metadata">
<h4><a class="toc-backref" href="#id763">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.runtime.disable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-runtime-disable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata disables runtime loop unrolling. The metadata has a single
operand which is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.runtime.disable</span></code>. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.runtime.disable&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-unroll-enable-metadata">
<h4><a class="toc-backref" href="#id764">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.enable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-enable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests that the loop should be fully unrolled if the trip count
is known at compile time and partially unrolled if the trip count is not known
at compile time. The metadata has a single operand which is the string
<code class="docutils literal"><span class="pre">llvm.loop.unroll.enable</span></code>.  For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.enable&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-unroll-full-metadata">
<h4><a class="toc-backref" href="#id765">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.full</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-full-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests that the loop should be unrolled fully. The
metadata has a single operand which is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.full</span></code>.
For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.full&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-mem">
<h4><a class="toc-backref" href="#id766">&#8216;<code class="docutils literal"><span class="pre">llvm.mem</span></code>&#8216;</a><a class="headerlink" href="#llvm-mem" title="永久链接至标题">¶</a></h4>
<p>Metadata types used to annotate memory accesses with information helpful
for optimizations are prefixed with <code class="docutils literal"><span class="pre">llvm.mem</span></code>.</p>
</div>
<div class="section" id="llvm-mem-parallel-loop-access-metadata">
<h4><a class="toc-backref" href="#id767">&#8216;<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-mem-parallel-loop-access-metadata" title="永久链接至标题">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata refers to a loop identifier,
or metadata containing a list of loop identifiers for nested loops.
The metadata is attached to memory accessing instructions and denotes that
no loop carried memory dependence exist between it and other instructions denoted
with the same loop identifier.</p>
<p>Precisely, given two instructions <code class="docutils literal"><span class="pre">m1</span></code> and <code class="docutils literal"><span class="pre">m2</span></code> that both have the
<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata, with <code class="docutils literal"><span class="pre">L1</span></code> and <code class="docutils literal"><span class="pre">L2</span></code> being the
set of loops associated with that metadata, respectively, then there is no loop
carried dependence between <code class="docutils literal"><span class="pre">m1</span></code> and <code class="docutils literal"><span class="pre">m2</span></code> for loops in both <code class="docutils literal"><span class="pre">L1</span></code> and
<code class="docutils literal"><span class="pre">L2</span></code>.</p>
<p>As a special case, if all memory accessing instructions in a loop have
<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata that refers to that loop, then the
loop has no loop carried memory dependences and is considered to be a parallel
loop.</p>
<p>Note that if not all memory access instructions have such metadata referring to
the loop, then the loop is considered not being trivially parallel. Additional
memory dependence analysis is required to make that determination. As a fail
safe mechanism, this causes loops that were originally parallel to be considered
sequential (if optimization passes that are unaware of the parallel semantics
insert new memory instructions into the loop body).</p>
<p>Example of a loop that is considered parallel due to its correct use of
both <code class="docutils literal"><span class="pre">llvm.loop</span></code> and <code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code>
metadata types that refer to the same loop identifier metadata.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">for.body:</span>
  <span class="p">...</span>
  <span class="nv">%val0</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%val0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx1</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%for.end</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%for.body</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!0</span>

<span class="nl">for.end:</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
</pre></div>
</div>
<p>It is also possible to have nested parallel loops. In that case the
memory accesses refer to a list of loop identifier metadata nodes instead of
the loop identifier metadata node directly:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">outer.for.body:</span>
  <span class="p">...</span>
  <span class="nv">%val1</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx3</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!2</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%inner.for.body</span>

<span class="nl">inner.for.body:</span>
  <span class="p">...</span>
  <span class="nv">%val0</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx1</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%val0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx2</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%inner.for.end</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%inner.for.body</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!1</span>

<span class="nl">inner.for.end:</span>
  <span class="p">...</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%val1</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx4</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!2</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%outer.for.end</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%outer.for.body</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!2</span>

<span class="nl">outer.for.end:</span>                                          <span class="c">; preds = %for.body</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">}</span> <span class="c">; a list of loop identifiers</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span> <span class="c">; an identifier for the inner loop</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!2</span><span class="p">}</span> <span class="c">; an identifier for the outer loop</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-bitsets">
<h4><a class="toc-backref" href="#id768">&#8216;<code class="docutils literal"><span class="pre">llvm.bitsets</span></code>&#8216;</a><a class="headerlink" href="#llvm-bitsets" title="永久链接至标题">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">llvm.bitsets</span></code> global metadata is used to implement
<a class="reference internal" href="BitSets.html"><span class="doc">bitsets</span></a>.</p>
</div>
<div class="section" id="invariant-group-metadata">
<h4><a class="toc-backref" href="#id769">&#8216;<code class="docutils literal"><span class="pre">invariant.group</span></code>&#8216; Metadata</a><a class="headerlink" href="#invariant-group-metadata" title="永久链接至标题">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata may be attached to <code class="docutils literal"><span class="pre">load</span></code>/<code class="docutils literal"><span class="pre">store</span></code> instructions.
The existence of the <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata on the instruction tells
the optimizer that every <code class="docutils literal"><span class="pre">load</span></code> and <code class="docutils literal"><span class="pre">store</span></code> to the same pointer operand
within the same invariant group can be assumed to load or store the same
value (but see the <code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code> intrinsic which affects
when two pointers are considered the same).</p>
<p>Examples:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@unknownPtr</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i8</span>
<span class="p">...</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i8</span>
<span class="k">store</span> <span class="k">i8</span> <span class="m">42</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span>
<span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>

<span class="nv">%a</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can assume that value under %ptr didn&#39;t change</span>
<span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%b</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!1</span> <span class="c">; Can&#39;t assume anything, because group changed</span>

<span class="nv">%newPtr</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@getPointer</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%c</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%newPtr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can&#39;t assume anything, because we only have information about %ptr</span>

<span class="nv">%unknownValue</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@unknownPtr</span>
<span class="k">store</span> <span class="k">i8</span> <span class="nv">%unknownValue</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can assume that %unknownValue == 42</span>

<span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%newPtr2</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.invariant.group.barrier</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%d</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%newPtr2</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span>  <span class="c">; Can&#39;t step through invariant.group.barrier to get value of %ptr</span>

<span class="p">...</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@getPointer</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.invariant.group.barrier</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>

<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;magic ptr&quot;</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;other ptr&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="module-flags-metadata">
<h2><a class="toc-backref" href="#id770">Module Flags Metadata</a><a class="headerlink" href="#module-flags-metadata" title="永久链接至标题">¶</a></h2>
<p>Information about the module as a whole is difficult to convey to LLVM&#8217;s
subsystems. The LLVM IR isn&#8217;t sufficient to transmit this information.
The <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> named metadata exists in order to facilitate
this. These flags are in the form of key / value pairs &#8212; much like a
dictionary &#8212; making it easy for any subsystem who cares about a flag to
look it up.</p>
<p>The <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> metadata contains a list of metadata triplets.
Each triplet has the following form:</p>
<ul class="simple">
<li>The first element is a <em>behavior</em> flag, which specifies the behavior
when two (or more) modules are merged together, and it encounters two
(or more) metadata with the same ID. The supported behaviors are
described below.</li>
<li>The second element is a metadata string that is a unique ID for the
metadata. Each module may only have one flag entry for each unique ID (not
including entries with the <strong>Require</strong> behavior).</li>
<li>The third element is the value of the flag.</li>
</ul>
<p>When two (or more) modules are merged together, the resulting
<code class="docutils literal"><span class="pre">llvm.module.flags</span></code> metadata is the union of the modules&#8217; flags. That is, for
each unique metadata ID string, there will be exactly one entry in the merged
modules <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> metadata table, and the value for that entry will
be determined by the merge behavior flag, as described below. The only exception
is that entries with the <em>Require</em> behavior are always preserved.</p>
<p>The following behaviors are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Behavior</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td><dl class="first last docutils">
<dt><strong>Error</strong></dt>
<dd>Emits an error if two values disagree, otherwise the resulting value
is that of the operands.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td><dl class="first last docutils">
<dt><strong>Warning</strong></dt>
<dd>Emits a warning if two values disagree. The result value will be the
operand for the flag from the first module being linked.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td><dl class="first last docutils">
<dt><strong>Require</strong></dt>
<dd>Adds a requirement that another module flag be present and have a
specified value after linking is performed. The value must be a
metadata pair, where the first element of the pair is the ID of the
module flag to be restricted, and the second element of the pair is
the value the module flag should be restricted to. This behavior can
be used to restrict the allowable results (via triggering of an
error) of linking IDs with the <strong>Override</strong> behavior.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>4</td>
<td><dl class="first last docutils">
<dt><strong>Override</strong></dt>
<dd>Uses the specified value, regardless of the behavior or value of the
other module. If both modules specify <strong>Override</strong>, but the values
differ, an error will be emitted.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>5</td>
<td><dl class="first last docutils">
<dt><strong>Append</strong></dt>
<dd>Appends the two values, which are required to be metadata nodes.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>6</td>
<td><dl class="first last docutils">
<dt><strong>AppendUnique</strong></dt>
<dd>Appends the two values, which are required to be metadata
nodes. However, duplicate entries in the second list are dropped
during the append operation.</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>It is an error for a particular unique flag ID to have multiple behaviors,
except in the case of <strong>Require</strong> (which adds restrictions on another metadata
value) or <strong>Override</strong>.</p>
<p>An example of module flags:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!&quot;foo&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!&quot;bar&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">37</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="nv">!&quot;qux&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">42</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="nv">!&quot;qux&quot;</span><span class="p">,</span>
  <span class="p">!{</span>
    <span class="nv">!&quot;foo&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nv">!llvm.module.flags</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nv nv-Anonymous">!3</span> <span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!0</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;foo&quot;</span></code> and the value &#8216;1&#8217;. The behavior
if two or more <code class="docutils literal"><span class="pre">!&quot;foo&quot;</span></code> flags are seen is to emit an error if their
values are not equal.</p>
</li>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!1</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;bar&quot;</span></code> and the value &#8216;37&#8217;. The
behavior if two or more <code class="docutils literal"><span class="pre">!&quot;bar&quot;</span></code> flags are seen is to use the value
&#8216;37&#8217;.</p>
</li>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!2</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;qux&quot;</span></code> and the value &#8216;42&#8217;. The
behavior if two or more <code class="docutils literal"><span class="pre">!&quot;qux&quot;</span></code> flags are seen is to emit a
warning if their values are not equal.</p>
</li>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!3</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;qux&quot;</span></code> and the value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>!{ !&quot;foo&quot;, i32 1 }
</pre></div>
</div>
<p>The behavior is to emit an error if the <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> does not
contain a flag with the ID <code class="docutils literal"><span class="pre">!&quot;foo&quot;</span></code> that has the value &#8216;1&#8217; after linking is
performed.</p>
</li>
</ul>
<div class="section" id="objective-c-garbage-collection-module-flags-metadata">
<h3><a class="toc-backref" href="#id771">Objective-C Garbage Collection Module Flags Metadata</a><a class="headerlink" href="#objective-c-garbage-collection-module-flags-metadata" title="永久链接至标题">¶</a></h3>
<p>On the Mach-O platform, Objective-C stores metadata about garbage
collection in a special section called &#8220;image info&#8221;. The metadata
consists of a version number and a bitmask specifying what types of
garbage collection are supported (if any) by the file. If two or more
modules are linked together their garbage collection metadata needs to
be merged rather than appended together.</p>
<p>The Objective-C garbage collection module flags metadata consists of the
following key-value pairs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Version</span></code></td>
<td><strong>[Required]</strong> &#8212; The Objective-C ABI version. Valid values are 1 and 2.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Image</span> <span class="pre">Info</span> <span class="pre">Version</span></code></td>
<td><strong>[Required]</strong> &#8212; The version of the image info section. Currently
always 0.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Image</span> <span class="pre">Info</span> <span class="pre">Section</span></code></td>
<td><strong>[Required]</strong> &#8212; The section to place the metadata. Valid values are
<code class="docutils literal"><span class="pre">&quot;__OBJC,</span> <span class="pre">__image_info,</span> <span class="pre">regular&quot;</span></code> for Objective-C ABI version 1, and
<code class="docutils literal"><span class="pre">&quot;__DATA,__objc_imageinfo,</span> <span class="pre">regular,</span> <span class="pre">no_dead_strip&quot;</span></code> for
Objective-C ABI version 2.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code></td>
<td><strong>[Required]</strong> &#8212; Specifies whether garbage collection is supported or
not. Valid values are 0, for no garbage collection, and 2, for garbage
collection supported.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">GC</span> <span class="pre">Only</span></code></td>
<td><strong>[Optional]</strong> &#8212; Specifies that only garbage collection is supported.
If present, its value must be 6. This flag requires that the
<code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> flag have the value 2.</td>
</tr>
</tbody>
</table>
<p>Some important flag interactions:</p>
<ul class="simple">
<li>If a module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> set to 0 is
merged with a module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> set to
2, then the resulting module has the
<code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> flag set to 0.</li>
<li>A module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> set to 0 cannot be
merged with a module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">GC</span> <span class="pre">Only</span></code> set to 6.</li>
</ul>
</div>
<div class="section" id="automatic-linker-flags-module-flags-metadata">
<h3><a class="toc-backref" href="#id772">Automatic Linker Flags Module Flags Metadata</a><a class="headerlink" href="#automatic-linker-flags-module-flags-metadata" title="永久链接至标题">¶</a></h3>
<p>Some targets support embedding flags to the linker inside individual object
files. Typically this is used in conjunction with language extensions which
allow source files to explicitly declare the libraries they depend on, and have
these automatically be transmitted to the linker via object files.</p>
<p>These flags are encoded in the IR using metadata in the module flags section,
using the <code class="docutils literal"><span class="pre">Linker</span> <span class="pre">Options</span></code> key. The merge behavior for this flag is required
to be <code class="docutils literal"><span class="pre">AppendUnique</span></code>, and the value for the key is expected to be a metadata
node which should be a list of other metadata nodes, each of which should be a
list of metadata strings defining linker options.</p>
<p>For example, the following metadata section specifies two separate sets of
linker options, presumably to link against <code class="docutils literal"><span class="pre">libz</span></code> and the <code class="docutils literal"><span class="pre">Cocoa</span></code>
framework:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>!0 = !{ i32 6, !&quot;Linker Options&quot;,
   !{
      !{ !&quot;-lz&quot; },
      !{ !&quot;-framework&quot;, !&quot;Cocoa&quot; } } }
!llvm.module.flags = !{ !0 }
</pre></div>
</div>
<p>The metadata encoding as lists of lists of options, as opposed to a collapsed
list of options, is chosen so that the IR encoding can use multiple option
strings to specify e.g., a single library, while still having that specifier be
preserved as an atomic element that can be recognized by a target specific
assembly writer or object file emitter.</p>
<p>Each individual option is required to be either a valid option for the target&#8217;s
linker, or an option that is reserved by the target specific assembly writer or
object file emitter. No other aspect of these options is defined by the IR.</p>
</div>
<div class="section" id="c-type-width-module-flags-metadata">
<h3><a class="toc-backref" href="#id773">C type width Module Flags Metadata</a><a class="headerlink" href="#c-type-width-module-flags-metadata" title="永久链接至标题">¶</a></h3>
<p>The ARM backend emits a section into each generated object file describing the
options that it was compiled with (in a compiler-independent way) to prevent
linking incompatible objects, and to allow automatic library selection. Some
of these options are not visible at the IR level, namely wchar_t width and enum
width.</p>
<p>To pass this information to the backend, these options are encoded in module
flags metadata, using the following key-value pairs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>short_wchar</td>
<td><ul class="first last simple">
<li>0 &#8212; sizeof(wchar_t) == 4</li>
<li>1 &#8212; sizeof(wchar_t) == 2</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>short_enum</td>
<td><ul class="first last simple">
<li>0 &#8212; Enums are at least as large as an <code class="docutils literal"><span class="pre">int</span></code>.</li>
<li>1 &#8212; Enums are stored in the smallest integer type which can
represent all of its values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For example, the following metadata section specifies that the module was
compiled with a <code class="docutils literal"><span class="pre">wchar_t</span></code> width of 4 bytes, and the underlying type of an
enum is the smallest type which can represent all of its values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>!llvm.module.flags = !{!0, !1}
!0 = !{i32 1, !&quot;short_wchar&quot;, i32 1}
!1 = !{i32 1, !&quot;short_enum&quot;, i32 0}
</pre></div>
</div>
</div>
</div>
<div class="section" id="intrinsic-global-variables">
<span id="intrinsicglobalvariables"></span><h2><a class="toc-backref" href="#id774">Intrinsic Global Variables</a><a class="headerlink" href="#intrinsic-global-variables" title="永久链接至标题">¶</a></h2>
<p>LLVM has a number of &#8220;magic&#8221; global variables that contain data that
affect code generation or other IR semantics. These are documented here.
All globals of this sort should have a section specified as
&#8220;<code class="docutils literal"><span class="pre">llvm.metadata</span></code>&#8221;. This section and all globals that start with
&#8220;<code class="docutils literal"><span class="pre">llvm.</span></code>&#8221; are reserved for use by LLVM.</p>
<div class="section" id="the-llvm-used-global-variable">
<span id="gv-llvmused"></span><h3><a class="toc-backref" href="#id775">The &#8216;<code class="docutils literal"><span class="pre">llvm.used</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-used-global-variable" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> global is an array which has
<a class="reference internal" href="#linkage-appending"><span class="std std-ref">appending linkage</span></a>. This array contains a list of
pointers to named global variables, functions and aliases which may optionally
have a pointer cast formed of bitcast or getelementptr. For example, a legal
use of it is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@X</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i8</span> <span class="m">4</span>
<span class="vg">@Y</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">123</span>

<span class="vg">@llvm.used</span> <span class="p">=</span> <span class="k">appending</span> <span class="k">global</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*]</span> <span class="p">[</span>
   <span class="k">i8</span><span class="p">*</span> <span class="vg">@X</span><span class="p">,</span>
   <span class="k">i8</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">(</span><span class="k">i32</span><span class="p">*</span> <span class="vg">@Y</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*)</span>
<span class="p">],</span> <span class="k">section</span> <span class="s">&quot;llvm.metadata&quot;</span>
</pre></div>
</div>
<p>If a symbol appears in the <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> list, then the compiler, assembler,
and linker are required to treat the symbol as if there is a reference to the
symbol that it cannot see (which is why they have to be named). For example, if
a variable has internal linkage and no references other than that from the
<code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> list, it cannot be deleted. This is commonly used to represent
references from inline asms and other things the compiler cannot &#8220;see&#8221;, and
corresponds to &#8220;<code class="docutils literal"><span class="pre">attribute((used))</span></code>&#8221; in GNU C.</p>
<p>On some targets, the code generator must emit a directive to the
assembler or object file to prevent the assembler and linker from
molesting the symbol.</p>
</div>
<div class="section" id="the-llvm-compiler-used-global-variable">
<span id="gv-llvmcompilerused"></span><h3><a class="toc-backref" href="#id776">The &#8216;<code class="docutils literal"><span class="pre">llvm.compiler.used</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-compiler-used-global-variable" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.compiler.used</span></code> directive is the same as the <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code>
directive, except that it only prevents the compiler from touching the
symbol. On targets that support it, this allows an intelligent linker to
optimize references to the symbol without being impeded as it would be
by <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code>.</p>
<p>This is a rare construct that should only be used in rare circumstances,
and should not be exposed to source languages.</p>
</div>
<div class="section" id="the-llvm-global-ctors-global-variable">
<span id="gv-llvmglobalctors"></span><h3><a class="toc-backref" href="#id777">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_ctors</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-global-ctors-global-variable" title="永久链接至标题">¶</a></h3>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*,</span> <span class="k">i8</span><span class="p">*</span> <span class="p">}</span>
<span class="vg">@llvm.global_ctors</span> <span class="p">=</span> <span class="k">appending</span> <span class="k">global</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="nv nv-Anonymous">%0</span><span class="p">]</span> <span class="p">[</span><span class="nv nv-Anonymous">%0</span> <span class="p">{</span> <span class="k">i32</span> <span class="m">65535</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*</span> <span class="vg">@ctor</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@data</span> <span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.global_ctors</span></code> array contains a list of constructor
functions, priorities, and an optional associated global or function.
The functions referenced by this array will be called in ascending order
of priority (i.e. lowest first) when the module is loaded. The order of
functions with the same priority is not defined.</p>
<p>If the third field is present, non-null, and points to a global variable
or function, the initializer function will only run if the associated
data from the current module is not discarded.</p>
</div>
<div class="section" id="the-llvm-global-dtors-global-variable">
<span id="llvmglobaldtors"></span><h3><a class="toc-backref" href="#id778">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_dtors</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-global-dtors-global-variable" title="永久链接至标题">¶</a></h3>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*,</span> <span class="k">i8</span><span class="p">*</span> <span class="p">}</span>
<span class="vg">@llvm.global_dtors</span> <span class="p">=</span> <span class="k">appending</span> <span class="k">global</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="nv nv-Anonymous">%0</span><span class="p">]</span> <span class="p">[</span><span class="nv nv-Anonymous">%0</span> <span class="p">{</span> <span class="k">i32</span> <span class="m">65535</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*</span> <span class="vg">@dtor</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@data</span> <span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.global_dtors</span></code> array contains a list of destructor
functions, priorities, and an optional associated global or function.
The functions referenced by this array will be called in descending
order of priority (i.e. highest first) when the module is unloaded. The
order of functions with the same priority is not defined.</p>
<p>If the third field is present, non-null, and points to a global variable
or function, the destructor function will only run if the associated
data from the current module is not discarded.</p>
</div>
</div>
<div class="section" id="instruction-reference">
<h2><a class="toc-backref" href="#id779">Instruction Reference</a><a class="headerlink" href="#instruction-reference" title="永久链接至标题">¶</a></h2>
<p>The LLVM instruction set consists of several different classifications
of instructions: <a class="reference internal" href="#terminators"><span class="std std-ref">terminator instructions</span></a>, <a class="reference internal" href="#binaryops"><span class="std std-ref">binary
instructions</span></a>, <a class="reference internal" href="#bitwiseops"><span class="std std-ref">bitwise binary
instructions</span></a>, <a class="reference internal" href="#memoryops"><span class="std std-ref">memory instructions</span></a>, and
<a class="reference internal" href="#otherops"><span class="std std-ref">other instructions</span></a>.</p>
<div class="section" id="terminator-instructions">
<span id="terminators"></span><h3><a class="toc-backref" href="#id780">Terminator Instructions</a><a class="headerlink" href="#terminator-instructions" title="永久链接至标题">¶</a></h3>
<p>As mentioned <a class="reference internal" href="#functionstructure"><span class="std std-ref">previously</span></a>, every basic block in a
program ends with a &#8220;Terminator&#8221; instruction, which indicates which
block should be executed after the current block is finished. These
terminator instructions typically yield a &#8216;<code class="docutils literal"><span class="pre">void</span></code>&#8216; value: they produce
control flow, not values (the one exception being the
&#8216;<a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>&#8216; instruction).</p>
<p>The terminator instructions are: &#8216;<a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-br"><span class="std std-ref">br</span></a>&#8216;, &#8216;<a class="reference internal" href="#i-switch"><span class="std std-ref">switch</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-indirectbr"><span class="std std-ref">indirectbr</span></a>&#8216;, &#8216;<a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a>&#8216;, &#8216;<a class="reference internal" href="#i-catchswitch"><span class="std std-ref">catchswitch</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-catchret"><span class="std std-ref">catchret</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-cleanupret"><span class="std std-ref">cleanupret</span></a>&#8216;,
and &#8216;<a class="reference internal" href="#i-unreachable"><span class="std std-ref">unreachable</span></a>&#8216;.</p>
<div class="section" id="ret-instruction">
<span id="i-ret"></span><h4><a class="toc-backref" href="#id781">&#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; Instruction</a><a class="headerlink" href="#ret-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="syntax">
<h5><a class="toc-backref" href="#id782">Syntax:</a><a class="headerlink" href="#syntax" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">Return</span> <span class="n">a</span> <span class="n">value</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">non</span><span class="o">-</span><span class="n">void</span> <span class="n">function</span>
<span class="n">ret</span> <span class="n">void</span>                 <span class="p">;</span> <span class="n">Return</span> <span class="kn">from</span> <span class="nn">void</span> <span class="n">function</span>
</pre></div>
</div>
</div>
<div class="section" id="overview">
<h5><a class="toc-backref" href="#id783">Overview:</a><a class="headerlink" href="#overview" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction is used to return control flow (and optionally
a value) from a function back to the caller.</p>
<p>There are two forms of the &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction: one that returns a
value and then causes control flow, and one that just causes control
flow to occur.</p>
</div>
<div class="section" id="arguments">
<h5><a class="toc-backref" href="#id784">Arguments:</a><a class="headerlink" href="#arguments" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction optionally accepts a single argument, the
return value. The type of the return value must be a &#8216;<a class="reference internal" href="#t-firstclass"><span class="std std-ref">first
class</span></a>&#8216; type.</p>
<p>A function is not <a class="reference internal" href="#wellformed"><span class="std std-ref">well formed</span></a> if it it has a non-void
return type and contains a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction with no return value or
a return value with a type that does not match its type, or if it has a
void return type and contains a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction with a return
value.</p>
</div>
<div class="section" id="semantics">
<h5><a class="toc-backref" href="#id785">Semantics:</a><a class="headerlink" href="#semantics" title="永久链接至标题">¶</a></h5>
<p>When the &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction is executed, control flow returns back to
the calling function&#8217;s context. If the caller is a
&#8220;<a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a>&#8221; instruction, execution continues at the
instruction after the call. If the caller was an
&#8220;<a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>&#8221; instruction, execution continues at the
beginning of the &#8220;normal&#8221; destination block. If the instruction returns
a value, that value shall set the call or invoke instruction&#8217;s return
value.</p>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id786">Example:</a><a class="headerlink" href="#example" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">ret</span> <span class="k">i32</span> <span class="m">5</span>                       <span class="c">; Return an integer value of 5</span>
<span class="k">ret</span> <span class="kt">void</span>                        <span class="c">; Return from a void function</span>
<span class="k">ret</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i8</span> <span class="p">}</span> <span class="p">{</span> <span class="k">i32</span> <span class="m">4</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span> <span class="p">}</span> <span class="c">; Return a struct of values 4 and 2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="br-instruction">
<span id="i-br"></span><h4><a class="toc-backref" href="#id787">&#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; Instruction</a><a class="headerlink" href="#br-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id19">
<h5><a class="toc-backref" href="#id788">Syntax:</a><a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">br</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">iftrue</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">iffalse</span><span class="o">&gt;</span>
<span class="n">br</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">Unconditional</span> <span class="n">branch</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h5><a class="toc-backref" href="#id789">Overview:</a><a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction is used to cause control flow to transfer to a
different basic block in the current function. There are two forms of
this instruction, corresponding to a conditional branch and an
unconditional branch.</p>
</div>
<div class="section" id="id21">
<h5><a class="toc-backref" href="#id790">Arguments:</a><a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h5>
<p>The conditional branch form of the &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction takes a single
&#8216;<code class="docutils literal"><span class="pre">i1</span></code>&#8216; value and two &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216; values. The unconditional form of the
&#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction takes a single &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216; value as a target.</p>
</div>
<div class="section" id="id22">
<h5><a class="toc-backref" href="#id791">Semantics:</a><a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h5>
<p>Upon execution of a conditional &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction, the &#8216;<code class="docutils literal"><span class="pre">i1</span></code>&#8216;
argument is evaluated. If the value is <code class="docutils literal"><span class="pre">true</span></code>, control flows to the
&#8216;<code class="docutils literal"><span class="pre">iftrue</span></code>&#8216; <code class="docutils literal"><span class="pre">label</span></code> argument. If &#8220;cond&#8221; is <code class="docutils literal"><span class="pre">false</span></code>, control flows
to the &#8216;<code class="docutils literal"><span class="pre">iffalse</span></code>&#8216; <code class="docutils literal"><span class="pre">label</span></code> argument.</p>
</div>
<div class="section" id="id23">
<h5><a class="toc-backref" href="#id792">Example:</a><a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">Test:</span>
  <span class="nv">%cond</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%IfEqual</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%IfUnequal</span>
<span class="nl">IfEqual:</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">1</span>
<span class="nl">IfUnequal:</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="switch-instruction">
<span id="i-switch"></span><h4><a class="toc-backref" href="#id793">&#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; Instruction</a><a class="headerlink" href="#switch-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id24">
<h5><a class="toc-backref" href="#id794">Syntax:</a><a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">switch</span> <span class="o">&lt;</span><span class="n">intty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">defaultdest</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">intty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h5><a class="toc-backref" href="#id795">Overview:</a><a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; instruction is used to transfer control flow to one of
several different places. It is a generalization of the &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216;
instruction, allowing a branch to occur to one of many possible
destinations.</p>
</div>
<div class="section" id="id26">
<h5><a class="toc-backref" href="#id796">Arguments:</a><a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; instruction uses three parameters: an integer
comparison value &#8216;<code class="docutils literal"><span class="pre">value</span></code>&#8216;, a default &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216; destination, and an
array of pairs of comparison value constants and &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216;s. The table
is not allowed to contain duplicate constant entries.</p>
</div>
<div class="section" id="id27">
<h5><a class="toc-backref" href="#id797">Semantics:</a><a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">switch</span></code> instruction specifies a table of values and destinations.
When the &#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; instruction is executed, this table is searched
for the given value. If the value is found, control flow is transferred
to the corresponding destination; otherwise, control flow is transferred
to the default destination.</p>
</div>
<div class="section" id="implementation">
<h5><a class="toc-backref" href="#id798">Implementation:</a><a class="headerlink" href="#implementation" title="永久链接至标题">¶</a></h5>
<p>Depending on properties of the target machine and the particular
<code class="docutils literal"><span class="pre">switch</span></code> instruction, this instruction may be code generated in
different ways. For example, it could be generated as a series of
chained conditional branches or with a lookup table.</p>
</div>
<div class="section" id="id28">
<h5><a class="toc-backref" href="#id799">Example:</a><a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Emulate a conditional br instruction</span>
<span class="nv">%Val</span> <span class="p">=</span> <span class="k">zext</span> <span class="k">i1</span> <span class="nv">%value</span> <span class="k">to</span> <span class="k">i32</span>
<span class="k">switch</span> <span class="k">i32</span> <span class="nv">%Val</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%truedest</span> <span class="p">[</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%falsedest</span> <span class="p">]</span>

<span class="c">; Emulate an unconditional br instruction</span>
<span class="k">switch</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%dest</span> <span class="p">[</span> <span class="p">]</span>

<span class="c">; Implement a jump table:</span>
<span class="k">switch</span> <span class="k">i32</span> <span class="nv">%val</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%otherwise</span> <span class="p">[</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%onzero</span>
                                    <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%onone</span>
                                    <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%ontwo</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="indirectbr-instruction">
<span id="i-indirectbr"></span><h4><a class="toc-backref" href="#id800">&#8216;<code class="docutils literal"><span class="pre">indirectbr</span></code>&#8216; Instruction</a><a class="headerlink" href="#indirectbr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id29">
<h5><a class="toc-backref" href="#id801">Syntax:</a><a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">indirectbr</span> <span class="o">&lt;</span><span class="n">somety</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">[</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h5><a class="toc-backref" href="#id802">Overview:</a><a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">indirectbr</span></code>&#8216; instruction implements an indirect branch to a
label within the current function, whose address is specified by
&#8220;<code class="docutils literal"><span class="pre">address</span></code>&#8221;. Address must be derived from a
<a class="reference internal" href="#blockaddress"><span class="std std-ref">blockaddress</span></a> constant.</p>
</div>
<div class="section" id="id31">
<h5><a class="toc-backref" href="#id803">Arguments:</a><a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">address</span></code>&#8216; argument is the address of the label to jump to. The
rest of the arguments indicate the full set of possible destinations
that the address may point to. Blocks are allowed to occur multiple
times in the destination list, though this isn&#8217;t particularly useful.</p>
<p>This destination list is required so that dataflow analysis has an
accurate understanding of the CFG.</p>
</div>
<div class="section" id="id32">
<h5><a class="toc-backref" href="#id804">Semantics:</a><a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h5>
<p>Control transfers to the block specified in the address argument. All
possible destination blocks must be listed in the label list, otherwise
this instruction has undefined behavior. This implies that jumps to
labels defined in other functions have undefined behavior as well.</p>
</div>
<div class="section" id="id33">
<h5><a class="toc-backref" href="#id805">Implementation:</a><a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h5>
<p>This is typically implemented with a jump through a register.</p>
</div>
<div class="section" id="id34">
<h5><a class="toc-backref" href="#id806">Example:</a><a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">indirectbr</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%Addr</span><span class="p">,</span> <span class="p">[</span> <span class="kt">label</span> <span class="nv">%bb1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb2</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb3</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="invoke-instruction">
<span id="i-invoke"></span><h4><a class="toc-backref" href="#id807">&#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; Instruction</a><a class="headerlink" href="#invoke-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id35">
<h5><a class="toc-backref" href="#id808">Syntax:</a><a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">invoke</span> <span class="p">[</span><span class="n">cconv</span><span class="p">]</span> <span class="p">[</span><span class="n">ret</span> <span class="n">attrs</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ptr</span> <span class="n">to</span> <span class="n">function</span> <span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">ptr</span> <span class="n">val</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">function</span> <span class="n">args</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">[</span><span class="n">fn</span> <span class="n">attrs</span><span class="p">]</span>
              <span class="p">[</span><span class="n">operand</span> <span class="n">bundles</span><span class="p">]</span> <span class="n">to</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">normal</span> <span class="n">label</span><span class="o">&gt;</span> <span class="n">unwind</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">exception</span> <span class="n">label</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h5><a class="toc-backref" href="#id809">Overview:</a><a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; instruction causes control to transfer to a specified
function, with the possibility of control flow transfer to either the
&#8216;<code class="docutils literal"><span class="pre">normal</span></code>&#8216; label or the &#8216;<code class="docutils literal"><span class="pre">exception</span></code>&#8216; label. If the callee function
returns with the &#8220;<code class="docutils literal"><span class="pre">ret</span></code>&#8221; instruction, control flow will return to the
&#8220;normal&#8221; label. If the callee (or any indirect callees) returns via the
&#8220;<a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a>&#8221; instruction or other exception handling
mechanism, control is interrupted and continued at the dynamically
nearest &#8220;exception&#8221; label.</p>
<p>The &#8216;<code class="docutils literal"><span class="pre">exception</span></code>&#8216; label is a <a class="reference external" href="ExceptionHandling.html#overview">landing
pad</a> for the exception. As such,
&#8216;<code class="docutils literal"><span class="pre">exception</span></code>&#8216; label is required to have the
&#8220;<a class="reference internal" href="#i-landingpad"><span class="std std-ref">landingpad</span></a>&#8221; instruction, which contains the
information about the behavior of the program after unwinding happens,
as its first non-PHI instruction. The restrictions on the
&#8220;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8221; instruction&#8217;s tightly couples it to the &#8220;<code class="docutils literal"><span class="pre">invoke</span></code>&#8221;
instruction, so that the important information contained within the
&#8220;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8221; instruction can&#8217;t be lost through normal code motion.</p>
</div>
<div class="section" id="id37">
<h5><a class="toc-backref" href="#id810">Arguments:</a><a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h5>
<p>This instruction requires several arguments:</p>
<ol class="arabic simple">
<li>The optional &#8220;cconv&#8221; marker indicates which <a class="reference internal" href="#callingconv"><span class="std std-ref">calling
convention</span></a> the call should use. If none is
specified, the call defaults to using C calling conventions.</li>
<li>The optional <a class="reference internal" href="#paramattrs"><span class="std std-ref">Parameter Attributes</span></a> list for return
values. Only &#8216;<code class="docutils literal"><span class="pre">zeroext</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">signext</span></code>&#8216;, and &#8216;<code class="docutils literal"><span class="pre">inreg</span></code>&#8216; attributes
are valid here.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">ptr</span> <span class="pre">to</span> <span class="pre">function</span> <span class="pre">ty</span></code>&#8216;: shall be the signature of the pointer to
function value being invoked. In most cases, this is a direct
function invocation, but indirect <code class="docutils literal"><span class="pre">invoke</span></code>&#8216;s are just as possible,
branching off an arbitrary pointer to function value.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">function</span> <span class="pre">ptr</span> <span class="pre">val</span></code>&#8216;: An LLVM value containing a pointer to a
function to be invoked.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">function</span> <span class="pre">args</span></code>&#8216;: argument list whose types match the function
signature argument types and parameter attributes. All arguments must
be of <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type. If the function signature
indicates the function accepts a variable number of arguments, the
extra arguments can be specified.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">normal</span> <span class="pre">label</span></code>&#8216;: the label reached when the called function
executes a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">exception</span> <span class="pre">label</span></code>&#8216;: the label reached when a callee returns via
the <a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a> instruction or other exception handling
mechanism.</li>
<li>The optional <a class="reference internal" href="#fnattrs"><span class="std std-ref">function attributes</span></a> list. Only
&#8216;<code class="docutils literal"><span class="pre">noreturn</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">nounwind</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">readonly</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">readnone</span></code>&#8216;
attributes are valid here.</li>
<li>The optional <a class="reference internal" href="#opbundles"><span class="std std-ref">operand bundles</span></a> list.</li>
</ol>
</div>
<div class="section" id="id38">
<h5><a class="toc-backref" href="#id811">Semantics:</a><a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h5>
<p>This instruction is designed to operate as a standard &#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216;
instruction in most regards. The primary difference is that it
establishes an association with a label, which is used by the runtime
library to unwind the stack.</p>
<p>This instruction is used in languages with destructors to ensure that
proper cleanup is performed in the case of either a <code class="docutils literal"><span class="pre">longjmp</span></code> or a
thrown exception. Additionally, this is important for implementation of
&#8216;<code class="docutils literal"><span class="pre">catch</span></code>&#8216; clauses in high-level languages that support them.</p>
<p>For the purposes of the SSA form, the definition of the value returned
by the &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; instruction is deemed to occur on the edge from the
current block to the &#8220;normal&#8221; label. If the callee unwinds then no
return value is available.</p>
</div>
<div class="section" id="id39">
<h5><a class="toc-backref" href="#id812">Example:</a><a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%retval</span> <span class="p">=</span> <span class="k">invoke</span> <span class="k">i32</span> <span class="vg">@Test</span><span class="p">(</span><span class="k">i32</span> <span class="m">15</span><span class="p">)</span> <span class="k">to</span> <span class="kt">label</span> <span class="nv">%Continue</span>
            <span class="k">unwind</span> <span class="kt">label</span> <span class="nv">%TestCleanup</span>              <span class="c">; i32:retval set</span>
<span class="nv">%retval</span> <span class="p">=</span> <span class="k">invoke</span> <span class="k">coldcc</span> <span class="k">i32</span> <span class="nv">%Testfnptr</span><span class="p">(</span><span class="k">i32</span> <span class="m">15</span><span class="p">)</span> <span class="k">to</span> <span class="kt">label</span> <span class="nv">%Continue</span>
            <span class="k">unwind</span> <span class="kt">label</span> <span class="nv">%TestCleanup</span>              <span class="c">; i32:retval set</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="resume-instruction">
<span id="i-resume"></span><h4><a class="toc-backref" href="#id813">&#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; Instruction</a><a class="headerlink" href="#resume-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id40">
<h5><a class="toc-backref" href="#id814">Syntax:</a><a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">resume</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h5><a class="toc-backref" href="#id815">Overview:</a><a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; instruction is a terminator instruction that has no
successors.</p>
</div>
<div class="section" id="id42">
<h5><a class="toc-backref" href="#id816">Arguments:</a><a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; instruction requires one argument, which must have the
same type as the result of any &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction in the same
function.</p>
</div>
<div class="section" id="id43">
<h5><a class="toc-backref" href="#id817">Semantics:</a><a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; instruction resumes propagation of an existing
(in-flight) exception whose unwinding was interrupted with a
<a class="reference internal" href="#i-landingpad"><span class="std std-ref">landingpad</span></a> instruction.</p>
</div>
<div class="section" id="id44">
<h5><a class="toc-backref" href="#id818">Example:</a><a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">resume</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span> <span class="nv">%exn</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="catchswitch-instruction">
<span id="i-catchswitch"></span><h4><a class="toc-backref" href="#id819">&#8216;<code class="docutils literal"><span class="pre">catchswitch</span></code>&#8216; Instruction</a><a class="headerlink" href="#catchswitch-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id45">
<h5><a class="toc-backref" href="#id820">Syntax:</a><a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">catchswitch</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="n">unwind</span> <span class="n">to</span> <span class="n">caller</span>
<span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">catchswitch</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="n">unwind</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">default</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id46">
<h5><a class="toc-backref" href="#id821">Overview:</a><a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchswitch</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling system</a> to describe the set of possible catch handlers
that may be executed by the <a class="reference internal" href="#personalityfn"><span class="std std-ref">EH personality routine</span></a>.</p>
</div>
<div class="section" id="id47">
<h5><a class="toc-backref" href="#id822">Arguments:</a><a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">parent</span></code> argument is the token of the funclet that contains the
<code class="docutils literal"><span class="pre">catchswitch</span></code> instruction. If the <code class="docutils literal"><span class="pre">catchswitch</span></code> is not inside a funclet,
this operand may be the token <code class="docutils literal"><span class="pre">none</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">default</span></code> argument is the label of another basic block beginning with
either a <code class="docutils literal"><span class="pre">cleanuppad</span></code> or <code class="docutils literal"><span class="pre">catchswitch</span></code> instruction.  This unwind destination
must be a legal target with respect to the <code class="docutils literal"><span class="pre">parent</span></code> links, as described in
the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">exception handling documentation</a>.</p>
<p>The <code class="docutils literal"><span class="pre">handlers</span></code> are a nonempty list of successor blocks that each begin with a
<a class="reference internal" href="#i-catchpad"><span class="std std-ref">catchpad</span></a> instruction.</p>
</div>
<div class="section" id="id48">
<h5><a class="toc-backref" href="#id823">Semantics:</a><a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h5>
<p>Executing this instruction transfers control to one of the successors in
<code class="docutils literal"><span class="pre">handlers</span></code>, if appropriate, or continues to unwind via the unwind label if
present.</p>
<p>The <code class="docutils literal"><span class="pre">catchswitch</span></code> is both a terminator and a &#8220;pad&#8221; instruction, meaning that
it must be both the first non-phi instruction and last instruction in the basic
block. Therefore, it must be the only non-phi instruction in the block.</p>
</div>
<div class="section" id="id49">
<h5><a class="toc-backref" href="#id824">Example:</a><a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>dispatch1:
  %cs1 = catchswitch within none [label %handler0, label %handler1] unwind to caller
dispatch2:
  %cs2 = catchswitch within %parenthandler [label %handler0] unwind label %cleanup
</pre></div>
</div>
</div>
</div>
<div class="section" id="catchret-instruction">
<span id="i-catchret"></span><h4><a class="toc-backref" href="#id825">&#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; Instruction</a><a class="headerlink" href="#catchret-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id50">
<h5><a class="toc-backref" href="#id826">Syntax:</a><a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">catchret</span> <span class="kn">from</span> <span class="o">&lt;</span><span class="n">token</span><span class="o">&gt;</span> <span class="n">to</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">normal</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h5><a class="toc-backref" href="#id827">Overview:</a><a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; instruction is a terminator instruction that has a
single successor.</p>
</div>
<div class="section" id="id52">
<h5><a class="toc-backref" href="#id828">Arguments:</a><a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h5>
<p>The first argument to a &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; indicates which <code class="docutils literal"><span class="pre">catchpad</span></code> it
exits.  It must be a <a class="reference internal" href="#i-catchpad"><span class="std std-ref">catchpad</span></a>.
The second argument to a &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; specifies where control will
transfer to next.</p>
</div>
<div class="section" id="id53">
<h5><a class="toc-backref" href="#id829">Semantics:</a><a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; instruction ends an existing (in-flight) exception whose
unwinding was interrupted with a <a class="reference internal" href="#i-catchpad"><span class="std std-ref">catchpad</span></a> instruction.  The
<a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> gets a chance to execute arbitrary
code to, for example, destroy the active exception.  Control then transfers to
<code class="docutils literal"><span class="pre">normal</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">token</span></code> argument must be a token produced by a <code class="docutils literal"><span class="pre">catchpad</span></code> instruction.
If the specified <code class="docutils literal"><span class="pre">catchpad</span></code> is not the most-recently-entered not-yet-exited
funclet pad (as described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
the <code class="docutils literal"><span class="pre">catchret</span></code>&#8216;s behavior is undefined.</p>
</div>
<div class="section" id="id54">
<h5><a class="toc-backref" href="#id830">Example:</a><a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>catchret from %catch label %continue
</pre></div>
</div>
</div>
</div>
<div class="section" id="cleanupret-instruction">
<span id="i-cleanupret"></span><h4><a class="toc-backref" href="#id831">&#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; Instruction</a><a class="headerlink" href="#cleanupret-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id55">
<h5><a class="toc-backref" href="#id832">Syntax:</a><a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cleanupret</span> <span class="kn">from</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">unwind</span> <span class="n">label</span> <span class="o">&lt;</span><span class="k">continue</span><span class="o">&gt;</span>
<span class="n">cleanupret</span> <span class="kn">from</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">unwind</span> <span class="n">to</span> <span class="n">caller</span>
</pre></div>
</div>
</div>
<div class="section" id="id56">
<h5><a class="toc-backref" href="#id833">Overview:</a><a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction is a terminator instruction that has
an optional successor.</p>
</div>
<div class="section" id="id57">
<h5><a class="toc-backref" href="#id834">Arguments:</a><a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction requires one argument, which indicates
which <code class="docutils literal"><span class="pre">cleanuppad</span></code> it exits, and must be a <a class="reference internal" href="#i-cleanuppad"><span class="std std-ref">cleanuppad</span></a>.
If the specified <code class="docutils literal"><span class="pre">cleanuppad</span></code> is not the most-recently-entered not-yet-exited
funclet pad (as described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
the <code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216;s behavior is undefined.</p>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction also has an optional successor, <code class="docutils literal"><span class="pre">continue</span></code>,
which must be the label of another basic block beginning with either a
<code class="docutils literal"><span class="pre">cleanuppad</span></code> or <code class="docutils literal"><span class="pre">catchswitch</span></code> instruction.  This unwind destination must
be a legal target with respect to the <code class="docutils literal"><span class="pre">parent</span></code> links, as described in the
<a class="reference external" href="ExceptionHandling.html#wineh-constraints">exception handling documentation</a>.</p>
</div>
<div class="section" id="id60">
<h5><a class="toc-backref" href="#id835">Semantics:</a><a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction indicates to the
<a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> that one
<a class="reference internal" href="#i-cleanuppad"><span class="std std-ref">cleanuppad</span></a> it transferred control to has ended.
It transfers control to <code class="docutils literal"><span class="pre">continue</span></code> or unwinds out of the function.</p>
</div>
<div class="section" id="id61">
<h5><a class="toc-backref" href="#id836">Example:</a><a class="headerlink" href="#id61" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>cleanupret from %cleanup unwind to caller
cleanupret from %cleanup unwind label %continue
</pre></div>
</div>
</div>
</div>
<div class="section" id="unreachable-instruction">
<span id="i-unreachable"></span><h4><a class="toc-backref" href="#id837">&#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; Instruction</a><a class="headerlink" href="#unreachable-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id62">
<h5><a class="toc-backref" href="#id838">Syntax:</a><a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unreachable</span>
</pre></div>
</div>
</div>
<div class="section" id="id63">
<h5><a class="toc-backref" href="#id839">Overview:</a><a class="headerlink" href="#id63" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; instruction has no defined semantics. This
instruction is used to inform the optimizer that a particular portion of
the code is not reachable. This can be used to indicate that the code
after a no-return function cannot be reached, and other facts.</p>
</div>
<div class="section" id="id64">
<h5><a class="toc-backref" href="#id840">Semantics:</a><a class="headerlink" href="#id64" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; instruction has no defined semantics.</p>
</div>
</div>
</div>
<div class="section" id="binary-operations">
<span id="binaryops"></span><h3><a class="toc-backref" href="#id841">Binary Operations</a><a class="headerlink" href="#binary-operations" title="永久链接至标题">¶</a></h3>
<p>Binary operators are used to do most of the computation in a program.
They require two operands of the same type, execute an operation on
them, and produce a single value. The operands might represent multiple
data, as is the case with the <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> data type. The
result value has the same type as its operands.</p>
<p>There are several different binary operators:</p>
<div class="section" id="add-instruction">
<span id="i-add"></span><h4><a class="toc-backref" href="#id842">&#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; Instruction</a><a class="headerlink" href="#add-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id65">
<h5><a class="toc-backref" href="#id843">Syntax:</a><a class="headerlink" href="#id65" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id66">
<h5><a class="toc-backref" href="#id844">Overview:</a><a class="headerlink" href="#id66" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; instruction returns the sum of its two operands.</p>
</div>
<div class="section" id="id67">
<h5><a class="toc-backref" href="#id845">Arguments:</a><a class="headerlink" href="#id67" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id68">
<h5><a class="toc-backref" href="#id846">Semantics:</a><a class="headerlink" href="#id68" title="永久链接至标题">¶</a></h5>
<p>The value produced is the integer sum of the two operands.</p>
<p>If the sum has unsigned overflow, the result returned is the
mathematical result modulo 2<sup>n</sup>, where n is the bit width of
the result.</p>
<p>Because LLVM integers use a two&#8217;s complement representation, this
instruction is appropriate for both signed and unsigned integers.</p>
<p><code class="docutils literal"><span class="pre">nuw</span></code> and <code class="docutils literal"><span class="pre">nsw</span></code> stand for &#8220;No Unsigned Wrap&#8221; and &#8220;No Signed Wrap&#8221;,
respectively. If the <code class="docutils literal"><span class="pre">nuw</span></code> and/or <code class="docutils literal"><span class="pre">nsw</span></code> keywords are present, the
result value of the <code class="docutils literal"><span class="pre">add</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if
unsigned and/or signed overflow, respectively, occurs.</p>
</div>
<div class="section" id="id69">
<h5><a class="toc-backref" href="#id847">Example:</a><a class="headerlink" href="#id69" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = add i32 4, %var          ; yields i32:result = 4 + %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fadd-instruction">
<span id="i-fadd"></span><h4><a class="toc-backref" href="#id848">&#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; Instruction</a><a class="headerlink" href="#fadd-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id70">
<h5><a class="toc-backref" href="#id849">Syntax:</a><a class="headerlink" href="#id70" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fadd</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id71">
<h5><a class="toc-backref" href="#id850">Overview:</a><a class="headerlink" href="#id71" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; instruction returns the sum of its two operands.</p>
</div>
<div class="section" id="id72">
<h5><a class="toc-backref" href="#id851">Arguments:</a><a class="headerlink" href="#id72" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id73">
<h5><a class="toc-backref" href="#id852">Semantics:</a><a class="headerlink" href="#id73" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point sum of the two operands. This
instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>,
which are optimization hints to enable otherwise unsafe floating point
optimizations:</p>
</div>
<div class="section" id="id74">
<h5><a class="toc-backref" href="#id853">Example:</a><a class="headerlink" href="#id74" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fadd float 4.0, %var          ; yields float:result = 4.0 + %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="sub-instruction">
<h4><a class="toc-backref" href="#id854">&#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; Instruction</a><a class="headerlink" href="#sub-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id75">
<h5><a class="toc-backref" href="#id855">Syntax:</a><a class="headerlink" href="#id75" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id76">
<h5><a class="toc-backref" href="#id856">Overview:</a><a class="headerlink" href="#id76" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; instruction returns the difference of its two operands.</p>
<p>Note that the &#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; instruction is used to represent the &#8216;<code class="docutils literal"><span class="pre">neg</span></code>&#8216;
instruction present in most other intermediate representations.</p>
</div>
<div class="section" id="id77">
<h5><a class="toc-backref" href="#id857">Arguments:</a><a class="headerlink" href="#id77" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id78">
<h5><a class="toc-backref" href="#id858">Semantics:</a><a class="headerlink" href="#id78" title="永久链接至标题">¶</a></h5>
<p>The value produced is the integer difference of the two operands.</p>
<p>If the difference has unsigned overflow, the result returned is the
mathematical result modulo 2<sup>n</sup>, where n is the bit width of
the result.</p>
<p>Because LLVM integers use a two&#8217;s complement representation, this
instruction is appropriate for both signed and unsigned integers.</p>
<p><code class="docutils literal"><span class="pre">nuw</span></code> and <code class="docutils literal"><span class="pre">nsw</span></code> stand for &#8220;No Unsigned Wrap&#8221; and &#8220;No Signed Wrap&#8221;,
respectively. If the <code class="docutils literal"><span class="pre">nuw</span></code> and/or <code class="docutils literal"><span class="pre">nsw</span></code> keywords are present, the
result value of the <code class="docutils literal"><span class="pre">sub</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if
unsigned and/or signed overflow, respectively, occurs.</p>
</div>
<div class="section" id="id79">
<h5><a class="toc-backref" href="#id859">Example:</a><a class="headerlink" href="#id79" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = sub i32 4, %var          ; yields i32:result = 4 - %var
&lt;result&gt; = sub i32 0, %val          ; yields i32:result = -%var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fsub-instruction">
<span id="i-fsub"></span><h4><a class="toc-backref" href="#id860">&#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; Instruction</a><a class="headerlink" href="#fsub-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id80">
<h5><a class="toc-backref" href="#id861">Syntax:</a><a class="headerlink" href="#id80" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fsub</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id81">
<h5><a class="toc-backref" href="#id862">Overview:</a><a class="headerlink" href="#id81" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; instruction returns the difference of its two operands.</p>
<p>Note that the &#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; instruction is used to represent the &#8216;<code class="docutils literal"><span class="pre">fneg</span></code>&#8216;
instruction present in most other intermediate representations.</p>
</div>
<div class="section" id="id82">
<h5><a class="toc-backref" href="#id863">Arguments:</a><a class="headerlink" href="#id82" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id83">
<h5><a class="toc-backref" href="#id864">Semantics:</a><a class="headerlink" href="#id83" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point difference of the two operands.
This instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math
flags</span></a>, which are optimization hints to enable otherwise
unsafe floating point optimizations:</p>
</div>
<div class="section" id="id84">
<h5><a class="toc-backref" href="#id865">Example:</a><a class="headerlink" href="#id84" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fsub float 4.0, %var           ; yields float:result = 4.0 - %var
&lt;result&gt; = fsub float -0.0, %val          ; yields float:result = -%var
</pre></div>
</div>
</div>
</div>
<div class="section" id="mul-instruction">
<h4><a class="toc-backref" href="#id866">&#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; Instruction</a><a class="headerlink" href="#mul-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id85">
<h5><a class="toc-backref" href="#id867">Syntax:</a><a class="headerlink" href="#id85" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id86">
<h5><a class="toc-backref" href="#id868">Overview:</a><a class="headerlink" href="#id86" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; instruction returns the product of its two operands.</p>
</div>
<div class="section" id="id87">
<h5><a class="toc-backref" href="#id869">Arguments:</a><a class="headerlink" href="#id87" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id88">
<h5><a class="toc-backref" href="#id870">Semantics:</a><a class="headerlink" href="#id88" title="永久链接至标题">¶</a></h5>
<p>The value produced is the integer product of the two operands.</p>
<p>If the result of the multiplication has unsigned overflow, the result
returned is the mathematical result modulo 2<sup>n</sup>, where n is the
bit width of the result.</p>
<p>Because LLVM integers use a two&#8217;s complement representation, and the
result is the same width as the operands, this instruction returns the
correct result for both signed and unsigned integers. If a full product
(e.g. <code class="docutils literal"><span class="pre">i32</span></code> * <code class="docutils literal"><span class="pre">i32</span></code> -&gt; <code class="docutils literal"><span class="pre">i64</span></code>) is needed, the operands should be
sign-extended or zero-extended as appropriate to the width of the full
product.</p>
<p><code class="docutils literal"><span class="pre">nuw</span></code> and <code class="docutils literal"><span class="pre">nsw</span></code> stand for &#8220;No Unsigned Wrap&#8221; and &#8220;No Signed Wrap&#8221;,
respectively. If the <code class="docutils literal"><span class="pre">nuw</span></code> and/or <code class="docutils literal"><span class="pre">nsw</span></code> keywords are present, the
result value of the <code class="docutils literal"><span class="pre">mul</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if
unsigned and/or signed overflow, respectively, occurs.</p>
</div>
<div class="section" id="id89">
<h5><a class="toc-backref" href="#id871">Example:</a><a class="headerlink" href="#id89" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = mul i32 4, %var          ; yields i32:result = 4 * %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fmul-instruction">
<span id="i-fmul"></span><h4><a class="toc-backref" href="#id872">&#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; Instruction</a><a class="headerlink" href="#fmul-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id90">
<h5><a class="toc-backref" href="#id873">Syntax:</a><a class="headerlink" href="#id90" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fmul</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id91">
<h5><a class="toc-backref" href="#id874">Overview:</a><a class="headerlink" href="#id91" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; instruction returns the product of its two operands.</p>
</div>
<div class="section" id="id92">
<h5><a class="toc-backref" href="#id875">Arguments:</a><a class="headerlink" href="#id92" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id93">
<h5><a class="toc-backref" href="#id876">Semantics:</a><a class="headerlink" href="#id93" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point product of the two operands.
This instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math
flags</span></a>, which are optimization hints to enable otherwise
unsafe floating point optimizations:</p>
</div>
<div class="section" id="id94">
<h5><a class="toc-backref" href="#id877">Example:</a><a class="headerlink" href="#id94" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fmul float 4.0, %var          ; yields float:result = 4.0 * %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="udiv-instruction">
<h4><a class="toc-backref" href="#id878">&#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; Instruction</a><a class="headerlink" href="#udiv-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id95">
<h5><a class="toc-backref" href="#id879">Syntax:</a><a class="headerlink" href="#id95" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">udiv</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">udiv</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id96">
<h5><a class="toc-backref" href="#id880">Overview:</a><a class="headerlink" href="#id96" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; instruction returns the quotient of its two operands.</p>
</div>
<div class="section" id="id97">
<h5><a class="toc-backref" href="#id881">Arguments:</a><a class="headerlink" href="#id97" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id98">
<h5><a class="toc-backref" href="#id882">Semantics:</a><a class="headerlink" href="#id98" title="永久链接至标题">¶</a></h5>
<p>The value produced is the unsigned integer quotient of the two operands.</p>
<p>Note that unsigned integer division and signed integer division are
distinct operations; for signed integer division, use &#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216;.</p>
<p>Division by zero leads to undefined behavior.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">udiv</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if %op1 is not a multiple of %op2 (as
such, &#8220;((a udiv exact b) mul b) == a&#8221;).</p>
</div>
<div class="section" id="id99">
<h5><a class="toc-backref" href="#id883">Example:</a><a class="headerlink" href="#id99" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = udiv i32 4, %var          ; yields i32:result = 4 / %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="sdiv-instruction">
<h4><a class="toc-backref" href="#id884">&#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; Instruction</a><a class="headerlink" href="#sdiv-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id100">
<h5><a class="toc-backref" href="#id885">Syntax:</a><a class="headerlink" href="#id100" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sdiv</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sdiv</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id101">
<h5><a class="toc-backref" href="#id886">Overview:</a><a class="headerlink" href="#id101" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; instruction returns the quotient of its two operands.</p>
</div>
<div class="section" id="id102">
<h5><a class="toc-backref" href="#id887">Arguments:</a><a class="headerlink" href="#id102" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id103">
<h5><a class="toc-backref" href="#id888">Semantics:</a><a class="headerlink" href="#id103" title="永久链接至标题">¶</a></h5>
<p>The value produced is the signed integer quotient of the two operands
rounded towards zero.</p>
<p>Note that signed integer division and unsigned integer division are
distinct operations; for unsigned integer division, use &#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216;.</p>
<p>Division by zero leads to undefined behavior. Overflow also leads to
undefined behavior; this is a rare case, but can occur, for example, by
doing a 32-bit division of -2147483648 by -1.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">sdiv</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if the result would be rounded.</p>
</div>
<div class="section" id="id104">
<h5><a class="toc-backref" href="#id889">Example:</a><a class="headerlink" href="#id104" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = sdiv i32 4, %var          ; yields i32:result = 4 / %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fdiv-instruction">
<span id="i-fdiv"></span><h4><a class="toc-backref" href="#id890">&#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; Instruction</a><a class="headerlink" href="#fdiv-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id105">
<h5><a class="toc-backref" href="#id891">Syntax:</a><a class="headerlink" href="#id105" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fdiv</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id106">
<h5><a class="toc-backref" href="#id892">Overview:</a><a class="headerlink" href="#id106" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; instruction returns the quotient of its two operands.</p>
</div>
<div class="section" id="id107">
<h5><a class="toc-backref" href="#id893">Arguments:</a><a class="headerlink" href="#id107" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id108">
<h5><a class="toc-backref" href="#id894">Semantics:</a><a class="headerlink" href="#id108" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point quotient of the two operands.
This instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math
flags</span></a>, which are optimization hints to enable otherwise
unsafe floating point optimizations:</p>
</div>
<div class="section" id="id109">
<h5><a class="toc-backref" href="#id895">Example:</a><a class="headerlink" href="#id109" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fdiv float 4.0, %var          ; yields float:result = 4.0 / %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="urem-instruction">
<h4><a class="toc-backref" href="#id896">&#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; Instruction</a><a class="headerlink" href="#urem-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id110">
<h5><a class="toc-backref" href="#id897">Syntax:</a><a class="headerlink" href="#id110" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">urem</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id111">
<h5><a class="toc-backref" href="#id898">Overview:</a><a class="headerlink" href="#id111" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; instruction returns the remainder from the unsigned
division of its two arguments.</p>
</div>
<div class="section" id="id112">
<h5><a class="toc-backref" href="#id899">Arguments:</a><a class="headerlink" href="#id112" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id113">
<h5><a class="toc-backref" href="#id900">Semantics:</a><a class="headerlink" href="#id113" title="永久链接至标题">¶</a></h5>
<p>This instruction returns the unsigned integer <em>remainder</em> of a division.
This instruction always performs an unsigned division to get the
remainder.</p>
<p>Note that unsigned integer remainder and signed integer remainder are
distinct operations; for signed integer remainder, use &#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216;.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.</p>
</div>
<div class="section" id="id114">
<h5><a class="toc-backref" href="#id901">Example:</a><a class="headerlink" href="#id114" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = urem i32 4, %var          ; yields i32:result = 4 % %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="srem-instruction">
<h4><a class="toc-backref" href="#id902">&#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; Instruction</a><a class="headerlink" href="#srem-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id115">
<h5><a class="toc-backref" href="#id903">Syntax:</a><a class="headerlink" href="#id115" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">srem</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id116">
<h5><a class="toc-backref" href="#id904">Overview:</a><a class="headerlink" href="#id116" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; instruction returns the remainder from the signed
division of its two operands. This instruction can also take
<a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> versions of the values in which case the elements
must be integers.</p>
</div>
<div class="section" id="id117">
<h5><a class="toc-backref" href="#id905">Arguments:</a><a class="headerlink" href="#id117" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id118">
<h5><a class="toc-backref" href="#id906">Semantics:</a><a class="headerlink" href="#id118" title="永久链接至标题">¶</a></h5>
<p>This instruction returns the <em>remainder</em> of a division (where the result
is either zero or has the same sign as the dividend, <code class="docutils literal"><span class="pre">op1</span></code>), not the
<em>modulo</em> operator (where the result is either zero or has the same sign
as the divisor, <code class="docutils literal"><span class="pre">op2</span></code>) of a value. For more information about the
difference, see <a class="reference external" href="http://mathforum.org/dr.math/problems/anne.4.28.99.html">The Math
Forum</a>. For a
table of how this is implemented in various languages, please see
<a class="reference external" href="http://en.wikipedia.org/wiki/Modulo_operation">Wikipedia: modulo
operation</a>.</p>
<p>Note that signed integer remainder and unsigned integer remainder are
distinct operations; for unsigned integer remainder, use &#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216;.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can
occur, for example, by taking the remainder of a 32-bit division of
-2147483648 by -1. (The remainder doesn&#8217;t actually overflow, but this
rule lets srem be implemented using instructions that return both the
result of the division and the remainder.)</p>
</div>
<div class="section" id="id119">
<h5><a class="toc-backref" href="#id907">Example:</a><a class="headerlink" href="#id119" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = srem i32 4, %var          ; yields i32:result = 4 % %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="frem-instruction">
<span id="i-frem"></span><h4><a class="toc-backref" href="#id908">&#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; Instruction</a><a class="headerlink" href="#frem-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id120">
<h5><a class="toc-backref" href="#id909">Syntax:</a><a class="headerlink" href="#id120" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">frem</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id121">
<h5><a class="toc-backref" href="#id910">Overview:</a><a class="headerlink" href="#id121" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; instruction returns the remainder from the division of
its two operands.</p>
</div>
<div class="section" id="id122">
<h5><a class="toc-backref" href="#id911">Arguments:</a><a class="headerlink" href="#id122" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id123">
<h5><a class="toc-backref" href="#id912">Semantics:</a><a class="headerlink" href="#id123" title="永久链接至标题">¶</a></h5>
<p>This instruction returns the <em>remainder</em> of a division. The remainder
has the same sign as the dividend. This instruction can also take any
number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>, which are optimization hints
to enable otherwise unsafe floating point optimizations:</p>
</div>
<div class="section" id="id124">
<h5><a class="toc-backref" href="#id913">Example:</a><a class="headerlink" href="#id124" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = frem float 4.0, %var          ; yields float:result = 4.0 % %var
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="bitwise-binary-operations">
<span id="bitwiseops"></span><h3><a class="toc-backref" href="#id914">Bitwise Binary Operations</a><a class="headerlink" href="#bitwise-binary-operations" title="永久链接至标题">¶</a></h3>
<p>Bitwise binary operators are used to do various forms of bit-twiddling
in a program. They are generally very efficient instructions and can
commonly be strength reduced from other instructions. They require two
operands of the same type, execute an operation on them, and produce a
single value. The resulting value is the same type as its operands.</p>
<div class="section" id="shl-instruction">
<h4><a class="toc-backref" href="#id915">&#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; Instruction</a><a class="headerlink" href="#shl-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id125">
<h5><a class="toc-backref" href="#id916">Syntax:</a><a class="headerlink" href="#id125" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>           <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id126">
<h5><a class="toc-backref" href="#id917">Overview:</a><a class="headerlink" href="#id126" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; instruction returns the first operand shifted to the left
a specified number of bits.</p>
</div>
<div class="section" id="id127">
<h5><a class="toc-backref" href="#id918">Arguments:</a><a class="headerlink" href="#id127" title="永久链接至标题">¶</a></h5>
<p>Both arguments to the &#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; instruction must be the same
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer type.
&#8216;<code class="docutils literal"><span class="pre">op2</span></code>&#8216; is treated as an unsigned value.</p>
</div>
<div class="section" id="id128">
<h5><a class="toc-backref" href="#id919">Semantics:</a><a class="headerlink" href="#id128" title="永久链接至标题">¶</a></h5>
<p>The value produced is <code class="docutils literal"><span class="pre">op1</span></code> * 2<sup>op2</sup> mod 2<sup>n</sup>,
where <code class="docutils literal"><span class="pre">n</span></code> is the width of the result. If <code class="docutils literal"><span class="pre">op2</span></code> is (statically or
dynamically) equal to or larger than the number of bits in
<code class="docutils literal"><span class="pre">op1</span></code>, the result is undefined. If the arguments are vectors, each
vector element of <code class="docutils literal"><span class="pre">op1</span></code> is shifted by the corresponding shift amount
in <code class="docutils literal"><span class="pre">op2</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">nuw</span></code> keyword is present, then the shift produces a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison
value</span></a> if it shifts out any non-zero bits. If the
<code class="docutils literal"><span class="pre">nsw</span></code> keyword is present, then the shift produces a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison
value</span></a> if it shifts out any bits that disagree with the
resultant sign bit. As such, NUW/NSW have the same semantics as they
would if the shift were expressed as a mul instruction with the same
nsw/nuw bits in (mul %op1, (shl 1, %op2)).</p>
</div>
<div class="section" id="id129">
<h5><a class="toc-backref" href="#id920">Example:</a><a class="headerlink" href="#id129" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = shl i32 4, %var   ; yields i32: 4 &lt;&lt; %var
&lt;result&gt; = shl i32 4, 2      ; yields i32: 16
&lt;result&gt; = shl i32 1, 10     ; yields i32: 1024
&lt;result&gt; = shl i32 1, 32     ; undefined
&lt;result&gt; = shl &lt;2 x i32&gt; &lt; i32 1, i32 1&gt;, &lt; i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 2, i32 4&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="lshr-instruction">
<h4><a class="toc-backref" href="#id921">&#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; Instruction</a><a class="headerlink" href="#lshr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id130">
<h5><a class="toc-backref" href="#id922">Syntax:</a><a class="headerlink" href="#id130" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">lshr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">lshr</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id131">
<h5><a class="toc-backref" href="#id923">Overview:</a><a class="headerlink" href="#id131" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; instruction (logical shift right) returns the first
operand shifted to the right a specified number of bits with zero fill.</p>
</div>
<div class="section" id="id132">
<h5><a class="toc-backref" href="#id924">Arguments:</a><a class="headerlink" href="#id132" title="永久链接至标题">¶</a></h5>
<p>Both arguments to the &#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; instruction must be the same
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer type.
&#8216;<code class="docutils literal"><span class="pre">op2</span></code>&#8216; is treated as an unsigned value.</p>
</div>
<div class="section" id="id133">
<h5><a class="toc-backref" href="#id925">Semantics:</a><a class="headerlink" href="#id133" title="永久链接至标题">¶</a></h5>
<p>This instruction always performs a logical shift right operation. The
most significant bits of the result will be filled with zero bits after
the shift. If <code class="docutils literal"><span class="pre">op2</span></code> is (statically or dynamically) equal to or larger
than the number of bits in <code class="docutils literal"><span class="pre">op1</span></code>, the result is undefined. If the
arguments are vectors, each vector element of <code class="docutils literal"><span class="pre">op1</span></code> is shifted by the
corresponding shift amount in <code class="docutils literal"><span class="pre">op2</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">lshr</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if any of the bits shifted out are
non-zero.</p>
</div>
<div class="section" id="id134">
<h5><a class="toc-backref" href="#id926">Example:</a><a class="headerlink" href="#id134" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = lshr i32 4, 1   ; yields i32:result = 2
&lt;result&gt; = lshr i32 4, 2   ; yields i32:result = 1
&lt;result&gt; = lshr i8  4, 3   ; yields i8:result = 0
&lt;result&gt; = lshr i8 -2, 1   ; yields i8:result = 0x7F
&lt;result&gt; = lshr i32 1, 32  ; undefined
&lt;result&gt; = lshr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 0x7FFFFFFF, i32 1&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="ashr-instruction">
<h4><a class="toc-backref" href="#id927">&#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; Instruction</a><a class="headerlink" href="#ashr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id135">
<h5><a class="toc-backref" href="#id928">Syntax:</a><a class="headerlink" href="#id135" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id136">
<h5><a class="toc-backref" href="#id929">Overview:</a><a class="headerlink" href="#id136" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; instruction (arithmetic shift right) returns the first
operand shifted to the right a specified number of bits with sign
extension.</p>
</div>
<div class="section" id="id137">
<h5><a class="toc-backref" href="#id930">Arguments:</a><a class="headerlink" href="#id137" title="永久链接至标题">¶</a></h5>
<p>Both arguments to the &#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; instruction must be the same
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer type.
&#8216;<code class="docutils literal"><span class="pre">op2</span></code>&#8216; is treated as an unsigned value.</p>
</div>
<div class="section" id="id138">
<h5><a class="toc-backref" href="#id931">Semantics:</a><a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h5>
<p>This instruction always performs an arithmetic shift right operation,
The most significant bits of the result will be filled with the sign bit
of <code class="docutils literal"><span class="pre">op1</span></code>. If <code class="docutils literal"><span class="pre">op2</span></code> is (statically or dynamically) equal to or larger
than the number of bits in <code class="docutils literal"><span class="pre">op1</span></code>, the result is undefined. If the
arguments are vectors, each vector element of <code class="docutils literal"><span class="pre">op1</span></code> is shifted by the
corresponding shift amount in <code class="docutils literal"><span class="pre">op2</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">ashr</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if any of the bits shifted out are
non-zero.</p>
</div>
<div class="section" id="id139">
<h5><a class="toc-backref" href="#id932">Example:</a><a class="headerlink" href="#id139" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = ashr i32 4, 1   ; yields i32:result = 2
&lt;result&gt; = ashr i32 4, 2   ; yields i32:result = 1
&lt;result&gt; = ashr i8  4, 3   ; yields i8:result = 0
&lt;result&gt; = ashr i8 -2, 1   ; yields i8:result = -1
&lt;result&gt; = ashr i32 1, 32  ; undefined
&lt;result&gt; = ashr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 3&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 -1, i32 0&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="and-instruction">
<h4><a class="toc-backref" href="#id933">&#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; Instruction</a><a class="headerlink" href="#and-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id140">
<h5><a class="toc-backref" href="#id934">Syntax:</a><a class="headerlink" href="#id140" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">and</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id141">
<h5><a class="toc-backref" href="#id935">Overview:</a><a class="headerlink" href="#id141" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; instruction returns the bitwise logical and of its two
operands.</p>
</div>
<div class="section" id="id142">
<h5><a class="toc-backref" href="#id936">Arguments:</a><a class="headerlink" href="#id142" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id143">
<h5><a class="toc-backref" href="#id937">Semantics:</a><a class="headerlink" href="#id143" title="永久链接至标题">¶</a></h5>
<p>The truth table used for the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; instruction is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In0</td>
<td>In1</td>
<td>Out</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id144">
<h5><a class="toc-backref" href="#id938">Example:</a><a class="headerlink" href="#id144" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = and i32 4, %var         ; yields i32:result = 4 &amp; %var
&lt;result&gt; = and i32 15, 40          ; yields i32:result = 8
&lt;result&gt; = and i32 4, 8            ; yields i32:result = 0
</pre></div>
</div>
</div>
</div>
<div class="section" id="or-instruction">
<h4><a class="toc-backref" href="#id939">&#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; Instruction</a><a class="headerlink" href="#or-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id145">
<h5><a class="toc-backref" href="#id940">Syntax:</a><a class="headerlink" href="#id145" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id146">
<h5><a class="toc-backref" href="#id941">Overview:</a><a class="headerlink" href="#id146" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; instruction returns the bitwise logical inclusive or of its
two operands.</p>
</div>
<div class="section" id="id147">
<h5><a class="toc-backref" href="#id942">Arguments:</a><a class="headerlink" href="#id147" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id148">
<h5><a class="toc-backref" href="#id943">Semantics:</a><a class="headerlink" href="#id148" title="永久链接至标题">¶</a></h5>
<p>The truth table used for the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; instruction is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In0</td>
<td>In1</td>
<td>Out</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id149">
<h5><a class="toc-backref" href="#id944">Example:</a><a class="headerlink" href="#id149" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="n">var</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">i32</span><span class="p">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">|</span> <span class="o">%</span><span class="n">var</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="n">i32</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">40</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">i32</span><span class="p">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">47</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span>            <span class="p">;</span> <span class="n">yields</span> <span class="n">i32</span><span class="p">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="xor-instruction">
<h4><a class="toc-backref" href="#id945">&#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; Instruction</a><a class="headerlink" href="#xor-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id150">
<h5><a class="toc-backref" href="#id946">Syntax:</a><a class="headerlink" href="#id150" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">xor</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id151">
<h5><a class="toc-backref" href="#id947">Overview:</a><a class="headerlink" href="#id151" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; instruction returns the bitwise logical exclusive or of
its two operands. The <code class="docutils literal"><span class="pre">xor</span></code> is used to implement the &#8220;one&#8217;s
complement&#8221; operation, which is the &#8220;~&#8221; operator in C.</p>
</div>
<div class="section" id="id152">
<h5><a class="toc-backref" href="#id948">Arguments:</a><a class="headerlink" href="#id152" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id153">
<h5><a class="toc-backref" href="#id949">Semantics:</a><a class="headerlink" href="#id153" title="永久链接至标题">¶</a></h5>
<p>The truth table used for the &#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; instruction is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In0</td>
<td>In1</td>
<td>Out</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id154">
<h5><a class="toc-backref" href="#id950">Example:</a><a class="headerlink" href="#id154" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = xor i32 4, %var         ; yields i32:result = 4 ^ %var
&lt;result&gt; = xor i32 15, 40          ; yields i32:result = 39
&lt;result&gt; = xor i32 4, 8            ; yields i32:result = 12
&lt;result&gt; = xor i32 %V, -1          ; yields i32:result = ~%V
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="vector-operations">
<h3><a class="toc-backref" href="#id951">Vector Operations</a><a class="headerlink" href="#vector-operations" title="永久链接至标题">¶</a></h3>
<p>LLVM supports several instructions to represent vector operations in a
target-independent manner. These instructions cover the element-access
and vector-specific operations needed to process vectors effectively.
While LLVM does directly support these vector operations, many
sophisticated algorithms will want to use target-specific intrinsics to
take full advantage of a specific target.</p>
<div class="section" id="extractelement-instruction">
<span id="i-extractelement"></span><h4><a class="toc-backref" href="#id952">&#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; Instruction</a><a class="headerlink" href="#extractelement-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id155">
<h5><a class="toc-backref" href="#id953">Syntax:</a><a class="headerlink" href="#id155" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id156">
<h5><a class="toc-backref" href="#id954">Overview:</a><a class="headerlink" href="#id156" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; instruction extracts a single scalar element
from a vector at a specified index.</p>
</div>
<div class="section" id="id157">
<h5><a class="toc-backref" href="#id955">Arguments:</a><a class="headerlink" href="#id157" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> type. The second operand is an index indicating
the position from which to extract the element. The index may be a
variable of any integer type.</p>
</div>
<div class="section" id="id158">
<h5><a class="toc-backref" href="#id956">Semantics:</a><a class="headerlink" href="#id158" title="永久链接至标题">¶</a></h5>
<p>The result is a scalar of the same type as the element type of <code class="docutils literal"><span class="pre">val</span></code>.
Its value is the value at position <code class="docutils literal"><span class="pre">idx</span></code> of <code class="docutils literal"><span class="pre">val</span></code>. If <code class="docutils literal"><span class="pre">idx</span></code>
exceeds the length of <code class="docutils literal"><span class="pre">val</span></code>, the results are undefined.</p>
</div>
<div class="section" id="id159">
<h5><a class="toc-backref" href="#id957">Example:</a><a class="headerlink" href="#id159" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = extractelement &lt;4 x i32&gt; %vec, i32 0    ; yields i32
</pre></div>
</div>
</div>
</div>
<div class="section" id="insertelement-instruction">
<span id="i-insertelement"></span><h4><a class="toc-backref" href="#id958">&#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; Instruction</a><a class="headerlink" href="#insertelement-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id160">
<h5><a class="toc-backref" href="#id959">Syntax:</a><a class="headerlink" href="#id160" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">elt</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id161">
<h5><a class="toc-backref" href="#id960">Overview:</a><a class="headerlink" href="#id161" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; instruction inserts a scalar element into a
vector at a specified index.</p>
</div>
<div class="section" id="id162">
<h5><a class="toc-backref" href="#id961">Arguments:</a><a class="headerlink" href="#id162" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> type. The second operand is a scalar value whose
type must equal the element type of the first operand. The third operand
is an index indicating the position at which to insert the value. The
index may be a variable of any integer type.</p>
</div>
<div class="section" id="id163">
<h5><a class="toc-backref" href="#id962">Semantics:</a><a class="headerlink" href="#id163" title="永久链接至标题">¶</a></h5>
<p>The result is a vector of the same type as <code class="docutils literal"><span class="pre">val</span></code>. Its element values
are those of <code class="docutils literal"><span class="pre">val</span></code> except at position <code class="docutils literal"><span class="pre">idx</span></code>, where it gets the value
<code class="docutils literal"><span class="pre">elt</span></code>. If <code class="docutils literal"><span class="pre">idx</span></code> exceeds the length of <code class="docutils literal"><span class="pre">val</span></code>, the results are
undefined.</p>
</div>
<div class="section" id="id164">
<h5><a class="toc-backref" href="#id963">Example:</a><a class="headerlink" href="#id164" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = insertelement &lt;4 x i32&gt; %vec, i32 1, i32 0    ; yields &lt;4 x i32&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="shufflevector-instruction">
<span id="i-shufflevector"></span><h4><a class="toc-backref" href="#id964">&#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; Instruction</a><a class="headerlink" href="#shufflevector-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id165">
<h5><a class="toc-backref" href="#id965">Syntax:</a><a class="headerlink" href="#id165" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shufflevector</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">v1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">v2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">m</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">m</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id166">
<h5><a class="toc-backref" href="#id966">Overview:</a><a class="headerlink" href="#id166" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; instruction constructs a permutation of elements
from two input vectors, returning a vector with the same element type as
the input and length that is the same as the shuffle mask.</p>
</div>
<div class="section" id="id167">
<h5><a class="toc-backref" href="#id967">Arguments:</a><a class="headerlink" href="#id167" title="永久链接至标题">¶</a></h5>
<p>The first two operands of a &#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; instruction are vectors
with the same type. The third argument is a shuffle mask whose element
type is always &#8216;i32&#8217;. The result of the instruction is a vector whose
length is the same as the shuffle mask and whose element type is the
same as the element type of the first two operands.</p>
<p>The shuffle mask operand is required to be a constant vector with either
constant integer or undef values.</p>
</div>
<div class="section" id="id168">
<h5><a class="toc-backref" href="#id968">Semantics:</a><a class="headerlink" href="#id168" title="永久链接至标题">¶</a></h5>
<p>The elements of the two input vectors are numbered from left to right
across both of the vectors. The shuffle mask operand specifies, for each
element of the result vector, which element of the two input vectors the
result element gets. The element selector may be undef (meaning &#8220;don&#8217;t
care&#8221;) and the second operand may be undef if performing a shuffle from
only one vector.</p>
</div>
<div class="section" id="id169">
<h5><a class="toc-backref" href="#id969">Example:</a><a class="headerlink" href="#id169" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2,
                        &lt;4 x i32&gt; &lt;i32 0, i32 4, i32 1, i32 5&gt;  ; yields &lt;4 x i32&gt;
&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; undef,
                        &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;  ; yields &lt;4 x i32&gt; - Identity shuffle.
&lt;result&gt; = shufflevector &lt;8 x i32&gt; %v1, &lt;8 x i32&gt; undef,
                        &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;  ; yields &lt;4 x i32&gt;
&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2,
                        &lt;8 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 &gt;  ; yields &lt;8 x i32&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="aggregate-operations">
<h3><a class="toc-backref" href="#id970">Aggregate Operations</a><a class="headerlink" href="#aggregate-operations" title="永久链接至标题">¶</a></h3>
<p>LLVM supports several instructions for working with
<a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> values.</p>
<div class="section" id="extractvalue-instruction">
<span id="i-extractvalue"></span><h4><a class="toc-backref" href="#id971">&#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; Instruction</a><a class="headerlink" href="#extractvalue-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id170">
<h5><a class="toc-backref" href="#id972">Syntax:</a><a class="headerlink" href="#id170" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">extractvalue</span> <span class="o">&lt;</span><span class="n">aggregate</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>
</pre></div>
</div>
</div>
<div class="section" id="id171">
<h5><a class="toc-backref" href="#id973">Overview:</a><a class="headerlink" href="#id171" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; instruction extracts the value of a member field
from an <a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> value.</p>
</div>
<div class="section" id="id172">
<h5><a class="toc-backref" href="#id974">Arguments:</a><a class="headerlink" href="#id172" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-struct"><span class="std std-ref">struct</span></a> or <a class="reference internal" href="#t-array"><span class="std std-ref">array</span></a> type. The other operands are
constant indices to specify which value to extract in a similar manner
as indices in a &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction.</p>
<p>The major differences to <code class="docutils literal"><span class="pre">getelementptr</span></code> indexing are:</p>
<ul class="simple">
<li>Since the value being indexed is not a pointer, the first index is
omitted and assumed to be zero.</li>
<li>At least one index must be specified.</li>
<li>Not only struct indices but also array indices must be in bounds.</li>
</ul>
</div>
<div class="section" id="id173">
<h5><a class="toc-backref" href="#id975">Semantics:</a><a class="headerlink" href="#id173" title="永久链接至标题">¶</a></h5>
<p>The result is the value at the position in the aggregate specified by
the index operands.</p>
</div>
<div class="section" id="id174">
<h5><a class="toc-backref" href="#id976">Example:</a><a class="headerlink" href="#id174" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = extractvalue {i32, float} %agg, 0    ; yields i32
</pre></div>
</div>
</div>
</div>
<div class="section" id="insertvalue-instruction">
<span id="i-insertvalue"></span><h4><a class="toc-backref" href="#id977">&#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; Instruction</a><a class="headerlink" href="#insertvalue-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id175">
<h5><a class="toc-backref" href="#id978">Syntax:</a><a class="headerlink" href="#id175" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">insertvalue</span> <span class="o">&lt;</span><span class="n">aggregate</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">elt</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>    <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">aggregate</span> <span class="nb">type</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id176">
<h5><a class="toc-backref" href="#id979">Overview:</a><a class="headerlink" href="#id176" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; instruction inserts a value into a member field in
an <a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> value.</p>
</div>
<div class="section" id="id177">
<h5><a class="toc-backref" href="#id980">Arguments:</a><a class="headerlink" href="#id177" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-struct"><span class="std std-ref">struct</span></a> or <a class="reference internal" href="#t-array"><span class="std std-ref">array</span></a> type. The second operand is
a first-class value to insert. The following operands are constant
indices indicating the position at which to insert the value in a
similar manner as indices in a &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; instruction. The value
to insert must have the same type as the value identified by the
indices.</p>
</div>
<div class="section" id="id178">
<h5><a class="toc-backref" href="#id981">Semantics:</a><a class="headerlink" href="#id178" title="永久链接至标题">¶</a></h5>
<p>The result is an aggregate of the same type as <code class="docutils literal"><span class="pre">val</span></code>. Its value is
that of <code class="docutils literal"><span class="pre">val</span></code> except that the value at the position specified by the
indices is that of <code class="docutils literal"><span class="pre">elt</span></code>.</p>
</div>
<div class="section" id="id179">
<h5><a class="toc-backref" href="#id982">Example:</a><a class="headerlink" href="#id179" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%agg1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="kt">float</span><span class="p">}</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span>              <span class="c">; yields {i32 1, float undef}</span>
<span class="nv">%agg2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="kt">float</span><span class="p">}</span> <span class="nv">%agg1</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%val</span><span class="p">,</span> <span class="m">1</span>         <span class="c">; yields {i32 1, float %val}</span>
<span class="nv">%agg3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">{</span><span class="kt">float</span><span class="p">}}</span> <span class="k">undef</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%val</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span>    <span class="c">; yields {i32 undef, {float %val}}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="memory-access-and-addressing-operations">
<span id="memoryops"></span><h3><a class="toc-backref" href="#id983">Memory Access and Addressing Operations</a><a class="headerlink" href="#memory-access-and-addressing-operations" title="永久链接至标题">¶</a></h3>
<p>A key design point of an SSA-based representation is how it represents
memory. In LLVM, no memory locations are in SSA form, which makes things
very simple. This section describes how to read, write, and allocate
memory in LLVM.</p>
<div class="section" id="alloca-instruction">
<span id="i-alloca"></span><h4><a class="toc-backref" href="#id984">&#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; Instruction</a><a class="headerlink" href="#alloca-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id180">
<h5><a class="toc-backref" href="#id985">Syntax:</a><a class="headerlink" href="#id180" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">alloca</span> <span class="p">[</span><span class="n">inalloca</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="p">[,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">NumElements</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[,</span> <span class="n">align</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">]</span>     <span class="p">;</span> <span class="n">yields</span> <span class="nb">type</span><span class="o">*</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id181">
<h5><a class="toc-backref" href="#id986">Overview:</a><a class="headerlink" href="#id181" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; instruction allocates memory on the stack frame of the
currently executing function, to be automatically released when this
function returns to its caller. The object is always allocated in the
generic address space (address space zero).</p>
</div>
<div class="section" id="id182">
<h5><a class="toc-backref" href="#id987">Arguments:</a><a class="headerlink" href="#id182" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; instruction allocates <code class="docutils literal"><span class="pre">sizeof(&lt;type&gt;)*NumElements</span></code>
bytes of memory on the runtime stack, returning a pointer of the
appropriate type to the program. If &#8220;NumElements&#8221; is specified, it is
the number of elements allocated, otherwise &#8220;NumElements&#8221; is defaulted
to be one. If a constant alignment is specified, the value result of the
allocation is guaranteed to be aligned to at least that boundary. The
alignment may not be greater than <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>. If not specified, or if
zero, the target can choose to align the allocation on any convenient
boundary compatible with the type.</p>
<p>&#8216;<code class="docutils literal"><span class="pre">type</span></code>&#8216; may be any sized type.</p>
</div>
<div class="section" id="id183">
<h5><a class="toc-backref" href="#id988">Semantics:</a><a class="headerlink" href="#id183" title="永久链接至标题">¶</a></h5>
<p>Memory is allocated; a pointer is returned. The operation is undefined
if there is insufficient stack space for the allocation. &#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216;d
memory is automatically released when the function returns. The
&#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; instruction is commonly used to represent automatic
variables that must have an address available. When the function returns
(either with the <code class="docutils literal"><span class="pre">ret</span></code> or <code class="docutils literal"><span class="pre">resume</span></code> instructions), the memory is
reclaimed. Allocating zero bytes is legal, but the result is undefined.
The order in which memory is allocated (ie., which way the stack grows)
is not specified.</p>
</div>
<div class="section" id="id184">
<h5><a class="toc-backref" href="#id989">Example:</a><a class="headerlink" href="#id184" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>                             <span class="c">; yields i32*:ptr</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span>                      <span class="c">; yields i32*:ptr</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">,</span> <span class="k">align</span> <span class="m">1024</span>          <span class="c">; yields i32*:ptr</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">1024</span>                 <span class="c">; yields i32*:ptr</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="load-instruction">
<span id="i-load"></span><h4><a class="toc-backref" href="#id990">&#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; Instruction</a><a class="headerlink" href="#load-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id185">
<h5><a class="toc-backref" href="#id991">Syntax:</a><a class="headerlink" href="#id185" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span>&lt;result&gt; = load [volatile] &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;index&gt;][, !invariant.load !&lt;index&gt;][, !invariant.group !&lt;index&gt;][, !nonnull !&lt;index&gt;][, !dereferenceable !&lt;deref_bytes_node&gt;][, !dereferenceable_or_null !&lt;deref_bytes_node&gt;][, !align !&lt;align_node&gt;]
&lt;result&gt; = load atomic [volatile] &lt;ty&gt;* &lt;pointer&gt; [singlethread] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;index&gt;]
!&lt;index&gt; = !{ i32 1 }
!&lt;deref_bytes_node&gt; = !{i64 &lt;dereferenceable_bytes&gt;}
!&lt;align_node&gt; = !{ i64 &lt;value_alignment&gt; }
</pre></div>
</div>
</div>
<div class="section" id="id186">
<h5><a class="toc-backref" href="#id992">Overview:</a><a class="headerlink" href="#id186" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; instruction is used to read from memory.</p>
</div>
<div class="section" id="id187">
<h5><a class="toc-backref" href="#id993">Arguments:</a><a class="headerlink" href="#id187" title="永久链接至标题">¶</a></h5>
<p>The argument to the <code class="docutils literal"><span class="pre">load</span></code> instruction specifies the memory address
from which to load. The type specified must be a <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first
class</span></a> type. If the <code class="docutils literal"><span class="pre">load</span></code> is marked as <code class="docutils literal"><span class="pre">volatile</span></code>,
then the optimizer is not allowed to modify the number or order of
execution of this <code class="docutils literal"><span class="pre">load</span></code> with other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.</p>
<p>If the <code class="docutils literal"><span class="pre">load</span></code> is marked as <code class="docutils literal"><span class="pre">atomic</span></code>, it takes an extra <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> and optional <code class="docutils literal"><span class="pre">singlethread</span></code> argument. The <code class="docutils literal"><span class="pre">release</span></code> and
<code class="docutils literal"><span class="pre">acq_rel</span></code> orderings are not valid on <code class="docutils literal"><span class="pre">load</span></code> instructions. Atomic loads
produce <a class="reference internal" href="#memmodel"><span class="std std-ref">defined</span></a> results when they may see multiple atomic
stores. The type of the pointee must be an integer, pointer, or floating-point
type whose bit width is a power of two greater than or equal to eight and less
than or equal to a target-specific size limit.  <code class="docutils literal"><span class="pre">align</span></code> must be explicitly
specified on atomic loads, and the load has undefined behavior if the alignment
is not set to a value which is at least the size in bytes of the
pointee. <code class="docutils literal"><span class="pre">!nontemporal</span></code> does not have any defined semantics for atomic loads.</p>
<p>The optional constant <code class="docutils literal"><span class="pre">align</span></code> argument specifies the alignment of the
operation (that is, the alignment of the memory address). A value of 0
or an omitted <code class="docutils literal"><span class="pre">align</span></code> argument means that the operation has the ABI
alignment for the target. It is the responsibility of the code emitter
to ensure that the alignment information is correct. Overestimating the
alignment results in undefined behavior. Underestimating the alignment
may produce less efficient code. An alignment of 1 is always safe. The
maximum possible alignment is <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>.</p>
<p>The optional <code class="docutils literal"><span class="pre">!nontemporal</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with one
<code class="docutils literal"><span class="pre">i32</span></code> entry of value 1. The existence of the <code class="docutils literal"><span class="pre">!nontemporal</span></code>
metadata on the instruction tells the optimizer and code generator
that this load is not expected to be reused in the cache. The code
generator may select special instructions to save cache bandwidth, such
as the <code class="docutils literal"><span class="pre">MOVNT</span></code> instruction on x86.</p>
<p>The optional <code class="docutils literal"><span class="pre">!invariant.load</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with no
entries. The existence of the <code class="docutils literal"><span class="pre">!invariant.load</span></code> metadata on the
instruction tells the optimizer and code generator that the address
operand to this load points to memory which can be assumed unchanged.
Being invariant does not imply that a location is dereferenceable,
but it does imply that once the location is known dereferenceable
its value is henceforth unchanging.</p>
<dl class="docutils">
<dt>The optional <code class="docutils literal"><span class="pre">!invariant.group</span></code> metadata must reference a single metadata name</dt>
<dd><code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node. See <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata.</dd>
</dl>
<p>The optional <code class="docutils literal"><span class="pre">!nonnull</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with no
entries. The existence of the <code class="docutils literal"><span class="pre">!nonnull</span></code> metadata on the
instruction tells the optimizer that the value loaded is known to
never be null. This is analogous to the <code class="docutils literal"><span class="pre">nonnull</span></code> attribute
on parameters and return values. This metadata can only be applied
to loads of a pointer type.</p>
<p>The optional <code class="docutils literal"><span class="pre">!dereferenceable</span></code> metadata must reference a single metadata
name <code class="docutils literal"><span class="pre">&lt;deref_bytes_node&gt;</span></code> corresponding to a metadata node with one <code class="docutils literal"><span class="pre">i64</span></code>
entry. The existence of the <code class="docutils literal"><span class="pre">!dereferenceable</span></code> metadata on the instruction
tells the optimizer that the value loaded is known to be dereferenceable.
The number of bytes known to be dereferenceable is specified by the integer
value in the metadata node. This is analogous to the &#8216;&#8217;dereferenceable&#8217;&#8217;
attribute on parameters and return values. This metadata can only be applied
to loads of a pointer type.</p>
<p>The optional <code class="docutils literal"><span class="pre">!dereferenceable_or_null</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;deref_bytes_node&gt;</span></code> corresponding to a metadata node with one
<code class="docutils literal"><span class="pre">i64</span></code> entry. The existence of the <code class="docutils literal"><span class="pre">!dereferenceable_or_null</span></code> metadata on the
instruction tells the optimizer that the value loaded is known to be either
dereferenceable or null.
The number of bytes known to be dereferenceable is specified by the integer
value in the metadata node. This is analogous to the &#8216;&#8217;dereferenceable_or_null&#8217;&#8217;
attribute on parameters and return values. This metadata can only be applied
to loads of a pointer type.</p>
<p>The optional <code class="docutils literal"><span class="pre">!align</span></code> metadata must reference a single metadata name
<code class="docutils literal"><span class="pre">&lt;align_node&gt;</span></code> corresponding to a metadata node with one <code class="docutils literal"><span class="pre">i64</span></code> entry.
The existence of the <code class="docutils literal"><span class="pre">!align</span></code> metadata on the instruction tells the
optimizer that the value loaded is known to be aligned to a boundary specified
by the integer value in the metadata node. The alignment must be a power of 2.
This is analogous to the &#8216;&#8217;align&#8217;&#8217; attribute on parameters and return values.
This metadata can only be applied to loads of a pointer type.</p>
</div>
<div class="section" id="id188">
<h5><a class="toc-backref" href="#id994">Semantics:</a><a class="headerlink" href="#id188" title="永久链接至标题">¶</a></h5>
<p>The location of memory pointed to is loaded. If the value being loaded
is of scalar type then the number of bytes read does not exceed the
minimum number of bytes needed to hold all bits of the type. For
example, loading an <code class="docutils literal"><span class="pre">i24</span></code> reads at most three bytes. When loading a
value of a type like <code class="docutils literal"><span class="pre">i20</span></code> with a size that is not an integral number
of bytes, the result is undefined if the value was not originally
written using a store of the same type.</p>
</div>
<div class="section" id="id189">
<h5><a class="toc-backref" href="#id995">Examples:</a><a class="headerlink" href="#id189" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>                               <span class="c">; yields i32*:ptr</span>
<span class="k">store</span> <span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                          <span class="c">; yields void</span>
<span class="nv">%val</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                      <span class="c">; yields i32:val = i32 3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="store-instruction">
<span id="i-store"></span><h4><a class="toc-backref" href="#id996">&#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; Instruction</a><a class="headerlink" href="#store-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id190">
<h5><a class="toc-backref" href="#id997">Syntax:</a><a class="headerlink" href="#id190" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span>store [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;index&gt;][, !invariant.group !&lt;index&gt;]        ; yields void
store atomic [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt; [singlethread] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;index&gt;] ; yields void
</pre></div>
</div>
</div>
<div class="section" id="id191">
<h5><a class="toc-backref" href="#id998">Overview:</a><a class="headerlink" href="#id191" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; instruction is used to write to memory.</p>
</div>
<div class="section" id="id192">
<h5><a class="toc-backref" href="#id999">Arguments:</a><a class="headerlink" href="#id192" title="永久链接至标题">¶</a></h5>
<p>There are two arguments to the <code class="docutils literal"><span class="pre">store</span></code> instruction: a value to store
and an address at which to store it. The type of the <code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>
operand must be a pointer to the <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type of
the <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> operand. If the <code class="docutils literal"><span class="pre">store</span></code> is marked as <code class="docutils literal"><span class="pre">volatile</span></code>,
then the optimizer is not allowed to modify the number or order of
execution of this <code class="docutils literal"><span class="pre">store</span></code> with other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.</p>
<p>If the <code class="docutils literal"><span class="pre">store</span></code> is marked as <code class="docutils literal"><span class="pre">atomic</span></code>, it takes an extra <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> and optional <code class="docutils literal"><span class="pre">singlethread</span></code> argument. The <code class="docutils literal"><span class="pre">acquire</span></code> and
<code class="docutils literal"><span class="pre">acq_rel</span></code> orderings aren&#8217;t valid on <code class="docutils literal"><span class="pre">store</span></code> instructions. Atomic loads
produce <a class="reference internal" href="#memmodel"><span class="std std-ref">defined</span></a> results when they may see multiple atomic
stores. The type of the pointee must be an integer, pointer, or floating-point
type whose bit width is a power of two greater than or equal to eight and less
than or equal to a target-specific size limit.  <code class="docutils literal"><span class="pre">align</span></code> must be explicitly
specified on atomic stores, and the store has undefined behavior if the
alignment is not set to a value which is at least the size in bytes of the
pointee. <code class="docutils literal"><span class="pre">!nontemporal</span></code> does not have any defined semantics for atomic stores.</p>
<p>The optional constant <code class="docutils literal"><span class="pre">align</span></code> argument specifies the alignment of the
operation (that is, the alignment of the memory address). A value of 0
or an omitted <code class="docutils literal"><span class="pre">align</span></code> argument means that the operation has the ABI
alignment for the target. It is the responsibility of the code emitter
to ensure that the alignment information is correct. Overestimating the
alignment results in undefined behavior. Underestimating the
alignment may produce less efficient code. An alignment of 1 is always
safe. The maximum possible alignment is <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>.</p>
<p>The optional <code class="docutils literal"><span class="pre">!nontemporal</span></code> metadata must reference a single metadata
name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with one <code class="docutils literal"><span class="pre">i32</span></code> entry of
value 1. The existence of the <code class="docutils literal"><span class="pre">!nontemporal</span></code> metadata on the instruction
tells the optimizer and code generator that this load is not expected to
be reused in the cache. The code generator may select special
instructions to save cache bandwidth, such as the <code class="docutils literal"><span class="pre">MOVNT</span></code> instruction on
x86.</p>
<p>The optional <code class="docutils literal"><span class="pre">!invariant.group</span></code> metadata must reference a
single metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code>. See <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata.</p>
</div>
<div class="section" id="id193">
<h5><a class="toc-backref" href="#id1000">Semantics:</a><a class="headerlink" href="#id193" title="永久链接至标题">¶</a></h5>
<p>The contents of memory are updated to contain <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> at the
location specified by the <code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code> operand. If <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> is
of scalar type then the number of bytes written does not exceed the
minimum number of bytes needed to hold all bits of the type. For
example, storing an <code class="docutils literal"><span class="pre">i24</span></code> writes at most three bytes. When writing a
value of a type like <code class="docutils literal"><span class="pre">i20</span></code> with a size that is not an integral number
of bytes, it is unspecified what happens to the extra bits that do not
belong to the type, but they will typically be overwritten.</p>
</div>
<div class="section" id="id194">
<h5><a class="toc-backref" href="#id1001">Example:</a><a class="headerlink" href="#id194" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>                               <span class="c">; yields i32*:ptr</span>
<span class="k">store</span> <span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                          <span class="c">; yields void</span>
<span class="nv">%val</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                      <span class="c">; yields i32:val = i32 3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fence-instruction">
<span id="i-fence"></span><h4><a class="toc-backref" href="#id1002">&#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; Instruction</a><a class="headerlink" href="#fence-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id195">
<h5><a class="toc-backref" href="#id1003">Syntax:</a><a class="headerlink" href="#id195" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fence</span> <span class="p">[</span><span class="n">singlethread</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ordering</span><span class="o">&gt;</span>                   <span class="p">;</span> <span class="n">yields</span> <span class="n">void</span>
</pre></div>
</div>
</div>
<div class="section" id="id196">
<h5><a class="toc-backref" href="#id1004">Overview:</a><a class="headerlink" href="#id196" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; instruction is used to introduce happens-before edges
between operations.</p>
</div>
<div class="section" id="id197">
<h5><a class="toc-backref" href="#id1005">Arguments:</a><a class="headerlink" href="#id197" title="永久链接至标题">¶</a></h5>
<p>&#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; instructions take an <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> argument which
defines what <em>synchronizes-with</em> edges they add. They can only be given
<code class="docutils literal"><span class="pre">acquire</span></code>, <code class="docutils literal"><span class="pre">release</span></code>, <code class="docutils literal"><span class="pre">acq_rel</span></code>, and <code class="docutils literal"><span class="pre">seq_cst</span></code> orderings.</p>
</div>
<div class="section" id="id198">
<h5><a class="toc-backref" href="#id1006">Semantics:</a><a class="headerlink" href="#id198" title="永久链接至标题">¶</a></h5>
<p>A fence A which has (at least) <code class="docutils literal"><span class="pre">release</span></code> ordering semantics
<em>synchronizes with</em> a fence B with (at least) <code class="docutils literal"><span class="pre">acquire</span></code> ordering
semantics if and only if there exist atomic operations X and Y, both
operating on some atomic object M, such that A is sequenced before X, X
modifies M (either directly or through some side effect of a sequence
headed by X), Y is sequenced before B, and Y observes M. This provides a
<em>happens-before</em> dependency between A and B. Rather than an explicit
<code class="docutils literal"><span class="pre">fence</span></code>, one (but not both) of the atomic operations X or Y might
provide a <code class="docutils literal"><span class="pre">release</span></code> or <code class="docutils literal"><span class="pre">acquire</span></code> (resp.) ordering constraint and
still <em>synchronize-with</em> the explicit <code class="docutils literal"><span class="pre">fence</span></code> and establish the
<em>happens-before</em> edge.</p>
<p>A <code class="docutils literal"><span class="pre">fence</span></code> which has <code class="docutils literal"><span class="pre">seq_cst</span></code> ordering, in addition to having both
<code class="docutils literal"><span class="pre">acquire</span></code> and <code class="docutils literal"><span class="pre">release</span></code> semantics specified above, participates in
the global program order of other <code class="docutils literal"><span class="pre">seq_cst</span></code> operations and/or fences.</p>
<p>The optional &#8220;<a class="reference internal" href="#singlethread"><span class="std std-ref">singlethread</span></a>&#8221; argument specifies
that the fence only synchronizes with other fences in the same thread.
(This is useful for interacting with signal handlers.)</p>
</div>
<div class="section" id="id199">
<h5><a class="toc-backref" href="#id1007">Example:</a><a class="headerlink" href="#id199" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">fence</span> <span class="k">acquire</span>                          <span class="c">; yields void</span>
<span class="k">fence</span> <span class="k">singlethread</span> <span class="k">seq_cst</span>             <span class="c">; yields void</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cmpxchg-instruction">
<span id="i-cmpxchg"></span><h4><a class="toc-backref" href="#id1008">&#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; Instruction</a><a class="headerlink" href="#cmpxchg-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id200">
<h5><a class="toc-backref" href="#id1009">Syntax:</a><a class="headerlink" href="#id200" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cmpxchg</span> <span class="p">[</span><span class="n">weak</span><span class="p">]</span> <span class="p">[</span><span class="n">volatile</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nb">cmp</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">new</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">singlethread</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">success</span> <span class="n">ordering</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">failure</span> <span class="n">ordering</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">yields</span>  <span class="p">{</span> <span class="n">ty</span><span class="p">,</span> <span class="n">i1</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id201">
<h5><a class="toc-backref" href="#id1010">Overview:</a><a class="headerlink" href="#id201" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; instruction is used to atomically modify memory. It
loads a value in memory and compares it to a given value. If they are
equal, it tries to store a new value into the memory.</p>
</div>
<div class="section" id="id202">
<h5><a class="toc-backref" href="#id1011">Arguments:</a><a class="headerlink" href="#id202" title="永久链接至标题">¶</a></h5>
<p>There are three arguments to the &#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; instruction: an address
to operate on, a value to compare to the value currently be at that
address, and a new value to place at that address if the compared values
are equal. The type of &#8216;&lt;cmp&gt;&#8217; must be an integer type whose bit width
is a power of two greater than or equal to eight and less than or equal
to a target-specific size limit. &#8216;&lt;cmp&gt;&#8217; and &#8216;&lt;new&gt;&#8217; must have the same
type, and the type of &#8216;&lt;pointer&gt;&#8217; must be a pointer to that type. If the
<code class="docutils literal"><span class="pre">cmpxchg</span></code> is marked as <code class="docutils literal"><span class="pre">volatile</span></code>, then the optimizer is not allowed
to modify the number or order of execution of this <code class="docutils literal"><span class="pre">cmpxchg</span></code> with
other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operations</span></a>.</p>
<p>The success and failure <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> arguments specify how this
<code class="docutils literal"><span class="pre">cmpxchg</span></code> synchronizes with other atomic operations. Both ordering parameters
must be at least <code class="docutils literal"><span class="pre">monotonic</span></code>, the ordering constraint on failure must be no
stronger than that on success, and the failure ordering cannot be either
<code class="docutils literal"><span class="pre">release</span></code> or <code class="docutils literal"><span class="pre">acq_rel</span></code>.</p>
<p>The optional &#8220;<code class="docutils literal"><span class="pre">singlethread</span></code>&#8221; argument declares that the <code class="docutils literal"><span class="pre">cmpxchg</span></code>
is only atomic with respect to code (usually signal handlers) running in
the same thread as the <code class="docutils literal"><span class="pre">cmpxchg</span></code>. Otherwise the cmpxchg is atomic with
respect to all other code in the system.</p>
<p>The pointer passed into cmpxchg must have alignment greater than or
equal to the size in memory of the operand.</p>
</div>
<div class="section" id="id203">
<h5><a class="toc-backref" href="#id1012">Semantics:</a><a class="headerlink" href="#id203" title="永久链接至标题">¶</a></h5>
<p>The contents of memory at the location specified by the &#8216;<code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>&#8216; operand
is read and compared to &#8216;<code class="docutils literal"><span class="pre">&lt;cmp&gt;</span></code>&#8216;; if the read value is the equal, the
&#8216;<code class="docutils literal"><span class="pre">&lt;new&gt;</span></code>&#8216; is written. The original value at the location is returned, together
with a flag indicating success (true) or failure (false).</p>
<p>If the cmpxchg operation is marked as <code class="docutils literal"><span class="pre">weak</span></code> then a spurious failure is
permitted: the operation may not write <code class="docutils literal"><span class="pre">&lt;new&gt;</span></code> even if the comparison
matched.</p>
<p>If the cmpxchg operation is strong (the default), the i1 value is 1 if and only
if the value loaded equals <code class="docutils literal"><span class="pre">cmp</span></code>.</p>
<p>A successful <code class="docutils literal"><span class="pre">cmpxchg</span></code> is a read-modify-write instruction for the purpose of
identifying release sequences. A failed <code class="docutils literal"><span class="pre">cmpxchg</span></code> is equivalent to an atomic
load with an ordering parameter determined the second ordering parameter.</p>
</div>
<div class="section" id="id204">
<h5><a class="toc-backref" href="#id1013">Example:</a><a class="headerlink" href="#id204" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
  <span class="nv">%orig</span> <span class="p">=</span> <span class="k">atomic</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span> <span class="k">unordered</span>                <span class="c">; yields i32</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%cmp</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%orig</span><span class="p">,</span> <span class="nv">%entry</span> <span class="p">],</span> <span class="p">[</span><span class="nv">%old</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%squared</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="nv">%cmp</span>
  <span class="nv">%val_success</span> <span class="p">=</span> <span class="k">cmpxchg</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%squared</span> <span class="k">acq_rel</span> <span class="k">monotonic</span> <span class="c">; yields  { i32, i1 }</span>
  <span class="nv">%value_loaded</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i1</span> <span class="p">}</span> <span class="nv">%val_success</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%success</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i1</span> <span class="p">}</span> <span class="nv">%val_success</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%success</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">done:</span>
  <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="atomicrmw-instruction">
<span id="i-atomicrmw"></span><h4><a class="toc-backref" href="#id1014">&#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; Instruction</a><a class="headerlink" href="#atomicrmw-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id205">
<h5><a class="toc-backref" href="#id1015">Syntax:</a><a class="headerlink" href="#id205" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">atomicrmw</span> <span class="p">[</span><span class="n">volatile</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">operation</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">singlethread</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ordering</span><span class="o">&gt;</span>                   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span>
</pre></div>
</div>
</div>
<div class="section" id="id206">
<h5><a class="toc-backref" href="#id1016">Overview:</a><a class="headerlink" href="#id206" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; instruction is used to atomically modify memory.</p>
</div>
<div class="section" id="id207">
<h5><a class="toc-backref" href="#id1017">Arguments:</a><a class="headerlink" href="#id207" title="永久链接至标题">¶</a></h5>
<p>There are three arguments to the &#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; instruction: an
operation to apply, an address whose value to modify, an argument to the
operation. The operation must be one of the following keywords:</p>
<ul class="simple">
<li>xchg</li>
<li>add</li>
<li>sub</li>
<li>and</li>
<li>nand</li>
<li>or</li>
<li>xor</li>
<li>max</li>
<li>min</li>
<li>umax</li>
<li>umin</li>
</ul>
<p>The type of &#8216;&lt;value&gt;&#8217; must be an integer type whose bit width is a power
of two greater than or equal to eight and less than or equal to a
target-specific size limit. The type of the &#8216;<code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>&#8216; operand must
be a pointer to that type. If the <code class="docutils literal"><span class="pre">atomicrmw</span></code> is marked as
<code class="docutils literal"><span class="pre">volatile</span></code>, then the optimizer is not allowed to modify the number or
order of execution of this <code class="docutils literal"><span class="pre">atomicrmw</span></code> with other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.</p>
</div>
<div class="section" id="id208">
<h5><a class="toc-backref" href="#id1018">Semantics:</a><a class="headerlink" href="#id208" title="永久链接至标题">¶</a></h5>
<p>The contents of memory at the location specified by the &#8216;<code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>&#8216;
operand are atomically read, modified, and written back. The original
value at the location is returned. The modification is specified by the
operation argument:</p>
<ul class="simple">
<li>xchg: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">val</span></code></li>
<li>add: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">+</span> <span class="pre">val</span></code></li>
<li>sub: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">-</span> <span class="pre">val</span></code></li>
<li>and: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&amp;</span> <span class="pre">val</span></code></li>
<li>nand: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(*ptr</span> <span class="pre">&amp;</span> <span class="pre">val)</span></code></li>
<li>or: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">|</span> <span class="pre">val</span></code></li>
<li>xor: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">^</span> <span class="pre">val</span></code></li>
<li>max: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&gt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using a signed comparison)</li>
<li>min: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&lt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using a signed comparison)</li>
<li>umax: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&gt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using an unsigned
comparison)</li>
<li>umin: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&lt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using an unsigned
comparison)</li>
</ul>
</div>
<div class="section" id="id209">
<h5><a class="toc-backref" href="#id1019">Example:</a><a class="headerlink" href="#id209" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%old</span> <span class="p">=</span> <span class="k">atomicrmw</span> <span class="k">add</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span> <span class="k">acquire</span>                        <span class="c">; yields i32</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="getelementptr-instruction">
<span id="i-getelementptr"></span><h4><a class="toc-backref" href="#id1020">&#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; Instruction</a><a class="headerlink" href="#getelementptr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id210">
<h5><a class="toc-backref" href="#id1021">Syntax:</a><a class="headerlink" href="#id210" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="n">inbounds</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ptr</span> <span class="n">vector</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">vector</span> <span class="n">index</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id211">
<h5><a class="toc-backref" href="#id1022">Overview:</a><a class="headerlink" href="#id211" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction is used to get the address of a
subelement of an <a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> data structure. It performs
address calculation only and does not access memory. The instruction can also
be used to calculate a vector of such addresses.</p>
</div>
<div class="section" id="id212">
<h5><a class="toc-backref" href="#id1023">Arguments:</a><a class="headerlink" href="#id212" title="永久链接至标题">¶</a></h5>
<p>The first argument is always a type used as the basis for the calculations.
The second argument is always a pointer or a vector of pointers, and is the
base address to start from. The remaining arguments are indices
that indicate which of the elements of the aggregate object are indexed.
The interpretation of each index is dependent on the type being indexed
into. The first index always indexes the pointer value given as the
first argument, the second index indexes a value of the type pointed to
(not necessarily the value directly pointed to, since the first index
can be non-zero), etc. The first type indexed into must be a pointer
value, subsequent types can be arrays, vectors, and structs. Note that
subsequent types being indexed into can never be pointers, since that
would require loading the pointer before continuing calculation.</p>
<p>The type of each index argument depends on the type it is indexing into.
When indexing into a (optionally packed) structure, only <code class="docutils literal"><span class="pre">i32</span></code> integer
<strong>constants</strong> are allowed (when using a vector of indices they must all
be the <strong>same</strong> <code class="docutils literal"><span class="pre">i32</span></code> integer constant). When indexing into an array,
pointer or vector, integers of any width are allowed, and they are not
required to be constant. These integers are treated as signed values
where relevant.</p>
<p>For example, let&#8217;s consider a C code fragment and how it gets compiled
to LLVM:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RT</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">A</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">C</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ST</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">Y</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">RT</span> <span class="n">Z</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="o">*</span><span class="nf">foo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ST</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Z</span><span class="p">.</span><span class="n">B</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">13</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The LLVM code generated by Clang is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%struct.RT</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i8</span><span class="p">,</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]],</span> <span class="k">i8</span> <span class="p">}</span>
<span class="nv">%struct.ST</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="nv">%struct.RT</span> <span class="p">}</span>

<span class="k">define</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@foo</span><span class="p">(</span><span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">)</span> <span class="k">nounwind</span> <span class="k">uwtable</span> <span class="k">readnone</span> <span class="k">optsize</span> <span class="k">ssp</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%arrayidx</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%struct.ST</span><span class="p">,</span> <span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">,</span> <span class="k">i64</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i64</span> <span class="m">5</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span>
  <span class="k">ret</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id213">
<h5><a class="toc-backref" href="#id1024">Semantics:</a><a class="headerlink" href="#id213" title="永久链接至标题">¶</a></h5>
<p>In the example above, the first index is indexing into the
&#8216;<code class="docutils literal"><span class="pre">%struct.ST*</span></code>&#8216; type, which is a pointer, yielding a &#8216;<code class="docutils literal"><span class="pre">%struct.ST</span></code>&#8216;
= &#8216;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i32,</span> <span class="pre">double,</span> <span class="pre">%struct.RT</span> <span class="pre">}</span></code>&#8216; type, a structure. The second index
indexes into the third element of the structure, yielding a
&#8216;<code class="docutils literal"><span class="pre">%struct.RT</span></code>&#8216; = &#8216;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i8</span> <span class="pre">,</span> <span class="pre">[10</span> <span class="pre">x</span> <span class="pre">[20</span> <span class="pre">x</span> <span class="pre">i32]],</span> <span class="pre">i8</span> <span class="pre">}</span></code>&#8216; type, another
structure. The third index indexes into the second element of the
structure, yielding a &#8216;<code class="docutils literal"><span class="pre">[10</span> <span class="pre">x</span> <span class="pre">[20</span> <span class="pre">x</span> <span class="pre">i32]]</span></code>&#8216; type, an array. The two
dimensions of the array are subscripted into, yielding an &#8216;<code class="docutils literal"><span class="pre">i32</span></code>&#8216;
type. The &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction returns a pointer to this
element, thus computing a value of &#8216;<code class="docutils literal"><span class="pre">i32*</span></code>&#8216; type.</p>
<p>Note that it is perfectly legal to index partially through a structure,
returning a pointer to an inner element. Because of this, the LLVM code
for the given testcase is equivalent to:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@foo</span><span class="p">(</span><span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%t1</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%struct.ST</span><span class="p">,</span> <span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>                        <span class="c">; yields %struct.ST*:%t1</span>
  <span class="nv">%t2</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%struct.ST</span><span class="p">,</span> <span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%t1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span>                <span class="c">; yields %struct.RT*:%t2</span>
  <span class="nv">%t3</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%struct.RT</span><span class="p">,</span> <span class="nv">%struct.RT</span><span class="p">*</span> <span class="nv">%t2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>                <span class="c">; yields [10 x [20 x i32]]*:%t3</span>
  <span class="nv">%t4</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]],</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]]*</span> <span class="nv">%t3</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">5</span>  <span class="c">; yields [20 x i32]*:%t4</span>
  <span class="nv">%t5</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">],</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]*</span> <span class="nv">%t4</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">13</span>               <span class="c">; yields i32*:%t5</span>
  <span class="k">ret</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%t5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal"><span class="pre">inbounds</span></code> keyword is present, the result value of the
<code class="docutils literal"><span class="pre">getelementptr</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if the base
pointer is not an <em>in bounds</em> address of an allocated object, or if any
of the addresses that would be formed by successive addition of the
offsets implied by the indices to the base address with infinitely
precise signed arithmetic are not an <em>in bounds</em> address of that
allocated object. The <em>in bounds</em> addresses for an allocated object are
all the addresses that point into the object, plus the address one byte
past the end. In cases where the base is a vector of pointers the
<code class="docutils literal"><span class="pre">inbounds</span></code> keyword applies to each of the computations element-wise.</p>
<p>If the <code class="docutils literal"><span class="pre">inbounds</span></code> keyword is not present, the offsets are added to the
base address with silently-wrapping two&#8217;s complement arithmetic. If the
offsets have a different width from the pointer, they are sign-extended
or truncated to the width of the pointer. The result value of the
<code class="docutils literal"><span class="pre">getelementptr</span></code> may be outside the object pointed to by the base
pointer. The result value may not necessarily be used to access memory
though, even if it happens to point into allocated storage. See the
<a class="reference internal" href="#pointeraliasing"><span class="std std-ref">Pointer Aliasing Rules</span></a> section for more
information.</p>
<p>The getelementptr instruction is often confusing. For some more insight
into how it works, see <a class="reference internal" href="GetElementPtr.html"><span class="doc">the getelementptr FAQ</span></a>.</p>
</div>
<div class="section" id="id214">
<h5><a class="toc-backref" href="#id1025">Example:</a><a class="headerlink" href="#id214" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; yields [12 x i8]*:aptr</span>
<span class="nv">%aptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]},</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]}*</span> <span class="nv">%saptr</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
<span class="c">; yields i8*:vptr</span>
<span class="nv">%vptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;},</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;}*</span> <span class="nv">%svptr</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
<span class="c">; yields i8*:eptr</span>
<span class="nv">%eptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="nv">%aptr</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
<span class="c">; yields i32*:iptr</span>
<span class="nv">%iptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i32</span><span class="p">],</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]*</span> <span class="vg">@arr</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span>
</pre></div>
</div>
</div>
<div class="section" id="vector-of-pointers">
<h5><a class="toc-backref" href="#id1026">Vector of pointers:</a><a class="headerlink" href="#vector-of-pointers" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">getelementptr</span></code> returns a vector of pointers, instead of a single address,
when one or more of its arguments is a vector. In such cases, all vector
arguments should have the same number of elements, and every scalar argument
will be effectively broadcast into a vector during address calculation.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; All arguments are vectors:</span>
<span class="c">;   A[i] = ptrs[i] + offsets[i]*sizeof(i8)</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i8</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*&gt;</span> <span class="nv">%ptrs</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%offsets</span>

<span class="c">; Add the same scalar offset to each pointer of a vector:</span>
<span class="c">;   A[i] = ptrs[i] + offset*sizeof(i8)</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i8</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*&gt;</span> <span class="nv">%ptrs</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%offset</span>

<span class="c">; Add distinct offsets to the same pointer:</span>
<span class="c">;   A[i] = ptr + offsets[i]*sizeof(i8)</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%offsets</span>

<span class="c">; In all cases described above the type of the result is &lt;4 x i8*&gt;</span>
</pre></div>
</div>
<p>The two following instructions are equivalent:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">getelementptr</span>  <span class="nv">%struct.ST</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="nv">%struct.ST</span><span class="p">*&gt;</span> <span class="nv">%s</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%ind1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">&gt;,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">&gt;,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%ind4</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i64</span> <span class="m">13</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span><span class="p">&gt;</span>

<span class="k">getelementptr</span>  <span class="nv">%struct.ST</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="nv">%struct.ST</span><span class="p">*&gt;</span> <span class="nv">%s</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%ind1</span><span class="p">,</span>
  <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%ind4</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span>
</pre></div>
</div>
<p>Let&#8217;s look at the C code, where the vector version of <code class="docutils literal"><span class="pre">getelementptr</span></code>
makes sense:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Let&#39;s assume that we vectorize the following loop:</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">;</span> <span class="kt">int</span> <span class="o">*</span><span class="n">C</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; get pointers for 8 elements from array B</span>
<span class="nv">%ptrs</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">*</span> <span class="nv">%B</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%C</span>
<span class="c">; load 8 elements from array B into A</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="kt">double</span><span class="p">&gt;</span> <span class="vg">@llvm.masked.gather.v8f64</span><span class="p">(&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="kt">double</span><span class="p">*&gt;</span> <span class="nv">%ptrs</span><span class="p">,</span>
     <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="k">i1</span><span class="p">&gt;</span> <span class="nv">%mask</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="kt">double</span><span class="p">&gt;</span> <span class="nv">%passthru</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="conversion-operations">
<h3><a class="toc-backref" href="#id1027">Conversion Operations</a><a class="headerlink" href="#conversion-operations" title="永久链接至标题">¶</a></h3>
<p>The instructions in this category are the conversion instructions
(casting) which all take a single operand and a type. They perform
various bit conversions on the operand.</p>
<div class="section" id="trunc-to-instruction">
<h4><a class="toc-backref" href="#id1028">&#8216;<code class="docutils literal"><span class="pre">trunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#trunc-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id215">
<h5><a class="toc-backref" href="#id1029">Syntax:</a><a class="headerlink" href="#id215" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">trunc</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id216">
<h5><a class="toc-backref" href="#id1030">Overview:</a><a class="headerlink" href="#id216" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">trunc</span></code>&#8216; instruction truncates its operand to the type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id217">
<h5><a class="toc-backref" href="#id1031">Arguments:</a><a class="headerlink" href="#id217" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">trunc</span></code>&#8216; instruction takes a value to trunc, and a type to trunc
it to. Both types must be of <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> types, or vectors
of the same number of integers. The bit size of the <code class="docutils literal"><span class="pre">value</span></code> must be
larger than the bit size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>. Equal sized
types are not allowed.</p>
</div>
<div class="section" id="id218">
<h5><a class="toc-backref" href="#id1032">Semantics:</a><a class="headerlink" href="#id218" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">trunc</span></code>&#8216; instruction truncates the high order bits in <code class="docutils literal"><span class="pre">value</span></code>
and converts the remaining bits to <code class="docutils literal"><span class="pre">ty2</span></code>. Since the source size must
be larger than the destination size, <code class="docutils literal"><span class="pre">trunc</span></code> cannot be a <em>no-op cast</em>.
It will always truncate bits.</p>
</div>
<div class="section" id="id219">
<h5><a class="toc-backref" href="#id1033">Example:</a><a class="headerlink" href="#id219" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">trunc</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="k">i8</span>                        <span class="c">; yields i8:1</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">trunc</span> <span class="k">i32</span> <span class="m">123</span> <span class="k">to</span> <span class="k">i1</span>                        <span class="c">; yields i1:true</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">trunc</span> <span class="k">i32</span> <span class="m">122</span> <span class="k">to</span> <span class="k">i1</span>                        <span class="c">; yields i1:false</span>
<span class="nv">%W</span> <span class="p">=</span> <span class="k">trunc</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i16</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i16</span> <span class="m">8</span><span class="p">,</span> <span class="k">i16</span> <span class="m">7</span><span class="p">&gt;</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="c">; yields &lt;i8 8, i8 7&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="zext-to-instruction">
<h4><a class="toc-backref" href="#id1034">&#8216;<code class="docutils literal"><span class="pre">zext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#zext-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id220">
<h5><a class="toc-backref" href="#id1035">Syntax:</a><a class="headerlink" href="#id220" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">zext</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id221">
<h5><a class="toc-backref" href="#id1036">Overview:</a><a class="headerlink" href="#id221" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">zext</span></code>&#8216; instruction zero extends its operand to type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id222">
<h5><a class="toc-backref" href="#id1037">Arguments:</a><a class="headerlink" href="#id222" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">zext</span></code>&#8216; instruction takes a value to cast, and a type to cast it
to. Both types must be of <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> types, or vectors of
the same number of integers. The bit size of the <code class="docutils literal"><span class="pre">value</span></code> must be
smaller than the bit size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id223">
<h5><a class="toc-backref" href="#id1038">Semantics:</a><a class="headerlink" href="#id223" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">zext</span></code> fills the high order bits of the <code class="docutils literal"><span class="pre">value</span></code> with zero bits
until it reaches the size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
<p>When zero extending from i1, the result will always be either 0 or 1.</p>
</div>
<div class="section" id="id224">
<h5><a class="toc-backref" href="#id1039">Example:</a><a class="headerlink" href="#id224" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">zext</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="k">i64</span>              <span class="c">; yields i64:257</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">zext</span> <span class="k">i1</span> <span class="k">true</span> <span class="k">to</span> <span class="k">i32</span>              <span class="c">; yields i32:1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">zext</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i16</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i16</span> <span class="m">8</span><span class="p">,</span> <span class="k">i16</span> <span class="m">7</span><span class="p">&gt;</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="c">; yields &lt;i32 8, i32 7&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sext-to-instruction">
<h4><a class="toc-backref" href="#id1040">&#8216;<code class="docutils literal"><span class="pre">sext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#sext-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id225">
<h5><a class="toc-backref" href="#id1041">Syntax:</a><a class="headerlink" href="#id225" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sext</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id226">
<h5><a class="toc-backref" href="#id1042">Overview:</a><a class="headerlink" href="#id226" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sext</span></code>&#8216; sign extends <code class="docutils literal"><span class="pre">value</span></code> to the type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id227">
<h5><a class="toc-backref" href="#id1043">Arguments:</a><a class="headerlink" href="#id227" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sext</span></code>&#8216; instruction takes a value to cast, and a type to cast it
to. Both types must be of <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> types, or vectors of
the same number of integers. The bit size of the <code class="docutils literal"><span class="pre">value</span></code> must be
smaller than the bit size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id228">
<h5><a class="toc-backref" href="#id1044">Semantics:</a><a class="headerlink" href="#id228" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sext</span></code>&#8216; instruction performs a sign extension by copying the sign
bit (highest order bit) of the <code class="docutils literal"><span class="pre">value</span></code> until it reaches the bit size
of the type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
<p>When sign extending from i1, the extension always results in -1 or 0.</p>
</div>
<div class="section" id="id229">
<h5><a class="toc-backref" href="#id1045">Example:</a><a class="headerlink" href="#id229" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">sext</span> <span class="k">i8</span>  <span class="m">-1</span> <span class="k">to</span> <span class="k">i16</span>              <span class="c">; yields i16   :65535</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">sext</span> <span class="k">i1</span> <span class="k">true</span> <span class="k">to</span> <span class="k">i32</span>             <span class="c">; yields i32:-1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">sext</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i16</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i16</span> <span class="m">8</span><span class="p">,</span> <span class="k">i16</span> <span class="m">7</span><span class="p">&gt;</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="c">; yields &lt;i32 8, i32 7&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fptrunc-to-instruction">
<h4><a class="toc-backref" href="#id1046">&#8216;<code class="docutils literal"><span class="pre">fptrunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fptrunc-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id230">
<h5><a class="toc-backref" href="#id1047">Syntax:</a><a class="headerlink" href="#id230" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fptrunc</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id231">
<h5><a class="toc-backref" href="#id1048">Overview:</a><a class="headerlink" href="#id231" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptrunc</span></code>&#8216; instruction truncates <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id232">
<h5><a class="toc-backref" href="#id1049">Arguments:</a><a class="headerlink" href="#id232" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptrunc</span></code>&#8216; instruction takes a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a>
value to cast and a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to cast it to.
The size of <code class="docutils literal"><span class="pre">value</span></code> must be larger than the size of <code class="docutils literal"><span class="pre">ty2</span></code>. This
implies that <code class="docutils literal"><span class="pre">fptrunc</span></code> cannot be used to make a <em>no-op cast</em>.</p>
</div>
<div class="section" id="id233">
<h5><a class="toc-backref" href="#id1050">Semantics:</a><a class="headerlink" href="#id233" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptrunc</span></code>&#8216; instruction casts a <code class="docutils literal"><span class="pre">value</span></code> from a larger
<a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to a smaller <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type. If the value cannot fit (i.e. overflows) within the
destination type, <code class="docutils literal"><span class="pre">ty2</span></code>, then the results are undefined. If the cast produces
an inexact result, how rounding is performed (e.g. truncation, also known as
round to zero) is undefined.</p>
</div>
<div class="section" id="id234">
<h5><a class="toc-backref" href="#id1051">Example:</a><a class="headerlink" href="#id234" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fptrunc</span> <span class="kt">double</span> <span class="m">123.0</span> <span class="k">to</span> <span class="kt">float</span>         <span class="c">; yields float:123.0</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fptrunc</span> <span class="kt">double</span> <span class="m">1.0E+300</span> <span class="k">to</span> <span class="kt">float</span>      <span class="c">; yields undefined</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fpext-to-instruction">
<h4><a class="toc-backref" href="#id1052">&#8216;<code class="docutils literal"><span class="pre">fpext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fpext-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id235">
<h5><a class="toc-backref" href="#id1053">Syntax:</a><a class="headerlink" href="#id235" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fpext</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id236">
<h5><a class="toc-backref" href="#id1054">Overview:</a><a class="headerlink" href="#id236" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fpext</span></code>&#8216; extends a floating point <code class="docutils literal"><span class="pre">value</span></code> to a larger floating
point value.</p>
</div>
<div class="section" id="id237">
<h5><a class="toc-backref" href="#id1055">Arguments:</a><a class="headerlink" href="#id237" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fpext</span></code>&#8216; instruction takes a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a>
<code class="docutils literal"><span class="pre">value</span></code> to cast, and a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to cast it
to. The source type must be smaller than the destination type.</p>
</div>
<div class="section" id="id238">
<h5><a class="toc-backref" href="#id1056">Semantics:</a><a class="headerlink" href="#id238" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fpext</span></code>&#8216; instruction extends the <code class="docutils literal"><span class="pre">value</span></code> from a smaller
<a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to a larger <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type. The <code class="docutils literal"><span class="pre">fpext</span></code> cannot be used to make a
<em>no-op cast</em> because it always changes bits. Use <code class="docutils literal"><span class="pre">bitcast</span></code> to make a
<em>no-op cast</em> for a floating point cast.</p>
</div>
<div class="section" id="id239">
<h5><a class="toc-backref" href="#id1057">Example:</a><a class="headerlink" href="#id239" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fpext</span> <span class="kt">float</span> <span class="m">3.125</span> <span class="k">to</span> <span class="kt">double</span>         <span class="c">; yields double:3.125000e+00</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fpext</span> <span class="kt">double</span> <span class="nv">%X</span> <span class="k">to</span> <span class="kt">fp128</span>            <span class="c">; yields fp128:0xL00000000000000004000900000000000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fptoui-to-instruction">
<h4><a class="toc-backref" href="#id1058">&#8216;<code class="docutils literal"><span class="pre">fptoui</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fptoui-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id240">
<h5><a class="toc-backref" href="#id1059">Syntax:</a><a class="headerlink" href="#id240" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fptoui</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id241">
<h5><a class="toc-backref" href="#id1060">Overview:</a><a class="headerlink" href="#id241" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptoui</span></code>&#8216; converts a floating point <code class="docutils literal"><span class="pre">value</span></code> to its unsigned
integer equivalent of type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id242">
<h5><a class="toc-backref" href="#id1061">Arguments:</a><a class="headerlink" href="#id242" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptoui</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> value, and a type to
cast it to <code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector floating point type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector integer
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id243">
<h5><a class="toc-backref" href="#id1062">Semantics:</a><a class="headerlink" href="#id243" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptoui</span></code>&#8216; instruction converts its <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> operand into the nearest (rounding towards zero)
unsigned integer value. If the value cannot fit in <code class="docutils literal"><span class="pre">ty2</span></code>, the results
are undefined.</p>
</div>
<div class="section" id="id244">
<h5><a class="toc-backref" href="#id1063">Example:</a><a class="headerlink" href="#id244" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fptoui</span> <span class="kt">double</span> <span class="m">123.0</span> <span class="k">to</span> <span class="k">i32</span>      <span class="c">; yields i32:123</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fptoui</span> <span class="kt">float</span> <span class="m">1.0E+300</span> <span class="k">to</span> <span class="k">i1</span>     <span class="c">; yields undefined:1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">fptoui</span> <span class="kt">float</span> <span class="m">1.04E+17</span> <span class="k">to</span> <span class="k">i8</span>     <span class="c">; yields undefined:1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fptosi-to-instruction">
<h4><a class="toc-backref" href="#id1064">&#8216;<code class="docutils literal"><span class="pre">fptosi</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fptosi-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id245">
<h5><a class="toc-backref" href="#id1065">Syntax:</a><a class="headerlink" href="#id245" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fptosi</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id246">
<h5><a class="toc-backref" href="#id1066">Overview:</a><a class="headerlink" href="#id246" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptosi</span></code>&#8216; instruction converts <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a>
<code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id247">
<h5><a class="toc-backref" href="#id1067">Arguments:</a><a class="headerlink" href="#id247" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptosi</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> value, and a type to
cast it to <code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector floating point type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector integer
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id248">
<h5><a class="toc-backref" href="#id1068">Semantics:</a><a class="headerlink" href="#id248" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptosi</span></code>&#8216; instruction converts its <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> operand into the nearest (rounding towards zero)
signed integer value. If the value cannot fit in <code class="docutils literal"><span class="pre">ty2</span></code>, the results
are undefined.</p>
</div>
<div class="section" id="id249">
<h5><a class="toc-backref" href="#id1069">Example:</a><a class="headerlink" href="#id249" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fptosi</span> <span class="kt">double</span> <span class="m">-123.0</span> <span class="k">to</span> <span class="k">i32</span>      <span class="c">; yields i32:-123</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fptosi</span> <span class="kt">float</span> <span class="m">1.0E-247</span> <span class="k">to</span> <span class="k">i1</span>      <span class="c">; yields undefined:1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">fptosi</span> <span class="kt">float</span> <span class="m">1.04E+17</span> <span class="k">to</span> <span class="k">i8</span>      <span class="c">; yields undefined:1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="uitofp-to-instruction">
<h4><a class="toc-backref" href="#id1070">&#8216;<code class="docutils literal"><span class="pre">uitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#uitofp-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id250">
<h5><a class="toc-backref" href="#id1071">Syntax:</a><a class="headerlink" href="#id250" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">uitofp</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id251">
<h5><a class="toc-backref" href="#id1072">Overview:</a><a class="headerlink" href="#id251" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">uitofp</span></code>&#8216; instruction regards <code class="docutils literal"><span class="pre">value</span></code> as an unsigned integer
and converts that value to the <code class="docutils literal"><span class="pre">ty2</span></code> type.</p>
</div>
<div class="section" id="id252">
<h5><a class="toc-backref" href="#id1073">Arguments:</a><a class="headerlink" href="#id252" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">uitofp</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> value, and a type to cast it to
<code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector integer type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector floating point
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id253">
<h5><a class="toc-backref" href="#id1074">Semantics:</a><a class="headerlink" href="#id253" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">uitofp</span></code>&#8216; instruction interprets its operand as an unsigned
integer quantity and converts it to the corresponding floating point
value. If the value cannot fit in the floating point value, the results
are undefined.</p>
</div>
<div class="section" id="id254">
<h5><a class="toc-backref" href="#id1075">Example:</a><a class="headerlink" href="#id254" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="kt">float</span>         <span class="c">; yields float:257.0</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i8</span> <span class="m">-1</span> <span class="k">to</span> <span class="kt">double</span>          <span class="c">; yields double:255.0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sitofp-to-instruction">
<h4><a class="toc-backref" href="#id1076">&#8216;<code class="docutils literal"><span class="pre">sitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#sitofp-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id255">
<h5><a class="toc-backref" href="#id1077">Syntax:</a><a class="headerlink" href="#id255" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sitofp</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id256">
<h5><a class="toc-backref" href="#id1078">Overview:</a><a class="headerlink" href="#id256" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sitofp</span></code>&#8216; instruction regards <code class="docutils literal"><span class="pre">value</span></code> as a signed integer and
converts that value to the <code class="docutils literal"><span class="pre">ty2</span></code> type.</p>
</div>
<div class="section" id="id257">
<h5><a class="toc-backref" href="#id1079">Arguments:</a><a class="headerlink" href="#id257" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sitofp</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> value, and a type to cast it to
<code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector integer type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector floating point
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id258">
<h5><a class="toc-backref" href="#id1080">Semantics:</a><a class="headerlink" href="#id258" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sitofp</span></code>&#8216; instruction interprets its operand as a signed integer
quantity and converts it to the corresponding floating point value. If
the value cannot fit in the floating point value, the results are
undefined.</p>
</div>
<div class="section" id="id259">
<h5><a class="toc-backref" href="#id1081">Example:</a><a class="headerlink" href="#id259" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">sitofp</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="kt">float</span>         <span class="c">; yields float:257.0</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">sitofp</span> <span class="k">i8</span> <span class="m">-1</span> <span class="k">to</span> <span class="kt">double</span>          <span class="c">; yields double:-1.0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ptrtoint-to-instruction">
<span id="i-ptrtoint"></span><h4><a class="toc-backref" href="#id1082">&#8216;<code class="docutils literal"><span class="pre">ptrtoint</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#ptrtoint-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id260">
<h5><a class="toc-backref" href="#id1083">Syntax:</a><a class="headerlink" href="#id260" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ptrtoint</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id261">
<h5><a class="toc-backref" href="#id1084">Overview:</a><a class="headerlink" href="#id261" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ptrtoint</span></code>&#8216; instruction converts the pointer or a vector of
pointers <code class="docutils literal"><span class="pre">value</span></code> to the integer (or vector of integers) type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id262">
<h5><a class="toc-backref" href="#id1085">Arguments:</a><a class="headerlink" href="#id262" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ptrtoint</span></code>&#8216; instruction takes a <code class="docutils literal"><span class="pre">value</span></code> to cast, which must be
a value of type <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> or a vector of pointers, and a
type to cast it to <code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or
a vector of integers type.</p>
</div>
<div class="section" id="id263">
<h5><a class="toc-backref" href="#id1086">Semantics:</a><a class="headerlink" href="#id263" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ptrtoint</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to integer type
<code class="docutils literal"><span class="pre">ty2</span></code> by interpreting the pointer value as an integer and either
truncating or zero extending that value to the size of the integer type.
If <code class="docutils literal"><span class="pre">value</span></code> is smaller than <code class="docutils literal"><span class="pre">ty2</span></code> then a zero extension is done. If
<code class="docutils literal"><span class="pre">value</span></code> is larger than <code class="docutils literal"><span class="pre">ty2</span></code> then a truncation is done. If they are
the same size, then nothing is done (<em>no-op cast</em>) other than a type
change.</p>
</div>
<div class="section" id="id264">
<h5><a class="toc-backref" href="#id1087">Example:</a><a class="headerlink" href="#id264" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%P</span> <span class="k">to</span> <span class="k">i8</span>                         <span class="c">; yields truncation on 32-bit architecture</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%P</span> <span class="k">to</span> <span class="k">i64</span>                        <span class="c">; yields zero extension on 32-bit architecture</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">*&gt;</span> <span class="nv">%P</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span><span class="c">; yields vector zero extension for a vector of addresses on 32-bit architecture</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="inttoptr-to-instruction">
<span id="i-inttoptr"></span><h4><a class="toc-backref" href="#id1088">&#8216;<code class="docutils literal"><span class="pre">inttoptr</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#inttoptr-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id265">
<h5><a class="toc-backref" href="#id1089">Syntax:</a><a class="headerlink" href="#id265" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">inttoptr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id266">
<h5><a class="toc-backref" href="#id1090">Overview:</a><a class="headerlink" href="#id266" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">inttoptr</span></code>&#8216; instruction converts an integer <code class="docutils literal"><span class="pre">value</span></code> to a
pointer type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id267">
<h5><a class="toc-backref" href="#id1091">Arguments:</a><a class="headerlink" href="#id267" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">inttoptr</span></code>&#8216; instruction takes an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> value to
cast, and a type to cast it to, which must be a <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a>
type.</p>
</div>
<div class="section" id="id268">
<h5><a class="toc-backref" href="#id1092">Semantics:</a><a class="headerlink" href="#id268" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">inttoptr</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code> by
applying either a zero extension or a truncation depending on the size
of the integer <code class="docutils literal"><span class="pre">value</span></code>. If <code class="docutils literal"><span class="pre">value</span></code> is larger than the size of a
pointer then a truncation is done. If <code class="docutils literal"><span class="pre">value</span></code> is smaller than the size
of a pointer then a zero extension is done. If they are the same size,
nothing is done (<em>no-op cast</em>).</p>
</div>
<div class="section" id="id269">
<h5><a class="toc-backref" href="#id1093">Example:</a><a class="headerlink" href="#id269" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i32</span> <span class="m">255</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>          <span class="c">; yields zero extension on 64-bit architecture</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i32</span> <span class="m">255</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>          <span class="c">; yields no-op on 32-bit architecture</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i64</span> <span class="m">0</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>            <span class="c">; yields truncation on 32-bit architecture</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%G</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*&gt;</span><span class="c">; yields truncation of vector G to four pointers</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bitcast-to-instruction">
<span id="i-bitcast"></span><h4><a class="toc-backref" href="#id1094">&#8216;<code class="docutils literal"><span class="pre">bitcast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#bitcast-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id270">
<h5><a class="toc-backref" href="#id1095">Syntax:</a><a class="headerlink" href="#id270" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">bitcast</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id271">
<h5><a class="toc-backref" href="#id1096">Overview:</a><a class="headerlink" href="#id271" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code> without
changing any bits.</p>
</div>
<div class="section" id="id272">
<h5><a class="toc-backref" href="#id1097">Arguments:</a><a class="headerlink" href="#id272" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216; instruction takes a value to cast, which must be a
non-aggregate first class value, and a type to cast it to, which must
also be a non-aggregate <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type. The
bit sizes of <code class="docutils literal"><span class="pre">value</span></code> and the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>, must be
identical. If the source type is a pointer, the destination type must
also be a pointer of the same size. This instruction supports bitwise
conversion of vectors to integers and to vectors of other types (as
long as they have the same size).</p>
</div>
<div class="section" id="id273">
<h5><a class="toc-backref" href="#id1098">Semantics:</a><a class="headerlink" href="#id273" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code>. It
is always a <em>no-op cast</em> because no bits change with this
conversion. The conversion is done as if the <code class="docutils literal"><span class="pre">value</span></code> had been stored
to memory and read back as type <code class="docutils literal"><span class="pre">ty2</span></code>. Pointer (or vector of
pointers) types may only be converted to other pointer (or vector of
pointers) types with the same address space through this instruction.
To convert pointers to other types, use the <a class="reference internal" href="#i-inttoptr"><span class="std std-ref">inttoptr</span></a>
or <a class="reference internal" href="#i-ptrtoint"><span class="std std-ref">ptrtoint</span></a> instructions first.</p>
</div>
<div class="section" id="id274">
<h5><a class="toc-backref" href="#id1099">Example:</a><a class="headerlink" href="#id274" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>%X = bitcast i8 255 to i8              ; yields i8 :-1
%Y = bitcast i32* %x to sint*          ; yields sint*:%x
%Z = bitcast &lt;2 x int&gt; %V to i64;        ; yields i64: %V
%Z = bitcast &lt;2 x i32*&gt; %V to &lt;2 x i64*&gt; ; yields &lt;2 x i64*&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="addrspacecast-to-instruction">
<span id="i-addrspacecast"></span><h4><a class="toc-backref" href="#id1100">&#8216;<code class="docutils literal"><span class="pre">addrspacecast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#addrspacecast-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id275">
<h5><a class="toc-backref" href="#id1101">Syntax:</a><a class="headerlink" href="#id275" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">addrspacecast</span> <span class="o">&lt;</span><span class="n">pty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">pty2</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">yields</span> <span class="n">pty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id276">
<h5><a class="toc-backref" href="#id1102">Overview:</a><a class="headerlink" href="#id276" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">addrspacecast</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">ptrval</span></code> from <code class="docutils literal"><span class="pre">pty</span></code> in
address space <code class="docutils literal"><span class="pre">n</span></code> to type <code class="docutils literal"><span class="pre">pty2</span></code> in address space <code class="docutils literal"><span class="pre">m</span></code>.</p>
</div>
<div class="section" id="id277">
<h5><a class="toc-backref" href="#id1103">Arguments:</a><a class="headerlink" href="#id277" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">addrspacecast</span></code>&#8216; instruction takes a pointer or vector of pointer value
to cast and a pointer type to cast it to, which must have a different
address space.</p>
</div>
<div class="section" id="id278">
<h5><a class="toc-backref" href="#id1104">Semantics:</a><a class="headerlink" href="#id278" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">addrspacecast</span></code>&#8216; instruction converts the pointer value
<code class="docutils literal"><span class="pre">ptrval</span></code> to type <code class="docutils literal"><span class="pre">pty2</span></code>. It can be a <em>no-op cast</em> or a complex
value modification, depending on the target and the address space
pair. Pointer conversions within the same address space must be
performed with the <code class="docutils literal"><span class="pre">bitcast</span></code> instruction. Note that if the address space
conversion is legal then both result and operand refer to the same memory
location.</p>
</div>
<div class="section" id="id279">
<h5><a class="toc-backref" href="#id1105">Example:</a><a class="headerlink" href="#id279" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">addrspacecast</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%x</span> <span class="k">to</span> <span class="k">i32</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)*</span>    <span class="c">; yields i32 addrspace(1)*:%x</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">addrspacecast</span> <span class="k">i32</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)*</span> <span class="nv">%y</span> <span class="k">to</span> <span class="k">i64</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">2</span><span class="p">)*</span>    <span class="c">; yields i64 addrspace(2)*:%y</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">addrspacecast</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">*&gt;</span> <span class="nv">%z</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="kt">float</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)*&gt;</span>   <span class="c">; yields &lt;4 x float addrspace(3)*&gt;:%z</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="other-operations">
<span id="otherops"></span><h3><a class="toc-backref" href="#id1106">Other Operations</a><a class="headerlink" href="#other-operations" title="永久链接至标题">¶</a></h3>
<p>The instructions in this category are the &#8220;miscellaneous&#8221; instructions,
which defy better classification.</p>
<div class="section" id="icmp-instruction">
<span id="i-icmp"></span><h4><a class="toc-backref" href="#id1107">&#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; Instruction</a><a class="headerlink" href="#icmp-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id280">
<h5><a class="toc-backref" href="#id1108">Syntax:</a><a class="headerlink" href="#id280" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">icmp</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">i1</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">N</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id281">
<h5><a class="toc-backref" href="#id1109">Overview:</a><a class="headerlink" href="#id281" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; instruction returns a boolean value or a vector of
boolean values based on comparison of its two integer, integer vector,
pointer, or pointer vector operands.</p>
</div>
<div class="section" id="id282">
<h5><a class="toc-backref" href="#id1110">Arguments:</a><a class="headerlink" href="#id282" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; instruction takes three operands. The first operand is
the condition code indicating the kind of comparison to perform. It is
not a value, just a keyword. The possible condition code are:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">eq</span></code>: equal</li>
<li><code class="docutils literal"><span class="pre">ne</span></code>: not equal</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: unsigned greater than</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: unsigned greater or equal</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: unsigned less than</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: unsigned less or equal</li>
<li><code class="docutils literal"><span class="pre">sgt</span></code>: signed greater than</li>
<li><code class="docutils literal"><span class="pre">sge</span></code>: signed greater or equal</li>
<li><code class="docutils literal"><span class="pre">slt</span></code>: signed less than</li>
<li><code class="docutils literal"><span class="pre">sle</span></code>: signed less or equal</li>
</ol>
<p>The remaining two arguments must be <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or
<a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> or integer <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> typed. They
must also be identical types.</p>
</div>
<div class="section" id="id283">
<h5><a class="toc-backref" href="#id1111">Semantics:</a><a class="headerlink" href="#id283" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; compares <code class="docutils literal"><span class="pre">op1</span></code> and <code class="docutils literal"><span class="pre">op2</span></code> according to the condition
code given as <code class="docutils literal"><span class="pre">cond</span></code>. The comparison performed always yields either an
<a class="reference internal" href="#t-integer"><span class="std std-ref">i1</span></a> or vector of <code class="docutils literal"><span class="pre">i1</span></code> result, as follows:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">eq</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if the operands are equal, <code class="docutils literal"><span class="pre">false</span></code>
otherwise. No sign interpretation is necessary or performed.</li>
<li><code class="docutils literal"><span class="pre">ne</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if the operands are unequal, <code class="docutils literal"><span class="pre">false</span></code>
otherwise. No sign interpretation is necessary or performed.</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sgt</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sge</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">slt</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sle</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
</ol>
<p>If the operands are <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> typed, the pointer values
are compared as if they were integers.</p>
<p>If the operands are integer vectors, then they are compared element by
element. The result is an <code class="docutils literal"><span class="pre">i1</span></code> vector with the same number of elements
as the values being compared. Otherwise, the result is an <code class="docutils literal"><span class="pre">i1</span></code>.</p>
</div>
<div class="section" id="id284">
<h5><a class="toc-backref" href="#id1112">Example:</a><a class="headerlink" href="#id284" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = icmp eq i32 4, 5          ; yields: result=false
&lt;result&gt; = icmp ne float* %X, %X     ; yields: result=false
&lt;result&gt; = icmp ult i16  4, 5        ; yields: result=true
&lt;result&gt; = icmp sgt i16  4, 5        ; yields: result=false
&lt;result&gt; = icmp ule i16 -4, 5        ; yields: result=false
&lt;result&gt; = icmp sge i16  4, 5        ; yields: result=false
</pre></div>
</div>
<p>Note that the code generator does not yet support vector types with the
<code class="docutils literal"><span class="pre">icmp</span></code> instruction.</p>
</div>
</div>
<div class="section" id="fcmp-instruction">
<span id="i-fcmp"></span><h4><a class="toc-backref" href="#id1113">&#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; Instruction</a><a class="headerlink" href="#fcmp-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id285">
<h5><a class="toc-backref" href="#id1114">Syntax:</a><a class="headerlink" href="#id285" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fcmp</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>     <span class="p">;</span> <span class="n">yields</span> <span class="n">i1</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">N</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id286">
<h5><a class="toc-backref" href="#id1115">Overview:</a><a class="headerlink" href="#id286" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; instruction returns a boolean value or vector of boolean
values based on comparison of its operands.</p>
<p>If the operands are floating point scalars, then the result type is a
boolean (<a class="reference internal" href="#t-integer"><span class="std std-ref">i1</span></a>).</p>
<p>If the operands are floating point vectors, then the result type is a
vector of boolean with the same number of elements as the operands being
compared.</p>
</div>
<div class="section" id="id287">
<h5><a class="toc-backref" href="#id1116">Arguments:</a><a class="headerlink" href="#id287" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; instruction takes three operands. The first operand is
the condition code indicating the kind of comparison to perform. It is
not a value, just a keyword. The possible condition code are:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">false</span></code>: no comparison, always returns false</li>
<li><code class="docutils literal"><span class="pre">oeq</span></code>: ordered and equal</li>
<li><code class="docutils literal"><span class="pre">ogt</span></code>: ordered and greater than</li>
<li><code class="docutils literal"><span class="pre">oge</span></code>: ordered and greater than or equal</li>
<li><code class="docutils literal"><span class="pre">olt</span></code>: ordered and less than</li>
<li><code class="docutils literal"><span class="pre">ole</span></code>: ordered and less than or equal</li>
<li><code class="docutils literal"><span class="pre">one</span></code>: ordered and not equal</li>
<li><code class="docutils literal"><span class="pre">ord</span></code>: ordered (no nans)</li>
<li><code class="docutils literal"><span class="pre">ueq</span></code>: unordered or equal</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: unordered or greater than</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: unordered or greater than or equal</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: unordered or less than</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: unordered or less than or equal</li>
<li><code class="docutils literal"><span class="pre">une</span></code>: unordered or not equal</li>
<li><code class="docutils literal"><span class="pre">uno</span></code>: unordered (either nans)</li>
<li><code class="docutils literal"><span class="pre">true</span></code>: no comparison, always returns true</li>
</ol>
<p><em>Ordered</em> means that neither operand is a QNAN while <em>unordered</em> means
that either operand may be a QNAN.</p>
<p>Each of <code class="docutils literal"><span class="pre">val1</span></code> and <code class="docutils literal"><span class="pre">val2</span></code> arguments must be either a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type or a <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point
type. They must have identical types.</p>
</div>
<div class="section" id="id288">
<h5><a class="toc-backref" href="#id1117">Semantics:</a><a class="headerlink" href="#id288" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; instruction compares <code class="docutils literal"><span class="pre">op1</span></code> and <code class="docutils literal"><span class="pre">op2</span></code> according to the
condition code given as <code class="docutils literal"><span class="pre">cond</span></code>. If the operands are vectors, then the
vectors are compared element by element. Each comparison performed
always yields an <a class="reference internal" href="#t-integer"><span class="std std-ref">i1</span></a> result, as follows:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">false</span></code>: always yields <code class="docutils literal"><span class="pre">false</span></code>, regardless of operands.</li>
<li><code class="docutils literal"><span class="pre">oeq</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ogt</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">oge</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">olt</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ole</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">one</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is not equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ord</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN.</li>
<li><code class="docutils literal"><span class="pre">ueq</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">une</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
not equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">uno</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN.</li>
<li><code class="docutils literal"><span class="pre">true</span></code>: always yields <code class="docutils literal"><span class="pre">true</span></code>, regardless of operands.</li>
</ol>
<p>The <code class="docutils literal"><span class="pre">fcmp</span></code> instruction can also optionally take any number of
<a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>, which are optimization hints to enable
otherwise unsafe floating point optimizations.</p>
<p>Any set of fast-math flags are legal on an <code class="docutils literal"><span class="pre">fcmp</span></code> instruction, but the
only flags that have any effect on its semantics are those that allow
assumptions to be made about the values of input arguments; namely
<code class="docutils literal"><span class="pre">nnan</span></code>, <code class="docutils literal"><span class="pre">ninf</span></code>, and <code class="docutils literal"><span class="pre">nsz</span></code>. See <a class="reference internal" href="#fastmath"><span class="std std-ref">Fast-Math Flags</span></a> for more information.</p>
</div>
<div class="section" id="id289">
<h5><a class="toc-backref" href="#id1118">Example:</a><a class="headerlink" href="#id289" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fcmp oeq float 4.0, 5.0    ; yields: result=false
&lt;result&gt; = fcmp one float 4.0, 5.0    ; yields: result=true
&lt;result&gt; = fcmp olt float 4.0, 5.0    ; yields: result=true
&lt;result&gt; = fcmp ueq double 1.0, 2.0   ; yields: result=false
</pre></div>
</div>
<p>Note that the code generator does not yet support vector types with the
<code class="docutils literal"><span class="pre">fcmp</span></code> instruction.</p>
</div>
</div>
<div class="section" id="phi-instruction">
<span id="i-phi"></span><h4><a class="toc-backref" href="#id1119">&#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; Instruction</a><a class="headerlink" href="#phi-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id290">
<h5><a class="toc-backref" href="#id1120">Syntax:</a><a class="headerlink" href="#id290" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">val0</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">label0</span><span class="o">&gt;</span><span class="p">],</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id291">
<h5><a class="toc-backref" href="#id1121">Overview:</a><a class="headerlink" href="#id291" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; instruction is used to implement the φ node in the SSA
graph representing the function.</p>
</div>
<div class="section" id="id292">
<h5><a class="toc-backref" href="#id1122">Arguments:</a><a class="headerlink" href="#id292" title="永久链接至标题">¶</a></h5>
<p>The type of the incoming values is specified with the first type field.
After this, the &#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; instruction takes a list of pairs as
arguments, with one pair for each predecessor basic block of the current
block. Only values of <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type may be used as
the value arguments to the PHI node. Only labels may be used as the
label arguments.</p>
<p>There must be no non-phi instructions between the start of a basic block
and the PHI instructions: i.e. PHI instructions must be first in a basic
block.</p>
<p>For the purposes of the SSA form, the use of each incoming value is
deemed to occur on the edge from the corresponding predecessor block to
the current block (but after any definition of an &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216;
instruction&#8217;s return value on the same edge).</p>
</div>
<div class="section" id="id293">
<h5><a class="toc-backref" href="#id1123">Semantics:</a><a class="headerlink" href="#id293" title="永久链接至标题">¶</a></h5>
<p>At runtime, the &#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; instruction logically takes on the value
specified by the pair corresponding to the predecessor basic block that
executed just prior to the current block.</p>
</div>
<div class="section" id="id294">
<h5><a class="toc-backref" href="#id1124">Example:</a><a class="headerlink" href="#id294" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">Loop:</span>       <span class="c">; Infinite loop that counts from 0 on up...</span>
  <span class="nv">%indvar</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%LoopHeader</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%nextindvar</span><span class="p">,</span> <span class="nv">%Loop</span> <span class="p">]</span>
  <span class="nv">%nextindvar</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%indvar</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%Loop</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="select-instruction">
<span id="i-select"></span><h4><a class="toc-backref" href="#id1125">&#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; Instruction</a><a class="headerlink" href="#select-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id295">
<h5><a class="toc-backref" href="#id1126">Syntax:</a><a class="headerlink" href="#id295" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">select</span> <span class="n">selty</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span>

<span class="n">selty</span> <span class="ow">is</span> <span class="n">either</span> <span class="n">i1</span> <span class="ow">or</span> <span class="p">{</span><span class="o">&lt;</span><span class="n">N</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id296">
<h5><a class="toc-backref" href="#id1127">Overview:</a><a class="headerlink" href="#id296" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; instruction is used to choose one value based on a
condition, without IR-level branching.</p>
</div>
<div class="section" id="id297">
<h5><a class="toc-backref" href="#id1128">Arguments:</a><a class="headerlink" href="#id297" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; instruction requires an &#8216;i1&#8217; value or a vector of &#8216;i1&#8217;
values indicating the condition, and two values of the same <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first
class</span></a> type.</p>
</div>
<div class="section" id="id298">
<h5><a class="toc-backref" href="#id1129">Semantics:</a><a class="headerlink" href="#id298" title="永久链接至标题">¶</a></h5>
<p>If the condition is an i1 and it evaluates to 1, the instruction returns
the first value argument; otherwise, it returns the second value
argument.</p>
<p>If the condition is a vector of i1, then the value arguments must be
vectors of the same size, and the selection is done element by element.</p>
<p>If the condition is an i1 and the value arguments are vectors of the
same size, then an entire vector is selected.</p>
</div>
<div class="section" id="id299">
<h5><a class="toc-backref" href="#id1130">Example:</a><a class="headerlink" href="#id299" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">select</span> <span class="k">i1</span> <span class="k">true</span><span class="p">,</span> <span class="k">i8</span> <span class="m">17</span><span class="p">,</span> <span class="k">i8</span> <span class="m">42</span>          <span class="c">; yields i8:17</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="call-instruction">
<span id="i-call"></span><h4><a class="toc-backref" href="#id1131">&#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; Instruction</a><a class="headerlink" href="#call-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id300">
<h5><a class="toc-backref" href="#id1132">Syntax:</a><a class="headerlink" href="#id300" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="n">tail</span> <span class="o">|</span> <span class="n">musttail</span> <span class="o">|</span> <span class="n">notail</span> <span class="p">]</span> <span class="n">call</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span> <span class="p">[</span><span class="n">cconv</span><span class="p">]</span> <span class="p">[</span><span class="n">ret</span> <span class="n">attrs</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">fnty</span><span class="o">&gt;*</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">fnptrval</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">function</span> <span class="n">args</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">[</span><span class="n">fn</span> <span class="n">attrs</span><span class="p">]</span>
             <span class="p">[</span> <span class="n">operand</span> <span class="n">bundles</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id301">
<h5><a class="toc-backref" href="#id1133">Overview:</a><a class="headerlink" href="#id301" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; instruction represents a simple function call.</p>
</div>
<div class="section" id="id302">
<h5><a class="toc-backref" href="#id1134">Arguments:</a><a class="headerlink" href="#id302" title="永久链接至标题">¶</a></h5>
<p>This instruction requires several arguments:</p>
<ol class="arabic">
<li><p class="first">The optional <code class="docutils literal"><span class="pre">tail</span></code> and <code class="docutils literal"><span class="pre">musttail</span></code> markers indicate that the optimizers
should perform tail call optimization. The <code class="docutils literal"><span class="pre">tail</span></code> marker is a hint that
<a class="reference external" href="CodeGenerator.html#sibcallopt">can be ignored</a>. The <code class="docutils literal"><span class="pre">musttail</span></code> marker
means that the call must be tail call optimized in order for the program to
be correct. The <code class="docutils literal"><span class="pre">musttail</span></code> marker provides these guarantees:</p>
<ol class="arabic simple">
<li>The call will not cause unbounded stack growth if it is part of a
recursive cycle in the call graph.</li>
<li>Arguments with the <a class="reference internal" href="#attr-inalloca"><span class="std std-ref">inalloca</span></a> attribute are
forwarded in place.</li>
</ol>
<p>Both markers imply that the callee does not access allocas or varargs from
the caller. Calls marked <code class="docutils literal"><span class="pre">musttail</span></code> must obey the following additional
rules:</p>
<ul class="simple">
<li>The call must immediately precede a <a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a> instruction,
or a pointer bitcast followed by a ret instruction.</li>
<li>The ret instruction must return the (possibly bitcasted) value
produced by the call or void.</li>
<li>The caller and callee prototypes must match. Pointer types of
parameters or return types may differ in pointee type, but not
in address space.</li>
<li>The calling conventions of the caller and callee must match.</li>
<li>All ABI-impacting function attributes, such as sret, byval, inreg,
returned, and inalloca, must match.</li>
<li>The callee must be varargs iff the caller is varargs. Bitcasting a
non-varargs function to the appropriate varargs type is legal so
long as the non-varargs prefixes obey the other rules.</li>
</ul>
<p>Tail call optimization for calls marked <code class="docutils literal"><span class="pre">tail</span></code> is guaranteed to occur if
the following conditions are met:</p>
<ul class="simple">
<li>Caller and callee both have the calling convention <code class="docutils literal"><span class="pre">fastcc</span></code>.</li>
<li>The call is in tail position (ret immediately follows call and ret
uses value of call or is void).</li>
<li>Option <code class="docutils literal"><span class="pre">-tailcallopt</span></code> is enabled, or
<code class="docutils literal"><span class="pre">llvm::GuaranteedTailCallOpt</span></code> is <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li><a class="reference external" href="CodeGenerator.html#tailcallopt">Platform-specific constraints are
met.</a></li>
</ul>
</li>
<li><p class="first">The optional <code class="docutils literal"><span class="pre">notail</span></code> marker indicates that the optimizers should not add
<code class="docutils literal"><span class="pre">tail</span></code> or <code class="docutils literal"><span class="pre">musttail</span></code> markers to the call. It is used to prevent tail
call optimization from being performed on the call.</p>
</li>
<li><p class="first">The optional <code class="docutils literal"><span class="pre">fast-math</span> <span class="pre">flags</span></code> marker indicates that the call has one or more
<a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>, which are optimization hints to enable
otherwise unsafe floating-point optimizations. Fast-math flags are only valid
for calls that return a floating-point scalar or vector type.</p>
</li>
<li><p class="first">The optional &#8220;cconv&#8221; marker indicates which <a class="reference internal" href="#callingconv"><span class="std std-ref">calling
convention</span></a> the call should use. If none is
specified, the call defaults to using C calling conventions. The
calling convention of the call must match the calling convention of
the target function, or else the behavior is undefined.</p>
</li>
<li><p class="first">The optional <a class="reference internal" href="#paramattrs"><span class="std std-ref">Parameter Attributes</span></a> list for return
values. Only &#8216;<code class="docutils literal"><span class="pre">zeroext</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">signext</span></code>&#8216;, and &#8216;<code class="docutils literal"><span class="pre">inreg</span></code>&#8216; attributes
are valid here.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">ty</span></code>&#8216;: the type of the call instruction itself which is also the
type of the return value. Functions that return no value are marked
<code class="docutils literal"><span class="pre">void</span></code>.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">fnty</span></code>&#8216;: shall be the signature of the pointer to function value
being invoked. The argument types must match the types implied by
this signature. This type can be omitted if the function is not
varargs and if the function type does not return a pointer to a
function.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">fnptrval</span></code>&#8216;: An LLVM value containing a pointer to a function to
be invoked. In most cases, this is a direct function invocation, but
indirect <code class="docutils literal"><span class="pre">call</span></code>&#8216;s are just as possible, calling an arbitrary pointer
to function value.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">function</span> <span class="pre">args</span></code>&#8216;: argument list whose types match the function
signature argument types and parameter attributes. All arguments must
be of <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type. If the function signature
indicates the function accepts a variable number of arguments, the
extra arguments can be specified.</p>
</li>
<li><p class="first">The optional <a class="reference internal" href="#fnattrs"><span class="std std-ref">function attributes</span></a> list. Only
&#8216;<code class="docutils literal"><span class="pre">noreturn</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">nounwind</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">readonly</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">readnone</span></code>&#8216;
attributes are valid here.</p>
</li>
<li><p class="first">The optional <a class="reference internal" href="#opbundles"><span class="std std-ref">operand bundles</span></a> list.</p>
</li>
</ol>
</div>
<div class="section" id="id303">
<h5><a class="toc-backref" href="#id1135">Semantics:</a><a class="headerlink" href="#id303" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; instruction is used to cause control flow to transfer to
a specified function, with its incoming arguments bound to the specified
values. Upon a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction in the called function, control
flow continues with the instruction after the function call, and the
return value of the function is bound to the result argument.</p>
</div>
<div class="section" id="id304">
<h5><a class="toc-backref" href="#id1136">Example:</a><a class="headerlink" href="#id304" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%retval</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%argc</span><span class="p">)</span>
<span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)*</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%msg</span><span class="p">,</span> <span class="k">i32</span> <span class="m">12</span><span class="p">,</span> <span class="k">i8</span> <span class="m">42</span><span class="p">)</span>        <span class="c">; yields i32</span>
<span class="nv">%X</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">()</span>                                    <span class="c">; yields i32</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">fastcc</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">()</span>  <span class="c">; yields i32</span>
<span class="k">call</span> <span class="kt">void</span> <span class="nv">%foo</span><span class="p">(</span><span class="k">i8</span> <span class="m">97</span> <span class="k">signext</span><span class="p">)</span>

<span class="nv">%struct.A</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i8</span> <span class="p">}</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%struct.A</span> <span class="vg">@foo</span><span class="p">()</span>                        <span class="c">; yields { i32, i8 }</span>
<span class="nv">%gr</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%struct.A</span> <span class="nv">%r</span><span class="p">,</span> <span class="m">0</span>                <span class="c">; yields i32</span>
<span class="nv">%gr1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%struct.A</span> <span class="nv">%r</span><span class="p">,</span> <span class="m">1</span>               <span class="c">; yields i8</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="k">noreturn</span>                    <span class="c">; indicates that %foo never returns normally</span>
<span class="nv">%ZZ</span> <span class="p">=</span> <span class="k">call</span> <span class="k">zeroext</span> <span class="k">i32</span> <span class="vg">@bar</span><span class="p">()</span>                     <span class="c">; Return value is %zero extended</span>
</pre></div>
</div>
<p>llvm treats calls to some functions with names and arguments that match
the standard C99 library as being the C99 library functions, and may
perform optimizations or generate code for them under that assumption.
This is something we&#8217;d like to change in the future to provide better
support for freestanding environments and non-C-based languages.</p>
</div>
</div>
<div class="section" id="va-arg-instruction">
<span id="i-va-arg"></span><h4><a class="toc-backref" href="#id1137">&#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; Instruction</a><a class="headerlink" href="#va-arg-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id305">
<h5><a class="toc-backref" href="#id1138">Syntax:</a><a class="headerlink" href="#id305" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">va_arg</span> <span class="o">&lt;</span><span class="n">va_list</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">arglist</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">argty</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id306">
<h5><a class="toc-backref" href="#id1139">Overview:</a><a class="headerlink" href="#id306" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; instruction is used to access arguments passed through
the &#8220;variable argument&#8221; area of a function call. It is used to implement
the <code class="docutils literal"><span class="pre">va_arg</span></code> macro in C.</p>
</div>
<div class="section" id="id307">
<h5><a class="toc-backref" href="#id1140">Arguments:</a><a class="headerlink" href="#id307" title="永久链接至标题">¶</a></h5>
<p>This instruction takes a <code class="docutils literal"><span class="pre">va_list*</span></code> value and the type of the
argument. It returns a value of the specified argument type and
increments the <code class="docutils literal"><span class="pre">va_list</span></code> to point to the next argument. The actual
type of <code class="docutils literal"><span class="pre">va_list</span></code> is target specific.</p>
</div>
<div class="section" id="id308">
<h5><a class="toc-backref" href="#id1141">Semantics:</a><a class="headerlink" href="#id308" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; instruction loads an argument of the specified type
from the specified <code class="docutils literal"><span class="pre">va_list</span></code> and causes the <code class="docutils literal"><span class="pre">va_list</span></code> to point to
the next argument. For more information, see the variable argument
handling <a class="reference internal" href="#int-varargs"><span class="std std-ref">Intrinsic Functions</span></a>.</p>
<p>It is legal for this instruction to be called in a function which does
not take a variable number of arguments, for example, the <code class="docutils literal"><span class="pre">vfprintf</span></code>
function.</p>
<p><code class="docutils literal"><span class="pre">va_arg</span></code> is an LLVM instruction instead of an <a class="reference internal" href="#intrinsics"><span class="std std-ref">intrinsic
function</span></a> because it takes a type as an argument.</p>
</div>
<div class="section" id="id309">
<h5><a class="toc-backref" href="#id1142">Example:</a><a class="headerlink" href="#id309" title="永久链接至标题">¶</a></h5>
<p>See the <a class="reference internal" href="#int-varargs"><span class="std std-ref">variable argument processing</span></a> section.</p>
<p>Note that the code generator does not yet fully support va_arg on many
targets. Also, it does not currently support va_arg with aggregate
types on any target.</p>
</div>
</div>
<div class="section" id="landingpad-instruction">
<span id="i-landingpad"></span><h4><a class="toc-backref" href="#id1143">&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; Instruction</a><a class="headerlink" href="#landingpad-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id310">
<h5><a class="toc-backref" href="#id1144">Syntax:</a><a class="headerlink" href="#id310" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">landingpad</span> <span class="o">&lt;</span><span class="n">resultty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;+</span>
<span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">landingpad</span> <span class="o">&lt;</span><span class="n">resultty</span><span class="o">&gt;</span> <span class="n">cleanup</span> <span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;*</span>

<span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">=</span> <span class="n">catch</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">=</span> <span class="nb">filter</span> <span class="o">&lt;</span><span class="n">array</span> <span class="n">constant</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">array</span> <span class="n">constant</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id311">
<h5><a class="toc-backref" href="#id1145">Overview:</a><a class="headerlink" href="#id311" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling
system</a> to specify that a basic block
is a landing pad &#8212; one where the exception lands, and corresponds to the
code found in the <code class="docutils literal"><span class="pre">catch</span></code> portion of a <code class="docutils literal"><span class="pre">try</span></code>/<code class="docutils literal"><span class="pre">catch</span></code> sequence. It
defines values supplied by the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> upon
re-entry to the function. The <code class="docutils literal"><span class="pre">resultval</span></code> has the type <code class="docutils literal"><span class="pre">resultty</span></code>.</p>
</div>
<div class="section" id="id313">
<h5><a class="toc-backref" href="#id1146">Arguments:</a><a class="headerlink" href="#id313" title="永久链接至标题">¶</a></h5>
<p>The optional
<code class="docutils literal"><span class="pre">cleanup</span></code> flag indicates that the landing pad block is a cleanup.</p>
<p>A <code class="docutils literal"><span class="pre">clause</span></code> begins with the clause type &#8212; <code class="docutils literal"><span class="pre">catch</span></code> or <code class="docutils literal"><span class="pre">filter</span></code> &#8212; and
contains the global variable representing the &#8220;type&#8221; that may be caught
or filtered respectively. Unlike the <code class="docutils literal"><span class="pre">catch</span></code> clause, the <code class="docutils literal"><span class="pre">filter</span></code>
clause takes an array constant as its argument. Use
&#8220;<code class="docutils literal"><span class="pre">[0</span> <span class="pre">x</span> <span class="pre">i8**]</span> <span class="pre">undef</span></code>&#8221; for a filter which cannot throw. The
&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction must contain <em>at least</em> one <code class="docutils literal"><span class="pre">clause</span></code> or
the <code class="docutils literal"><span class="pre">cleanup</span></code> flag.</p>
</div>
<div class="section" id="id314">
<h5><a class="toc-backref" href="#id1147">Semantics:</a><a class="headerlink" href="#id314" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction defines the values which are set by the
<a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> upon re-entry to the function, and
therefore the &#8220;result type&#8221; of the <code class="docutils literal"><span class="pre">landingpad</span></code> instruction. As with
calling conventions, how the personality function results are
represented in LLVM IR is target specific.</p>
<p>The clauses are applied in order from top to bottom. If two
<code class="docutils literal"><span class="pre">landingpad</span></code> instructions are merged together through inlining, the
clauses from the calling function are appended to the list of clauses.
When the call stack is being unwound due to an exception being thrown,
the exception is compared against each <code class="docutils literal"><span class="pre">clause</span></code> in turn. If it doesn&#8217;t
match any of the clauses, and the <code class="docutils literal"><span class="pre">cleanup</span></code> flag is not set, then
unwinding continues further up the call stack.</p>
<p>The <code class="docutils literal"><span class="pre">landingpad</span></code> instruction has several restrictions:</p>
<ul class="simple">
<li>A landing pad block is a basic block which is the unwind destination
of an &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; instruction.</li>
<li>A landing pad block must have a &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction as its
first non-PHI instruction.</li>
<li>There can be only one &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction within the landing
pad block.</li>
<li>A basic block that is not a landing pad block may not include a
&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction.</li>
</ul>
</div>
<div class="section" id="id315">
<h5><a class="toc-backref" href="#id1148">Example:</a><a class="headerlink" href="#id315" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">;; A landing pad which can catch an integer.</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">landingpad</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
         <span class="k">catch</span> <span class="k">i8</span><span class="p">**</span> <span class="vg">@_ZTIi</span>
<span class="c">;; A landing pad that is a cleanup.</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">landingpad</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
         <span class="k">cleanup</span>
<span class="c">;; A landing pad which can catch an integer and can only throw a double.</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">landingpad</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
         <span class="k">catch</span> <span class="k">i8</span><span class="p">**</span> <span class="vg">@_ZTIi</span>
         <span class="k">filter</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="k">i8</span><span class="p">**]</span> <span class="p">[</span><span class="vg">@_ZTId</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="catchpad-instruction">
<span id="i-catchpad"></span><h4><a class="toc-backref" href="#id1149">&#8216;<code class="docutils literal"><span class="pre">catchpad</span></code>&#8216; Instruction</a><a class="headerlink" href="#catchpad-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id316">
<h5><a class="toc-backref" href="#id1150">Syntax:</a><a class="headerlink" href="#id316" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">catchpad</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">catchswitch</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;*</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id317">
<h5><a class="toc-backref" href="#id1151">Overview:</a><a class="headerlink" href="#id317" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchpad</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling
system</a> to specify that a basic block
begins a catch handler &#8212; one where a personality routine attempts to transfer
control to catch an exception.</p>
</div>
<div class="section" id="id319">
<h5><a class="toc-backref" href="#id1152">Arguments:</a><a class="headerlink" href="#id319" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">catchswitch</span></code> operand must always be a token produced by a
<a class="reference internal" href="#i-catchswitch"><span class="std std-ref">catchswitch</span></a> instruction in a predecessor block. This
ensures that each <code class="docutils literal"><span class="pre">catchpad</span></code> has exactly one predecessor block, and it always
terminates in a <code class="docutils literal"><span class="pre">catchswitch</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">args</span></code> correspond to whatever information the personality routine
requires to know if this is an appropriate handler for the exception. Control
will transfer to the <code class="docutils literal"><span class="pre">catchpad</span></code> if this is the first appropriate handler for
the exception.</p>
<p>The <code class="docutils literal"><span class="pre">resultval</span></code> has the type <a class="reference internal" href="#t-token"><span class="std std-ref">token</span></a> and is used to match the
<code class="docutils literal"><span class="pre">catchpad</span></code> to corresponding <a class="reference internal" href="#i-catchret"><span class="std std-ref">catchrets</span></a> and other nested EH
pads.</p>
</div>
<div class="section" id="id320">
<h5><a class="toc-backref" href="#id1153">Semantics:</a><a class="headerlink" href="#id320" title="永久链接至标题">¶</a></h5>
<p>When the call stack is being unwound due to an exception being thrown, the
exception is compared against the <code class="docutils literal"><span class="pre">args</span></code>. If it doesn&#8217;t match, control will
not reach the <code class="docutils literal"><span class="pre">catchpad</span></code> instruction.  The representation of <code class="docutils literal"><span class="pre">args</span></code> is
entirely target and personality function-specific.</p>
<p>Like the <a class="reference internal" href="#i-landingpad"><span class="std std-ref">landingpad</span></a> instruction, the <code class="docutils literal"><span class="pre">catchpad</span></code>
instruction must be the first non-phi of its parent basic block.</p>
<p>The meaning of the tokens produced and consumed by <code class="docutils literal"><span class="pre">catchpad</span></code> and other &#8220;pad&#8221;
instructions is described in the
<a class="reference external" href="ExceptionHandling.html#wineh">Windows exception handling documentation</a>.</p>
<p>When a <code class="docutils literal"><span class="pre">catchpad</span></code> has been &#8220;entered&#8221; but not yet &#8220;exited&#8221; (as
described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
it is undefined behavior to execute a <a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a> or <a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>
that does not carry an appropriate <a class="reference internal" href="#ob-funclet"><span class="std std-ref">&#8220;funclet&#8221; bundle</span></a>.</p>
</div>
<div class="section" id="id322">
<h5><a class="toc-backref" href="#id1154">Example:</a><a class="headerlink" href="#id322" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>dispatch:
  %cs = catchswitch within none [label %handler0] unwind to caller
  ;; A catch block which can catch an integer.
handler0:
  %tok = catchpad within %cs [i8** @_ZTIi]
</pre></div>
</div>
</div>
</div>
<div class="section" id="cleanuppad-instruction">
<span id="i-cleanuppad"></span><h4><a class="toc-backref" href="#id1155">&#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; Instruction</a><a class="headerlink" href="#cleanuppad-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id323">
<h5><a class="toc-backref" href="#id1156">Syntax:</a><a class="headerlink" href="#id323" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">cleanuppad</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;*</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id324">
<h5><a class="toc-backref" href="#id1157">Overview:</a><a class="headerlink" href="#id324" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling
system</a> to specify that a basic block
is a cleanup block &#8212; one where a personality routine attempts to
transfer control to run cleanup actions.
The <code class="docutils literal"><span class="pre">args</span></code> correspond to whatever additional
information the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> requires to
execute the cleanup.
The <code class="docutils literal"><span class="pre">resultval</span></code> has the type <a class="reference internal" href="#t-token"><span class="std std-ref">token</span></a> and is used to
match the <code class="docutils literal"><span class="pre">cleanuppad</span></code> to corresponding <a class="reference internal" href="#i-cleanupret"><span class="std std-ref">cleanuprets</span></a>.
The <code class="docutils literal"><span class="pre">parent</span></code> argument is the token of the funclet that contains the
<code class="docutils literal"><span class="pre">cleanuppad</span></code> instruction. If the <code class="docutils literal"><span class="pre">cleanuppad</span></code> is not inside a funclet,
this operand may be the token <code class="docutils literal"><span class="pre">none</span></code>.</p>
</div>
<div class="section" id="id326">
<h5><a class="toc-backref" href="#id1158">Arguments:</a><a class="headerlink" href="#id326" title="永久链接至标题">¶</a></h5>
<p>The instruction takes a list of arbitrary values which are interpreted
by the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a>.</p>
</div>
<div class="section" id="id327">
<h5><a class="toc-backref" href="#id1159">Semantics:</a><a class="headerlink" href="#id327" title="永久链接至标题">¶</a></h5>
<p>When the call stack is being unwound due to an exception being thrown,
the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> transfers control to the
<code class="docutils literal"><span class="pre">cleanuppad</span></code> with the aid of the personality-specific arguments.
As with calling conventions, how the personality function results are
represented in LLVM IR is target specific.</p>
<p>The <code class="docutils literal"><span class="pre">cleanuppad</span></code> instruction has several restrictions:</p>
<ul class="simple">
<li>A cleanup block is a basic block which is the unwind destination of
an exceptional instruction.</li>
<li>A cleanup block must have a &#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction as its
first non-PHI instruction.</li>
<li>There can be only one &#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction within the
cleanup block.</li>
<li>A basic block that is not a cleanup block may not include a
&#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction.</li>
</ul>
<p>When a <code class="docutils literal"><span class="pre">cleanuppad</span></code> has been &#8220;entered&#8221; but not yet &#8220;exited&#8221; (as
described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
it is undefined behavior to execute a <a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a> or <a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>
that does not carry an appropriate <a class="reference internal" href="#ob-funclet"><span class="std std-ref">&#8220;funclet&#8221; bundle</span></a>.</p>
</div>
<div class="section" id="id329">
<h5><a class="toc-backref" href="#id1160">Example:</a><a class="headerlink" href="#id329" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>%tok = cleanuppad within %cs []
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="intrinsic-functions">
<span id="intrinsics"></span><h2><a class="toc-backref" href="#id1161">Intrinsic Functions</a><a class="headerlink" href="#intrinsic-functions" title="永久链接至标题">¶</a></h2>
<p>LLVM supports the notion of an &#8220;intrinsic function&#8221;. These functions
have well known names and semantics and are required to follow certain
restrictions. Overall, these intrinsics represent an extension mechanism
for the LLVM language that does not require changing all of the
transformations in LLVM when adding to the language (or the bitcode
reader/writer, the parser, etc...).</p>
<p>Intrinsic function names must all start with an &#8220;<code class="docutils literal"><span class="pre">llvm.</span></code>&#8221; prefix. This
prefix is reserved in LLVM for intrinsic names; thus, function names may
not begin with this prefix. Intrinsic functions must always be external
functions: you cannot define the body of intrinsic functions. Intrinsic
functions may only be used in call or invoke instructions: it is illegal
to take the address of an intrinsic function. Additionally, because
intrinsic functions are part of the LLVM language, it is required if any
are added that they be documented here.</p>
<p>Some intrinsic functions can be overloaded, i.e., the intrinsic
represents a family of functions that perform the same operation but on
different data types. Because LLVM can represent over 8 million
different integer types, overloading is used commonly to allow an
intrinsic function to operate on any integer type. One or more of the
argument types or the result type can be overloaded to accept any
integer type. Argument types may also be defined as exactly matching a
previous argument&#8217;s type or the result type. This allows an intrinsic
function which accepts multiple arguments, but needs all of them to be
of the same type, to only be overloaded with respect to a single
argument or the result.</p>
<p>Overloaded intrinsics will have the names of its overloaded argument
types encoded into its function name, each preceded by a period. Only
those types which are overloaded result in a name suffix. Arguments
whose type is matched against another type do not. For example, the
<code class="docutils literal"><span class="pre">llvm.ctpop</span></code> function can take an integer of any width and returns an
integer of exactly the same integer width. This leads to a family of
functions such as <code class="docutils literal"><span class="pre">i8</span> <span class="pre">&#64;llvm.ctpop.i8(i8</span> <span class="pre">%val)</span></code> and
<code class="docutils literal"><span class="pre">i29</span> <span class="pre">&#64;llvm.ctpop.i29(i29</span> <span class="pre">%val)</span></code>. Only one type, the return type, is
overloaded, and only one type suffix is required. Because the argument&#8217;s
type is matched against the return type, it does not require its own
name suffix.</p>
<p>To learn how to add an intrinsic function, please see the <a class="reference external" href="ExtendingLLVM.html">Extending
LLVM Guide</a>.</p>
<div class="section" id="variable-argument-handling-intrinsics">
<span id="int-varargs"></span><h3><a class="toc-backref" href="#id1162">Variable Argument Handling Intrinsics</a><a class="headerlink" href="#variable-argument-handling-intrinsics" title="永久链接至标题">¶</a></h3>
<p>Variable argument support is defined in LLVM with the
<a class="reference internal" href="#i-va-arg"><span class="std std-ref">va_arg</span></a> instruction and these three intrinsic
functions. These functions are related to the similarly named macros
defined in the <code class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></code> header file.</p>
<p>All of these functions operate on arguments that use a target-specific
value type &#8220;<code class="docutils literal"><span class="pre">va_list</span></code>&#8221;. The LLVM assembly language reference manual
does not define what this type is, so all transformations should be
prepared to handle these functions regardless of the type used.</p>
<p>This example shows how the <a class="reference internal" href="#i-va-arg"><span class="std std-ref">va_arg</span></a> instruction and the
variable argument handling intrinsic functions are used.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; This struct is different for every platform. For most platforms,</span>
<span class="c">; it is merely an i8*.</span>
<span class="nv">%struct.va_list</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*</span> <span class="p">}</span>

<span class="c">; For Unix x86_64 platforms, va_list is the following struct:</span>
<span class="c">; %struct.va_list = type { i32, i32, i8*, i8* }</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="c">; Initialize variable argument processing</span>
  <span class="nv">%ap</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%struct.va_list</span>
  <span class="nv">%ap2</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="nv">%struct.va_list</span><span class="p">*</span> <span class="nv">%ap</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_start</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">)</span>

  <span class="c">; Read a single integer argument</span>
  <span class="nv">%tmp</span> <span class="p">=</span> <span class="k">va_arg</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">,</span> <span class="k">i32</span>

  <span class="c">; Demonstrate usage of llvm.va_copy and llvm.va_end</span>
  <span class="nv">%aq</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i8</span><span class="p">*</span>
  <span class="nv">%aq2</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%aq</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_copy</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%aq2</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_end</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%aq2</span><span class="p">)</span>

  <span class="c">; Stop processing of arguments.</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_end</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%tmp</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.va_start</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.va_copy</span><span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.va_end</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
</pre></div>
</div>
<div class="section" id="llvm-va-start-intrinsic">
<span id="int-va-start"></span><h4><a class="toc-backref" href="#id1163">&#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-va-start-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id330">
<h5><a class="toc-backref" href="#id1164">Syntax:</a><a class="headerlink" href="#id330" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">va_start</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">arglist</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id331">
<h5><a class="toc-backref" href="#id1165">Overview:</a><a class="headerlink" href="#id331" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; intrinsic initializes <code class="docutils literal"><span class="pre">*&lt;arglist&gt;</span></code> for
subsequent use by <code class="docutils literal"><span class="pre">va_arg</span></code>.</p>
</div>
<div class="section" id="id332">
<h5><a class="toc-backref" href="#id1166">Arguments:</a><a class="headerlink" href="#id332" title="永久链接至标题">¶</a></h5>
<p>The argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> element to initialize.</p>
</div>
<div class="section" id="id333">
<h5><a class="toc-backref" href="#id1167">Semantics:</a><a class="headerlink" href="#id333" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; intrinsic works just like the <code class="docutils literal"><span class="pre">va_start</span></code> macro
available in C. In a target-dependent way, it initializes the
<code class="docutils literal"><span class="pre">va_list</span></code> element to which the argument points, so that the next call
to <code class="docutils literal"><span class="pre">va_arg</span></code> will produce the first variable argument passed to the
function. Unlike the C <code class="docutils literal"><span class="pre">va_start</span></code> macro, this intrinsic does not need
to know the last argument of the function as the compiler can figure
that out.</p>
</div>
</div>
<div class="section" id="llvm-va-end-intrinsic">
<h4><a class="toc-backref" href="#id1168">&#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-va-end-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id334">
<h5><a class="toc-backref" href="#id1169">Syntax:</a><a class="headerlink" href="#id334" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">va_end</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">arglist</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id335">
<h5><a class="toc-backref" href="#id1170">Overview:</a><a class="headerlink" href="#id335" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; intrinsic destroys <code class="docutils literal"><span class="pre">*&lt;arglist&gt;</span></code>, which has been
initialized previously with <code class="docutils literal"><span class="pre">llvm.va_start</span></code> or <code class="docutils literal"><span class="pre">llvm.va_copy</span></code>.</p>
</div>
<div class="section" id="id336">
<h5><a class="toc-backref" href="#id1171">Arguments:</a><a class="headerlink" href="#id336" title="永久链接至标题">¶</a></h5>
<p>The argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> to destroy.</p>
</div>
<div class="section" id="id337">
<h5><a class="toc-backref" href="#id1172">Semantics:</a><a class="headerlink" href="#id337" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; intrinsic works just like the <code class="docutils literal"><span class="pre">va_end</span></code> macro
available in C. In a target-dependent way, it destroys the <code class="docutils literal"><span class="pre">va_list</span></code>
element to which the argument points. Calls to
<a class="reference internal" href="#int-va-start"><span class="std std-ref">llvm.va_start</span></a> and
<a class="reference internal" href="#int-va-copy"><span class="std std-ref">llvm.va_copy</span></a> must be matched exactly with calls to
<code class="docutils literal"><span class="pre">llvm.va_end</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-va-copy-intrinsic">
<span id="int-va-copy"></span><h4><a class="toc-backref" href="#id1173">&#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-va-copy-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id338">
<h5><a class="toc-backref" href="#id1174">Syntax:</a><a class="headerlink" href="#id338" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">va_copy</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">destarglist</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">srcarglist</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id339">
<h5><a class="toc-backref" href="#id1175">Overview:</a><a class="headerlink" href="#id339" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; intrinsic copies the current argument position
from the source argument list to the destination argument list.</p>
</div>
<div class="section" id="id340">
<h5><a class="toc-backref" href="#id1176">Arguments:</a><a class="headerlink" href="#id340" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> element to initialize.
The second argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> element to copy from.</p>
</div>
<div class="section" id="id341">
<h5><a class="toc-backref" href="#id1177">Semantics:</a><a class="headerlink" href="#id341" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; intrinsic works just like the <code class="docutils literal"><span class="pre">va_copy</span></code> macro
available in C. In a target-dependent way, it copies the source
<code class="docutils literal"><span class="pre">va_list</span></code> element into the destination <code class="docutils literal"><span class="pre">va_list</span></code> element. This
intrinsic is necessary because the `` llvm.va_start`` intrinsic may be
arbitrarily complex and require, for example, memory allocation.</p>
</div>
</div>
</div>
<div class="section" id="accurate-garbage-collection-intrinsics">
<h3><a class="toc-backref" href="#id1178">Accurate Garbage Collection Intrinsics</a><a class="headerlink" href="#accurate-garbage-collection-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM&#8217;s support for <a class="reference external" href="GarbageCollection.html">Accurate Garbage Collection</a>
(GC) requires the frontend to generate code containing appropriate intrinsic
calls and select an appropriate GC strategy which knows how to lower these
intrinsics in a manner which is appropriate for the target collector.</p>
<p>These intrinsics allow identification of <a class="reference internal" href="#int-gcroot"><span class="std std-ref">GC roots on the
stack</span></a>, as well as garbage collector implementations that
require <a class="reference internal" href="#int-gcread"><span class="std std-ref">read</span></a> and <a class="reference internal" href="#int-gcwrite"><span class="std std-ref">write</span></a> barriers.
Frontends for type-safe garbage collected languages should generate
these intrinsics to make use of the LLVM garbage collectors. For more
details, see <a class="reference external" href="GarbageCollection.html">Garbage Collection with LLVM</a>.</p>
<div class="section" id="experimental-statepoint-intrinsics">
<h4><a class="toc-backref" href="#id1179">Experimental Statepoint Intrinsics</a><a class="headerlink" href="#experimental-statepoint-intrinsics" title="永久链接至标题">¶</a></h4>
<p>LLVM provides an second experimental set of intrinsics for describing garbage
collection safepoints in compiled code. These intrinsics are an alternative
to the <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> intrinsics, but are compatible with the ones for
<a class="reference internal" href="#int-gcread"><span class="std std-ref">read</span></a> and <a class="reference internal" href="#int-gcwrite"><span class="std std-ref">write</span></a> barriers. The
differences in approach are covered in the <a class="reference external" href="GarbageCollection.html">Garbage Collection with LLVM</a> documentation. The intrinsics themselves are
described in <a class="reference internal" href="Statepoints.html"><span class="doc">Garbage Collection Safepoints in LLVM</span></a>.</p>
</div>
<div class="section" id="llvm-gcroot-intrinsic">
<span id="int-gcroot"></span><h4><a class="toc-backref" href="#id1180">&#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-gcroot-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id343">
<h5><a class="toc-backref" href="#id1181">Syntax:</a><a class="headerlink" href="#id343" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">gcroot</span><span class="p">(</span><span class="n">i8</span><span class="o">**</span> <span class="o">%</span><span class="n">ptrloc</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">metadata</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id344">
<h5><a class="toc-backref" href="#id1182">Overview:</a><a class="headerlink" href="#id344" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; intrinsic declares the existence of a GC root to
the code generator, and allows some metadata to be associated with it.</p>
</div>
<div class="section" id="id345">
<h5><a class="toc-backref" href="#id1183">Arguments:</a><a class="headerlink" href="#id345" title="永久链接至标题">¶</a></h5>
<p>The first argument specifies the address of a stack object that contains
the root pointer. The second pointer (which must be either a constant or
a global value address) contains the meta-data to be associated with the
root.</p>
</div>
<div class="section" id="id346">
<h5><a class="toc-backref" href="#id1184">Semantics:</a><a class="headerlink" href="#id346" title="永久链接至标题">¶</a></h5>
<p>At runtime, a call to this intrinsic stores a null pointer into the
&#8220;ptrloc&#8221; location. At compile-time, the code generator generates
information to allow the runtime to find the pointer at GC safe points.
The &#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; intrinsic may only be used in a function which
<a class="reference internal" href="#gc"><span class="std std-ref">specifies a GC algorithm</span></a>.</p>
</div>
</div>
<div class="section" id="llvm-gcread-intrinsic">
<span id="int-gcread"></span><h4><a class="toc-backref" href="#id1185">&#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-gcread-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id347">
<h5><a class="toc-backref" href="#id1186">Syntax:</a><a class="headerlink" href="#id347" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">gcread</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">ObjPtr</span><span class="p">,</span> <span class="n">i8</span><span class="o">**</span> <span class="o">%</span><span class="n">Ptr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id348">
<h5><a class="toc-backref" href="#id1187">Overview:</a><a class="headerlink" href="#id348" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; intrinsic identifies reads of references from heap
locations, allowing garbage collector implementations that require read
barriers.</p>
</div>
<div class="section" id="id349">
<h5><a class="toc-backref" href="#id1188">Arguments:</a><a class="headerlink" href="#id349" title="永久链接至标题">¶</a></h5>
<p>The second argument is the address to read from, which should be an
address allocated from the garbage collector. The first object is a
pointer to the start of the referenced object, if needed by the language
runtime (otherwise null).</p>
</div>
<div class="section" id="id350">
<h5><a class="toc-backref" href="#id1189">Semantics:</a><a class="headerlink" href="#id350" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; intrinsic has the same semantics as a load
instruction, but may be replaced with substantially more complex code by
the garbage collector runtime, as needed. The &#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216;
intrinsic may only be used in a function which <a class="reference internal" href="#gc"><span class="std std-ref">specifies a GC
algorithm</span></a>.</p>
</div>
</div>
<div class="section" id="llvm-gcwrite-intrinsic">
<span id="int-gcwrite"></span><h4><a class="toc-backref" href="#id1190">&#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-gcwrite-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id351">
<h5><a class="toc-backref" href="#id1191">Syntax:</a><a class="headerlink" href="#id351" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">gcwrite</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">P1</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">Obj</span><span class="p">,</span> <span class="n">i8</span><span class="o">**</span> <span class="o">%</span><span class="n">P2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id352">
<h5><a class="toc-backref" href="#id1192">Overview:</a><a class="headerlink" href="#id352" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; intrinsic identifies writes of references to heap
locations, allowing garbage collector implementations that require write
barriers (such as generational or reference counting collectors).</p>
</div>
<div class="section" id="id353">
<h5><a class="toc-backref" href="#id1193">Arguments:</a><a class="headerlink" href="#id353" title="永久链接至标题">¶</a></h5>
<p>The first argument is the reference to store, the second is the start of
the object to store it to, and the third is the address of the field of
Obj to store to. If the runtime does not require a pointer to the
object, Obj may be null.</p>
</div>
<div class="section" id="id354">
<h5><a class="toc-backref" href="#id1194">Semantics:</a><a class="headerlink" href="#id354" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; intrinsic has the same semantics as a store
instruction, but may be replaced with substantially more complex code by
the garbage collector runtime, as needed. The &#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216;
intrinsic may only be used in a function which <a class="reference internal" href="#gc"><span class="std std-ref">specifies a GC
algorithm</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="code-generator-intrinsics">
<h3><a class="toc-backref" href="#id1195">Code Generator Intrinsics</a><a class="headerlink" href="#code-generator-intrinsics" title="永久链接至标题">¶</a></h3>
<p>These intrinsics are provided by LLVM to expose special features that
may only be implemented with code generator support.</p>
<div class="section" id="llvm-returnaddress-intrinsic">
<h4><a class="toc-backref" href="#id1196">&#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-returnaddress-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id355">
<h5><a class="toc-backref" href="#id1197">Syntax:</a><a class="headerlink" href="#id355" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span>  <span class="o">*</span><span class="nd">@llvm</span><span class="o">.</span><span class="n">returnaddress</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">level</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id356">
<h5><a class="toc-backref" href="#id1198">Overview:</a><a class="headerlink" href="#id356" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; intrinsic attempts to compute a
target-specific value indicating the return address of the current
function or one of its callers.</p>
</div>
<div class="section" id="id357">
<h5><a class="toc-backref" href="#id1199">Arguments:</a><a class="headerlink" href="#id357" title="永久链接至标题">¶</a></h5>
<p>The argument to this intrinsic indicates which function to return the
address for. Zero indicates the calling function, one indicates its
caller, etc. The argument is <strong>required</strong> to be a constant integer
value.</p>
</div>
<div class="section" id="id358">
<h5><a class="toc-backref" href="#id1200">Semantics:</a><a class="headerlink" href="#id358" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; intrinsic either returns a pointer
indicating the return address of the specified call frame, or zero if it
cannot be identified. The value returned by this intrinsic is likely to
be incorrect or 0 for arguments other than zero, so it should only be
used for debugging purposes.</p>
<p>Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.</p>
</div>
</div>
<div class="section" id="llvm-frameaddress-intrinsic">
<h4><a class="toc-backref" href="#id1201">&#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-frameaddress-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id359">
<h5><a class="toc-backref" href="#id1202">Syntax:</a><a class="headerlink" href="#id359" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">frameaddress</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">level</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id360">
<h5><a class="toc-backref" href="#id1203">Overview:</a><a class="headerlink" href="#id360" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; intrinsic attempts to return the
target-specific frame pointer value for the specified stack frame.</p>
</div>
<div class="section" id="id361">
<h5><a class="toc-backref" href="#id1204">Arguments:</a><a class="headerlink" href="#id361" title="永久链接至标题">¶</a></h5>
<p>The argument to this intrinsic indicates which function to return the
frame pointer for. Zero indicates the calling function, one indicates
its caller, etc. The argument is <strong>required</strong> to be a constant integer
value.</p>
</div>
<div class="section" id="id362">
<h5><a class="toc-backref" href="#id1205">Semantics:</a><a class="headerlink" href="#id362" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; intrinsic either returns a pointer
indicating the frame address of the specified call frame, or zero if it
cannot be identified. The value returned by this intrinsic is likely to
be incorrect or 0 for arguments other than zero, so it should only be
used for debugging purposes.</p>
<p>Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.</p>
</div>
</div>
<div class="section" id="llvm-localescape-and-llvm-localrecover-intrinsics">
<h4><a class="toc-backref" href="#id1206">&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-localescape-and-llvm-localrecover-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id363">
<h5><a class="toc-backref" href="#id1207">Syntax:</a><a class="headerlink" href="#id363" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">localescape</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">localrecover</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">func</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">fp</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id364">
<h5><a class="toc-backref" href="#id1208">Overview:</a><a class="headerlink" href="#id364" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; intrinsic escapes offsets of a collection of static
allocas, and the &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; intrinsic applies those offsets to a
live frame pointer to recover the address of the allocation. The offset is
computed during frame layout of the caller of <code class="docutils literal"><span class="pre">llvm.localescape</span></code>.</p>
</div>
<div class="section" id="id365">
<h5><a class="toc-backref" href="#id1209">Arguments:</a><a class="headerlink" href="#id365" title="永久链接至标题">¶</a></h5>
<p>All arguments to &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; must be pointers to static allocas or
casts of static allocas. Each function can only call &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216;
once, and it can only do so from the entry block.</p>
<p>The <code class="docutils literal"><span class="pre">func</span></code> argument to &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; must be a constant
bitcasted pointer to a function defined in the current module. The code
generator cannot determine the frame allocation offset of functions defined in
other modules.</p>
<p>The <code class="docutils literal"><span class="pre">fp</span></code> argument to &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; must be a frame pointer of a
call frame that is currently live. The return value of &#8216;<code class="docutils literal"><span class="pre">llvm.localaddress</span></code>&#8216;
is one way to produce such a value, but various runtimes also expose a suitable
pointer in platform-specific ways.</p>
<p>The <code class="docutils literal"><span class="pre">idx</span></code> argument to &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; indicates which alloca passed to
&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; to recover. It is zero-indexed.</p>
</div>
<div class="section" id="id366">
<h5><a class="toc-backref" href="#id1210">Semantics:</a><a class="headerlink" href="#id366" title="永久链接至标题">¶</a></h5>
<p>These intrinsics allow a group of functions to share access to a set of local
stack allocations of a one parent function. The parent function may call the
&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; intrinsic once from the function entry block, and the
child functions can use &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; to access the escaped allocas.
The &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; intrinsic blocks inlining, as inlining changes where
the escaped allocas are allocated, which would break attempts to use
&#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216;.</p>
</div>
</div>
<div class="section" id="llvm-read-register-and-llvm-write-register-intrinsics">
<span id="int-write-register"></span><span id="int-read-register"></span><h4><a class="toc-backref" href="#id1211">&#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-read-register-and-llvm-write-register-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id367">
<h5><a class="toc-backref" href="#id1212">Syntax:</a><a class="headerlink" href="#id367" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span>declare i32 @llvm.read_register.i32(metadata)
declare i64 @llvm.read_register.i64(metadata)
declare void @llvm.write_register.i32(metadata, i32 @value)
declare void @llvm.write_register.i64(metadata, i64 @value)
!0 = !{!&quot;sp\00&quot;}
</pre></div>
</div>
</div>
<div class="section" id="id368">
<h5><a class="toc-backref" href="#id1213">Overview:</a><a class="headerlink" href="#id368" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; intrinsics
provides access to the named register. The register must be valid on
the architecture being compiled to. The type needs to be compatible
with the register being read.</p>
</div>
<div class="section" id="id369">
<h5><a class="toc-backref" href="#id1214">Semantics:</a><a class="headerlink" href="#id369" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; intrinsic returns the current value of the
register, where possible. The &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; intrinsic sets
the current value of the register, where possible.</p>
<p>This is useful to implement named register global variables that need
to always be mapped to a specific register, as is common practice on
bare-metal programs including OS kernels.</p>
<p>The compiler doesn&#8217;t check for register availability or use of the used
register in surrounding code, including inline assembly. Because of that,
allocatable registers are not supported.</p>
<p>Warning: So far it only works with the stack pointer on selected
architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of
work is needed to support other registers and even more so, allocatable
registers.</p>
</div>
</div>
<div class="section" id="llvm-stacksave-intrinsic">
<span id="int-stacksave"></span><h4><a class="toc-backref" href="#id1215">&#8216;<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stacksave-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id370">
<h5><a class="toc-backref" href="#id1216">Syntax:</a><a class="headerlink" href="#id370" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stacksave</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id371">
<h5><a class="toc-backref" href="#id1217">Overview:</a><a class="headerlink" href="#id371" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>&#8216; intrinsic is used to remember the current state
of the function stack, for use with
<a class="reference internal" href="#int-stackrestore"><span class="std std-ref">llvm.stackrestore</span></a>. This is useful for
implementing language features like scoped automatic variable sized
arrays in C99.</p>
</div>
<div class="section" id="id372">
<h5><a class="toc-backref" href="#id1218">Semantics:</a><a class="headerlink" href="#id372" title="永久链接至标题">¶</a></h5>
<p>This intrinsic returns a opaque pointer value that can be passed to
<a class="reference internal" href="#int-stackrestore"><span class="std std-ref">llvm.stackrestore</span></a>. When an
<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code> intrinsic is executed with a value saved from
<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>, it effectively restores the state of the stack to
the state it was in when the <code class="docutils literal"><span class="pre">llvm.stacksave</span></code> intrinsic executed. In
practice, this pops any <a class="reference internal" href="#i-alloca"><span class="std std-ref">alloca</span></a> blocks from the stack that
were allocated after the <code class="docutils literal"><span class="pre">llvm.stacksave</span></code> was executed.</p>
</div>
</div>
<div class="section" id="llvm-stackrestore-intrinsic">
<span id="int-stackrestore"></span><h4><a class="toc-backref" href="#id1219">&#8216;<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stackrestore-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id373">
<h5><a class="toc-backref" href="#id1220">Syntax:</a><a class="headerlink" href="#id373" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackrestore</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id374">
<h5><a class="toc-backref" href="#id1221">Overview:</a><a class="headerlink" href="#id374" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code>&#8216; intrinsic is used to restore the state of
the function stack to the state it was in when the corresponding
<a class="reference internal" href="#int-stacksave"><span class="std std-ref">llvm.stacksave</span></a> intrinsic executed. This is
useful for implementing language features like scoped automatic variable
sized arrays in C99.</p>
</div>
<div class="section" id="id375">
<h5><a class="toc-backref" href="#id1222">Semantics:</a><a class="headerlink" href="#id375" title="永久链接至标题">¶</a></h5>
<p>See the description for <a class="reference internal" href="#int-stacksave"><span class="std std-ref">llvm.stacksave</span></a>.</p>
</div>
</div>
<div class="section" id="llvm-get-dynamic-area-offset-intrinsic">
<span id="int-get-dynamic-area-offset"></span><h4><a class="toc-backref" href="#id1223">&#8216;<code class="docutils literal"><span class="pre">llvm.get.dynamic.area.offset</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-get-dynamic-area-offset-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id376">
<h5><a class="toc-backref" href="#id1224">Syntax:</a><a class="headerlink" href="#id376" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">dynamic</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">i32</span><span class="p">()</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">dynamic</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">i64</span><span class="p">()</span>

<span class="n">Overview</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">The &#39;``llvm.get.dynamic.area.offset.*``&#39; intrinsic family is used to</span>
<span class="s2">get the offset from native stack pointer to the address of the most</span>
<span class="s2">recent dynamic alloca on the caller&#39;s stack. These intrinsics are</span>
<span class="s2">intendend for use in combination with</span>
<span class="s2">:ref:`llvm.stacksave &lt;int_stacksave&gt;` to get a</span>
<span class="s2">pointer to the most recent dynamic alloca. This is useful, for example,</span>
<span class="s2">for AddressSanitizer&#39;s stack unpoisoning routines.</span>
</pre></div>
</div>
</div>
<div class="section" id="id377">
<h5><a class="toc-backref" href="#id1225">Semantics:</a><a class="headerlink" href="#id377" title="永久链接至标题">¶</a></h5>
<blockquote>
<div><p>These intrinsics return a non-negative integer value that can be used to
get the address of the most recent dynamic alloca, allocated by <a class="reference internal" href="#i-alloca"><span class="std std-ref">alloca</span></a>
on the caller&#8217;s stack. In particular, for targets where stack grows downwards,
adding this offset to the native stack pointer would get the address of the most
recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more
complicated, because substracting this value from stack pointer would get the address
one past the end of the most recent dynamic alloca.</p>
<p>Although for most targets <cite>llvm.get.dynamic.area.offset &lt;int_get_dynamic_area_offset&gt;</cite>
returns just a zero, for others, such as PowerPC and PowerPC64, it returns a
compile-time-known constant value.</p>
<p>The return value type of <a class="reference internal" href="#int-get-dynamic-area-offset"><span class="std std-ref">llvm.get.dynamic.area.offset</span></a>
must match the target&#8217;s generic address space&#8217;s (address space 0) pointer type.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="llvm-prefetch-intrinsic">
<h4><a class="toc-backref" href="#id1226">&#8216;<code class="docutils literal"><span class="pre">llvm.prefetch</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-prefetch-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id378">
<h5><a class="toc-backref" href="#id1227">Syntax:</a><a class="headerlink" href="#id378" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">rw</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">locality</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">cache</span> <span class="nb">type</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id379">
<h5><a class="toc-backref" href="#id1228">Overview:</a><a class="headerlink" href="#id379" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.prefetch</span></code>&#8216; intrinsic is a hint to the code generator to
insert a prefetch instruction if supported; otherwise, it is a noop.
Prefetches have no effect on the behavior of the program but can change
its performance characteristics.</p>
</div>
<div class="section" id="id380">
<h5><a class="toc-backref" href="#id1229">Arguments:</a><a class="headerlink" href="#id380" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">address</span></code> is the address to be prefetched, <code class="docutils literal"><span class="pre">rw</span></code> is the specifier
determining if the fetch should be for a read (0) or write (1), and
<code class="docutils literal"><span class="pre">locality</span></code> is a temporal locality specifier ranging from (0) - no
locality, to (3) - extremely local keep in cache. The <code class="docutils literal"><span class="pre">cache</span> <span class="pre">type</span></code>
specifies whether the prefetch is performed on the data (1) or
instruction (0) cache. The <code class="docutils literal"><span class="pre">rw</span></code>, <code class="docutils literal"><span class="pre">locality</span></code> and <code class="docutils literal"><span class="pre">cache</span> <span class="pre">type</span></code>
arguments must be constant integers.</p>
</div>
<div class="section" id="id381">
<h5><a class="toc-backref" href="#id1230">Semantics:</a><a class="headerlink" href="#id381" title="永久链接至标题">¶</a></h5>
<p>This intrinsic does not modify the behavior of the program. In
particular, prefetches cannot trap and do not produce a value. On
targets that support this intrinsic, the prefetch can provide hints to
the processor cache for better performance.</p>
</div>
</div>
<div class="section" id="llvm-pcmarker-intrinsic">
<h4><a class="toc-backref" href="#id1231">&#8216;<code class="docutils literal"><span class="pre">llvm.pcmarker</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-pcmarker-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id382">
<h5><a class="toc-backref" href="#id1232">Syntax:</a><a class="headerlink" href="#id382" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">pcmarker</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id383">
<h5><a class="toc-backref" href="#id1233">Overview:</a><a class="headerlink" href="#id383" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.pcmarker</span></code>&#8216; intrinsic is a method to export a Program
Counter (PC) in a region of code to simulators and other tools. The
method is target specific, but it is expected that the marker will use
exported symbols to transmit the PC of the marker. The marker makes no
guarantees that it will remain with any specific instruction after
optimizations. It is possible that the presence of a marker will inhibit
optimizations. The intended use is to be inserted after optimizations to
allow correlations of simulation runs.</p>
</div>
<div class="section" id="id384">
<h5><a class="toc-backref" href="#id1234">Arguments:</a><a class="headerlink" href="#id384" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">id</span></code> is a numerical id identifying the marker.</p>
</div>
<div class="section" id="id385">
<h5><a class="toc-backref" href="#id1235">Semantics:</a><a class="headerlink" href="#id385" title="永久链接至标题">¶</a></h5>
<p>This intrinsic does not modify the behavior of the program. Backends
that do not support this intrinsic may ignore it.</p>
</div>
</div>
<div class="section" id="llvm-readcyclecounter-intrinsic">
<h4><a class="toc-backref" href="#id1236">&#8216;<code class="docutils literal"><span class="pre">llvm.readcyclecounter</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-readcyclecounter-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id386">
<h5><a class="toc-backref" href="#id1237">Syntax:</a><a class="headerlink" href="#id386" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">readcyclecounter</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id387">
<h5><a class="toc-backref" href="#id1238">Overview:</a><a class="headerlink" href="#id387" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.readcyclecounter</span></code>&#8216; intrinsic provides access to the cycle
counter register (or similar low latency, high accuracy clocks) on those
targets that support it. On X86, it should map to RDTSC. On Alpha, it
should map to RPCC. As the backing counters overflow quickly (on the
order of 9 seconds on alpha), this should only be used for small
timings.</p>
</div>
<div class="section" id="id388">
<h5><a class="toc-backref" href="#id1239">Semantics:</a><a class="headerlink" href="#id388" title="永久链接至标题">¶</a></h5>
<p>When directly supported, reading the cycle counter should not modify any
memory. Implementations are allowed to either return a application
specific value or a system wide value. On backends without support, this
is lowered to a constant 0.</p>
<p>Note that runtime support may be conditional on the privilege-level code is
running at and the host platform.</p>
</div>
</div>
<div class="section" id="llvm-clear-cache-intrinsic">
<h4><a class="toc-backref" href="#id1240">&#8216;<code class="docutils literal"><span class="pre">llvm.clear_cache</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-clear-cache-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id389">
<h5><a class="toc-backref" href="#id1241">Syntax:</a><a class="headerlink" href="#id389" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id390">
<h5><a class="toc-backref" href="#id1242">Overview:</a><a class="headerlink" href="#id390" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.clear_cache</span></code>&#8216; intrinsic ensures visibility of modifications
in the specified range to the execution unit of the processor. On
targets with non-unified instruction and data cache, the implementation
flushes the instruction cache.</p>
</div>
<div class="section" id="id391">
<h5><a class="toc-backref" href="#id1243">Semantics:</a><a class="headerlink" href="#id391" title="永久链接至标题">¶</a></h5>
<p>On platforms with coherent instruction and data caches (e.g. x86), this
intrinsic is a nop. On platforms with non-coherent instruction and data
cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate
instructions or a system call, if cache flushing requires special
privileges.</p>
<p>The default behavior is to emit a call to <code class="docutils literal"><span class="pre">__clear_cache</span></code> from the run
time library.</p>
<p>This instrinsic does <em>not</em> empty the instruction pipeline. Modifications
of the current function are outside the scope of the intrinsic.</p>
</div>
</div>
<div class="section" id="llvm-instrprof-increment-intrinsic">
<h4><a class="toc-backref" href="#id1244">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_increment</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-instrprof-increment-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id392">
<h5><a class="toc-backref" href="#id1245">Syntax:</a><a class="headerlink" href="#id392" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">instrprof_increment</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">hash</span><span class="o">&gt;</span><span class="p">,</span>
                                       <span class="n">i32</span> <span class="o">&lt;</span><span class="n">num</span><span class="o">-</span><span class="n">counters</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">index</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id393">
<h5><a class="toc-backref" href="#id1246">Overview:</a><a class="headerlink" href="#id393" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_increment</span></code>&#8216; intrinsic can be emitted by a
frontend for use with instrumentation based profiling. These will be
lowered by the <code class="docutils literal"><span class="pre">-instrprof</span></code> pass to generate execution counts of a
program at runtime.</p>
</div>
<div class="section" id="id394">
<h5><a class="toc-backref" href="#id1247">Arguments:</a><a class="headerlink" href="#id394" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a global variable containing the
name of the entity being instrumented. This should generally be the
(mangled) function name for a set of counters.</p>
<p>The second argument is a hash value that can be used by the consumer
of the profile data to detect changes to the instrumented source, and
the third is the number of counters associated with <code class="docutils literal"><span class="pre">name</span></code>. It is an
error if <code class="docutils literal"><span class="pre">hash</span></code> or <code class="docutils literal"><span class="pre">num-counters</span></code> differ between two instances of
<code class="docutils literal"><span class="pre">instrprof_increment</span></code> that refer to the same name.</p>
<p>The last argument refers to which of the counters for <code class="docutils literal"><span class="pre">name</span></code> should
be incremented. It should be a value between 0 and <code class="docutils literal"><span class="pre">num-counters</span></code>.</p>
</div>
<div class="section" id="id395">
<h5><a class="toc-backref" href="#id1248">Semantics:</a><a class="headerlink" href="#id395" title="永久链接至标题">¶</a></h5>
<p>This intrinsic represents an increment of a profiling counter. It will
cause the <code class="docutils literal"><span class="pre">-instrprof</span></code> pass to generate the appropriate data
structures and the code to increment the appropriate value, in a
format that can be written out by a compiler runtime and consumed via
the <code class="docutils literal"><span class="pre">llvm-profdata</span></code> tool.</p>
</div>
</div>
<div class="section" id="llvm-instrprof-value-profile-intrinsic">
<h4><a class="toc-backref" href="#id1249">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-instrprof-value-profile-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id396">
<h5><a class="toc-backref" href="#id1250">Syntax:</a><a class="headerlink" href="#id396" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">instrprof_value_profile</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">hash</span><span class="o">&gt;</span><span class="p">,</span>
                                           <span class="n">i64</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">value_kind</span><span class="o">&gt;</span><span class="p">,</span>
                                           <span class="n">i32</span> <span class="o">&lt;</span><span class="n">index</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id397">
<h5><a class="toc-backref" href="#id1251">Overview:</a><a class="headerlink" href="#id397" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code>&#8216; intrinsic can be emitted by a
frontend for use with instrumentation based profiling. This will be
lowered by the <code class="docutils literal"><span class="pre">-instrprof</span></code> pass to find out the target values,
instrumented expressions take in a program at runtime.</p>
</div>
<div class="section" id="id398">
<h5><a class="toc-backref" href="#id1252">Arguments:</a><a class="headerlink" href="#id398" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a global variable containing the
name of the entity being instrumented. <code class="docutils literal"><span class="pre">name</span></code> should generally be the
(mangled) function name for a set of counters.</p>
<p>The second argument is a hash value that can be used by the consumer
of the profile data to detect changes to the instrumented source. It
is an error if <code class="docutils literal"><span class="pre">hash</span></code> differs between two instances of
<code class="docutils literal"><span class="pre">llvm.instrprof_*</span></code> that refer to the same name.</p>
<p>The third argument is the value of the expression being profiled. The profiled
expression&#8217;s value should be representable as an unsigned 64-bit value. The
fourth argument represents the kind of value profiling that is being done. The
supported value profiling kinds are enumerated through the
<code class="docutils literal"><span class="pre">InstrProfValueKind</span></code> type declared in the
<code class="docutils literal"><span class="pre">&lt;include/llvm/ProfileData/InstrProf.h&gt;</span></code> header file. The last argument is the
index of the instrumented expression within <code class="docutils literal"><span class="pre">name</span></code>. It should be &gt;= 0.</p>
</div>
<div class="section" id="id399">
<h5><a class="toc-backref" href="#id1253">Semantics:</a><a class="headerlink" href="#id399" title="永久链接至标题">¶</a></h5>
<p>This intrinsic represents the point where a call to a runtime routine
should be inserted for value profiling of target expressions. <code class="docutils literal"><span class="pre">-instrprof</span></code>
pass will generate the appropriate data structures and replace the
<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code> intrinsic with the call to the profile
runtime library with proper arguments.</p>
</div>
</div>
</div>
<div class="section" id="standard-c-library-intrinsics">
<h3><a class="toc-backref" href="#id1254">Standard C Library Intrinsics</a><a class="headerlink" href="#standard-c-library-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for a few important standard C library
functions. These intrinsics allow source-language front-ends to pass
information about the alignment of the pointer arguments to the code
generator, providing opportunity for more efficient code generation.</p>
<div class="section" id="llvm-memcpy-intrinsic">
<span id="int-memcpy"></span><h4><a class="toc-backref" href="#id1255">&#8216;<code class="docutils literal"><span class="pre">llvm.memcpy</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-memcpy-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id400">
<h5><a class="toc-backref" href="#id1256">Syntax:</a><a class="headerlink" href="#id400" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.memcpy</span></code> on any
integer bit width and for different address spaces. Not all targets
support all bit widths however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memcpy</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">i32</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memcpy</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id401">
<h5><a class="toc-backref" href="#id1257">Overview:</a><a class="headerlink" href="#id401" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memcpy.*</span></code>&#8216; intrinsics copy a block of memory from the
source location to the destination location.</p>
<p>Note that, unlike the standard libc function, the <code class="docutils literal"><span class="pre">llvm.memcpy.*</span></code>
intrinsics do not return a value, takes extra alignment/isvolatile
arguments and the pointers can be in specified address spaces.</p>
</div>
<div class="section" id="id402">
<h5><a class="toc-backref" href="#id1258">Arguments:</a><a class="headerlink" href="#id402" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to the destination, the second is a
pointer to the source. The third argument is an integer argument
specifying the number of bytes to copy, the fourth argument is the
alignment of the source and destination locations, and the fifth is a
boolean indicating a volatile access.</p>
<p>If the call to this intrinsic has an alignment value that is not 0 or 1,
then the caller guarantees that both the source and destination pointers
are aligned to that boundary.</p>
<p>If the <code class="docutils literal"><span class="pre">isvolatile</span></code> parameter is <code class="docutils literal"><span class="pre">true</span></code>, the <code class="docutils literal"><span class="pre">llvm.memcpy</span></code> call is
a <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operation</span></a>. The detailed access behavior is not
very cleanly specified and it is unwise to depend on it.</p>
</div>
<div class="section" id="id403">
<h5><a class="toc-backref" href="#id1259">Semantics:</a><a class="headerlink" href="#id403" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memcpy.*</span></code>&#8216; intrinsics copy a block of memory from the
source location to the destination location, which are not allowed to
overlap. It copies &#8220;len&#8221; bytes of memory over. If the argument is known
to be aligned to some boundary, this can be specified as the fourth
argument, otherwise it should be set to 0 or 1 (both meaning no alignment).</p>
</div>
</div>
<div class="section" id="llvm-memmove-intrinsic">
<h4><a class="toc-backref" href="#id1260">&#8216;<code class="docutils literal"><span class="pre">llvm.memmove</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-memmove-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id404">
<h5><a class="toc-backref" href="#id1261">Syntax:</a><a class="headerlink" href="#id404" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use llvm.memmove on any integer
bit width and for different address space. Not all targets support all
bit widths however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memmove</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                         <span class="n">i32</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memmove</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                         <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id405">
<h5><a class="toc-backref" href="#id1262">Overview:</a><a class="headerlink" href="#id405" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memmove.*</span></code>&#8216; intrinsics move a block of memory from the
source location to the destination location. It is similar to the
&#8216;<code class="docutils literal"><span class="pre">llvm.memcpy</span></code>&#8216; intrinsic but allows the two memory locations to
overlap.</p>
<p>Note that, unlike the standard libc function, the <code class="docutils literal"><span class="pre">llvm.memmove.*</span></code>
intrinsics do not return a value, takes extra alignment/isvolatile
arguments and the pointers can be in specified address spaces.</p>
</div>
<div class="section" id="id406">
<h5><a class="toc-backref" href="#id1263">Arguments:</a><a class="headerlink" href="#id406" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to the destination, the second is a
pointer to the source. The third argument is an integer argument
specifying the number of bytes to copy, the fourth argument is the
alignment of the source and destination locations, and the fifth is a
boolean indicating a volatile access.</p>
<p>If the call to this intrinsic has an alignment value that is not 0 or 1,
then the caller guarantees that the source and destination pointers are
aligned to that boundary.</p>
<p>If the <code class="docutils literal"><span class="pre">isvolatile</span></code> parameter is <code class="docutils literal"><span class="pre">true</span></code>, the <code class="docutils literal"><span class="pre">llvm.memmove</span></code> call
is a <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operation</span></a>. The detailed access behavior is
not very cleanly specified and it is unwise to depend on it.</p>
</div>
<div class="section" id="id407">
<h5><a class="toc-backref" href="#id1264">Semantics:</a><a class="headerlink" href="#id407" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memmove.*</span></code>&#8216; intrinsics copy a block of memory from the
source location to the destination location, which may overlap. It
copies &#8220;len&#8221; bytes of memory over. If the argument is known to be
aligned to some boundary, this can be specified as the fourth argument,
otherwise it should be set to 0 or 1 (both meaning no alignment).</p>
</div>
</div>
<div class="section" id="llvm-memset-intrinsics">
<h4><a class="toc-backref" href="#id1265">&#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-memset-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id408">
<h5><a class="toc-backref" href="#id1266">Syntax:</a><a class="headerlink" href="#id408" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use llvm.memset on any integer
bit width and for different address spaces. However, not all targets
support all bit widths.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memset</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">i32</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memset</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id409">
<h5><a class="toc-backref" href="#id1267">Overview:</a><a class="headerlink" href="#id409" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; intrinsics fill a block of memory with a
particular byte value.</p>
<p>Note that, unlike the standard libc function, the <code class="docutils literal"><span class="pre">llvm.memset</span></code>
intrinsic does not return a value and takes extra alignment/volatile
arguments. Also, the destination can be in an arbitrary address space.</p>
</div>
<div class="section" id="id410">
<h5><a class="toc-backref" href="#id1268">Arguments:</a><a class="headerlink" href="#id410" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to the destination to fill, the second
is the byte value with which to fill it, the third argument is an
integer argument specifying the number of bytes to fill, and the fourth
argument is the known alignment of the destination location.</p>
<p>If the call to this intrinsic has an alignment value that is not 0 or 1,
then the caller guarantees that the destination pointer is aligned to
that boundary.</p>
<p>If the <code class="docutils literal"><span class="pre">isvolatile</span></code> parameter is <code class="docutils literal"><span class="pre">true</span></code>, the <code class="docutils literal"><span class="pre">llvm.memset</span></code> call is
a <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operation</span></a>. The detailed access behavior is not
very cleanly specified and it is unwise to depend on it.</p>
</div>
<div class="section" id="id411">
<h5><a class="toc-backref" href="#id1269">Semantics:</a><a class="headerlink" href="#id411" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; intrinsics fill &#8220;len&#8221; bytes of memory starting
at the destination location. If the argument is known to be aligned to
some boundary, this can be specified as the fourth argument, otherwise
it should be set to 0 or 1 (both meaning no alignment).</p>
</div>
</div>
<div class="section" id="llvm-sqrt-intrinsic">
<h4><a class="toc-backref" href="#id1270">&#8216;<code class="docutils literal"><span class="pre">llvm.sqrt.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-sqrt-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id412">
<h5><a class="toc-backref" href="#id1271">Syntax:</a><a class="headerlink" href="#id412" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.sqrt</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id413">
<h5><a class="toc-backref" href="#id1272">Overview:</a><a class="headerlink" href="#id413" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sqrt</span></code>&#8216; intrinsics return the sqrt of the specified operand,
returning the same value as the libm &#8216;<code class="docutils literal"><span class="pre">sqrt</span></code>&#8216; functions would. Unlike
<code class="docutils literal"><span class="pre">sqrt</span></code> in libm, however, <code class="docutils literal"><span class="pre">llvm.sqrt</span></code> has undefined behavior for
negative numbers other than -0.0 (which allows for better optimization,
because there is no need to worry about errno being set).
<code class="docutils literal"><span class="pre">llvm.sqrt(-0.0)</span></code> is defined to return -0.0 like IEEE sqrt.</p>
</div>
<div class="section" id="id414">
<h5><a class="toc-backref" href="#id1273">Arguments:</a><a class="headerlink" href="#id414" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id415">
<h5><a class="toc-backref" href="#id1274">Semantics:</a><a class="headerlink" href="#id415" title="永久链接至标题">¶</a></h5>
<p>This function returns the sqrt of the specified operand if it is a
nonnegative floating point number.</p>
</div>
</div>
<div class="section" id="llvm-powi-intrinsic">
<h4><a class="toc-backref" href="#id1275">&#8216;<code class="docutils literal"><span class="pre">llvm.powi.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-powi-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id416">
<h5><a class="toc-backref" href="#id1276">Syntax:</a><a class="headerlink" href="#id416" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.powi</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id417">
<h5><a class="toc-backref" href="#id1277">Overview:</a><a class="headerlink" href="#id417" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.powi.*</span></code>&#8216; intrinsics return the first operand raised to the
specified (positive or negative) power. The order of evaluation of
multiplications is not defined. When a vector of floating point type is
used, the second argument remains a scalar integer value.</p>
</div>
<div class="section" id="id418">
<h5><a class="toc-backref" href="#id1278">Arguments:</a><a class="headerlink" href="#id418" title="永久链接至标题">¶</a></h5>
<p>The second argument is an integer power, and the first is a value to
raise to that power.</p>
</div>
<div class="section" id="id419">
<h5><a class="toc-backref" href="#id1279">Semantics:</a><a class="headerlink" href="#id419" title="永久链接至标题">¶</a></h5>
<p>This function returns the first value raised to the second power with an
unspecified sequence of rounding operations.</p>
</div>
</div>
<div class="section" id="llvm-sin-intrinsic">
<h4><a class="toc-backref" href="#id1280">&#8216;<code class="docutils literal"><span class="pre">llvm.sin.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-sin-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id420">
<h5><a class="toc-backref" href="#id1281">Syntax:</a><a class="headerlink" href="#id420" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.sin</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id421">
<h5><a class="toc-backref" href="#id1282">Overview:</a><a class="headerlink" href="#id421" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sin.*</span></code>&#8216; intrinsics return the sine of the operand.</p>
</div>
<div class="section" id="id422">
<h5><a class="toc-backref" href="#id1283">Arguments:</a><a class="headerlink" href="#id422" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id423">
<h5><a class="toc-backref" href="#id1284">Semantics:</a><a class="headerlink" href="#id423" title="永久链接至标题">¶</a></h5>
<p>This function returns the sine of the specified operand, returning the
same values as the libm <code class="docutils literal"><span class="pre">sin</span></code> functions would, and handles error
conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-cos-intrinsic">
<h4><a class="toc-backref" href="#id1285">&#8216;<code class="docutils literal"><span class="pre">llvm.cos.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-cos-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id424">
<h5><a class="toc-backref" href="#id1286">Syntax:</a><a class="headerlink" href="#id424" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.cos</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id425">
<h5><a class="toc-backref" href="#id1287">Overview:</a><a class="headerlink" href="#id425" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.cos.*</span></code>&#8216; intrinsics return the cosine of the operand.</p>
</div>
<div class="section" id="id426">
<h5><a class="toc-backref" href="#id1288">Arguments:</a><a class="headerlink" href="#id426" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id427">
<h5><a class="toc-backref" href="#id1289">Semantics:</a><a class="headerlink" href="#id427" title="永久链接至标题">¶</a></h5>
<p>This function returns the cosine of the specified operand, returning the
same values as the libm <code class="docutils literal"><span class="pre">cos</span></code> functions would, and handles error
conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-pow-intrinsic">
<h4><a class="toc-backref" href="#id1290">&#8216;<code class="docutils literal"><span class="pre">llvm.pow.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-pow-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id428">
<h5><a class="toc-backref" href="#id1291">Syntax:</a><a class="headerlink" href="#id428" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.pow</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="n">Power</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id429">
<h5><a class="toc-backref" href="#id1292">Overview:</a><a class="headerlink" href="#id429" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.pow.*</span></code>&#8216; intrinsics return the first operand raised to the
specified (positive or negative) power.</p>
</div>
<div class="section" id="id430">
<h5><a class="toc-backref" href="#id1293">Arguments:</a><a class="headerlink" href="#id430" title="永久链接至标题">¶</a></h5>
<p>The second argument is a floating point power, and the first is a value
to raise to that power.</p>
</div>
<div class="section" id="id431">
<h5><a class="toc-backref" href="#id1294">Semantics:</a><a class="headerlink" href="#id431" title="永久链接至标题">¶</a></h5>
<p>This function returns the first value raised to the second power,
returning the same values as the libm <code class="docutils literal"><span class="pre">pow</span></code> functions would, and
handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-exp-intrinsic">
<h4><a class="toc-backref" href="#id1295">&#8216;<code class="docutils literal"><span class="pre">llvm.exp.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-exp-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id432">
<h5><a class="toc-backref" href="#id1296">Syntax:</a><a class="headerlink" href="#id432" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.exp</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id433">
<h5><a class="toc-backref" href="#id1297">Overview:</a><a class="headerlink" href="#id433" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.exp.*</span></code>&#8216; intrinsics perform the exp function.</p>
</div>
<div class="section" id="id434">
<h5><a class="toc-backref" href="#id1298">Arguments:</a><a class="headerlink" href="#id434" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id435">
<h5><a class="toc-backref" href="#id1299">Semantics:</a><a class="headerlink" href="#id435" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">exp</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-exp2-intrinsic">
<h4><a class="toc-backref" href="#id1300">&#8216;<code class="docutils literal"><span class="pre">llvm.exp2.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-exp2-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id436">
<h5><a class="toc-backref" href="#id1301">Syntax:</a><a class="headerlink" href="#id436" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.exp2</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id437">
<h5><a class="toc-backref" href="#id1302">Overview:</a><a class="headerlink" href="#id437" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.exp2.*</span></code>&#8216; intrinsics perform the exp2 function.</p>
</div>
<div class="section" id="id438">
<h5><a class="toc-backref" href="#id1303">Arguments:</a><a class="headerlink" href="#id438" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id439">
<h5><a class="toc-backref" href="#id1304">Semantics:</a><a class="headerlink" href="#id439" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">exp2</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-log-intrinsic">
<h4><a class="toc-backref" href="#id1305">&#8216;<code class="docutils literal"><span class="pre">llvm.log.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-log-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id440">
<h5><a class="toc-backref" href="#id1306">Syntax:</a><a class="headerlink" href="#id440" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.log</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id441">
<h5><a class="toc-backref" href="#id1307">Overview:</a><a class="headerlink" href="#id441" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.log.*</span></code>&#8216; intrinsics perform the log function.</p>
</div>
<div class="section" id="id442">
<h5><a class="toc-backref" href="#id1308">Arguments:</a><a class="headerlink" href="#id442" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id443">
<h5><a class="toc-backref" href="#id1309">Semantics:</a><a class="headerlink" href="#id443" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">log</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-log10-intrinsic">
<h4><a class="toc-backref" href="#id1310">&#8216;<code class="docutils literal"><span class="pre">llvm.log10.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-log10-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id444">
<h5><a class="toc-backref" href="#id1311">Syntax:</a><a class="headerlink" href="#id444" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.log10</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id445">
<h5><a class="toc-backref" href="#id1312">Overview:</a><a class="headerlink" href="#id445" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.log10.*</span></code>&#8216; intrinsics perform the log10 function.</p>
</div>
<div class="section" id="id446">
<h5><a class="toc-backref" href="#id1313">Arguments:</a><a class="headerlink" href="#id446" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id447">
<h5><a class="toc-backref" href="#id1314">Semantics:</a><a class="headerlink" href="#id447" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">log10</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-log2-intrinsic">
<h4><a class="toc-backref" href="#id1315">&#8216;<code class="docutils literal"><span class="pre">llvm.log2.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-log2-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id448">
<h5><a class="toc-backref" href="#id1316">Syntax:</a><a class="headerlink" href="#id448" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.log2</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id449">
<h5><a class="toc-backref" href="#id1317">Overview:</a><a class="headerlink" href="#id449" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.log2.*</span></code>&#8216; intrinsics perform the log2 function.</p>
</div>
<div class="section" id="id450">
<h5><a class="toc-backref" href="#id1318">Arguments:</a><a class="headerlink" href="#id450" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id451">
<h5><a class="toc-backref" href="#id1319">Semantics:</a><a class="headerlink" href="#id451" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">log2</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-fma-intrinsic">
<h4><a class="toc-backref" href="#id1320">&#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-fma-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id452">
<h5><a class="toc-backref" href="#id1321">Syntax:</a><a class="headerlink" href="#id452" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.fma</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id453">
<h5><a class="toc-backref" href="#id1322">Overview:</a><a class="headerlink" href="#id453" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216; intrinsics perform the fused multiply-add
operation.</p>
</div>
<div class="section" id="id454">
<h5><a class="toc-backref" href="#id1323">Arguments:</a><a class="headerlink" href="#id454" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id455">
<h5><a class="toc-backref" href="#id1324">Semantics:</a><a class="headerlink" href="#id455" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">fma</span></code> functions
would, and does not set errno.</p>
</div>
</div>
<div class="section" id="llvm-fabs-intrinsic">
<h4><a class="toc-backref" href="#id1325">&#8216;<code class="docutils literal"><span class="pre">llvm.fabs.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-fabs-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id456">
<h5><a class="toc-backref" href="#id1326">Syntax:</a><a class="headerlink" href="#id456" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.fabs</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id457">
<h5><a class="toc-backref" href="#id1327">Overview:</a><a class="headerlink" href="#id457" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fabs.*</span></code>&#8216; intrinsics return the absolute value of the
operand.</p>
</div>
<div class="section" id="id458">
<h5><a class="toc-backref" href="#id1328">Arguments:</a><a class="headerlink" href="#id458" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id459">
<h5><a class="toc-backref" href="#id1329">Semantics:</a><a class="headerlink" href="#id459" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">fabs</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-minnum-intrinsic">
<h4><a class="toc-backref" href="#id1330">&#8216;<code class="docutils literal"><span class="pre">llvm.minnum.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-minnum-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id460">
<h5><a class="toc-backref" href="#id1331">Syntax:</a><a class="headerlink" href="#id460" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.minnum</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id461">
<h5><a class="toc-backref" href="#id1332">Overview:</a><a class="headerlink" href="#id461" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.minnum.*</span></code>&#8216; intrinsics return the minimum of the two
arguments.</p>
</div>
<div class="section" id="id462">
<h5><a class="toc-backref" href="#id1333">Arguments:</a><a class="headerlink" href="#id462" title="永久链接至标题">¶</a></h5>
<p>The arguments and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id463">
<h5><a class="toc-backref" href="#id1334">Semantics:</a><a class="headerlink" href="#id463" title="永久链接至标题">¶</a></h5>
<p>Follows the IEEE-754 semantics for minNum, which also match for libm&#8217;s
fmin.</p>
<p>If either operand is a NaN, returns the other non-NaN operand. Returns
NaN only if both operands are NaN. If the operands compare equal,
returns a value that compares equal to both operands. This means that
fmin(+/-0.0, +/-0.0) could return either -0.0 or 0.0.</p>
</div>
</div>
<div class="section" id="llvm-maxnum-intrinsic">
<h4><a class="toc-backref" href="#id1335">&#8216;<code class="docutils literal"><span class="pre">llvm.maxnum.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-maxnum-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id464">
<h5><a class="toc-backref" href="#id1336">Syntax:</a><a class="headerlink" href="#id464" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.maxnum</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">Val1l</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id465">
<h5><a class="toc-backref" href="#id1337">Overview:</a><a class="headerlink" href="#id465" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.maxnum.*</span></code>&#8216; intrinsics return the maximum of the two
arguments.</p>
</div>
<div class="section" id="id466">
<h5><a class="toc-backref" href="#id1338">Arguments:</a><a class="headerlink" href="#id466" title="永久链接至标题">¶</a></h5>
<p>The arguments and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id467">
<h5><a class="toc-backref" href="#id1339">Semantics:</a><a class="headerlink" href="#id467" title="永久链接至标题">¶</a></h5>
<p>Follows the IEEE-754 semantics for maxNum, which also match for libm&#8217;s
fmax.</p>
<p>If either operand is a NaN, returns the other non-NaN operand. Returns
NaN only if both operands are NaN. If the operands compare equal,
returns a value that compares equal to both operands. This means that
fmax(+/-0.0, +/-0.0) could return either -0.0 or 0.0.</p>
</div>
</div>
<div class="section" id="llvm-copysign-intrinsic">
<h4><a class="toc-backref" href="#id1340">&#8216;<code class="docutils literal"><span class="pre">llvm.copysign.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-copysign-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id468">
<h5><a class="toc-backref" href="#id1341">Syntax:</a><a class="headerlink" href="#id468" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.copysign</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id469">
<h5><a class="toc-backref" href="#id1342">Overview:</a><a class="headerlink" href="#id469" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.copysign.*</span></code>&#8216; intrinsics return a value with the magnitude of the
first operand and the sign of the second operand.</p>
</div>
<div class="section" id="id470">
<h5><a class="toc-backref" href="#id1343">Arguments:</a><a class="headerlink" href="#id470" title="永久链接至标题">¶</a></h5>
<p>The arguments and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id471">
<h5><a class="toc-backref" href="#id1344">Semantics:</a><a class="headerlink" href="#id471" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">copysign</span></code>
functions would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-floor-intrinsic">
<h4><a class="toc-backref" href="#id1345">&#8216;<code class="docutils literal"><span class="pre">llvm.floor.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-floor-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id472">
<h5><a class="toc-backref" href="#id1346">Syntax:</a><a class="headerlink" href="#id472" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.floor</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id473">
<h5><a class="toc-backref" href="#id1347">Overview:</a><a class="headerlink" href="#id473" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.floor.*</span></code>&#8216; intrinsics return the floor of the operand.</p>
</div>
<div class="section" id="id474">
<h5><a class="toc-backref" href="#id1348">Arguments:</a><a class="headerlink" href="#id474" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id475">
<h5><a class="toc-backref" href="#id1349">Semantics:</a><a class="headerlink" href="#id475" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">floor</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-ceil-intrinsic">
<h4><a class="toc-backref" href="#id1350">&#8216;<code class="docutils literal"><span class="pre">llvm.ceil.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ceil-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id476">
<h5><a class="toc-backref" href="#id1351">Syntax:</a><a class="headerlink" href="#id476" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.ceil</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id477">
<h5><a class="toc-backref" href="#id1352">Overview:</a><a class="headerlink" href="#id477" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ceil.*</span></code>&#8216; intrinsics return the ceiling of the operand.</p>
</div>
<div class="section" id="id478">
<h5><a class="toc-backref" href="#id1353">Arguments:</a><a class="headerlink" href="#id478" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id479">
<h5><a class="toc-backref" href="#id1354">Semantics:</a><a class="headerlink" href="#id479" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">ceil</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-trunc-intrinsic">
<h4><a class="toc-backref" href="#id1355">&#8216;<code class="docutils literal"><span class="pre">llvm.trunc.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-trunc-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id480">
<h5><a class="toc-backref" href="#id1356">Syntax:</a><a class="headerlink" href="#id480" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.trunc</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id481">
<h5><a class="toc-backref" href="#id1357">Overview:</a><a class="headerlink" href="#id481" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.trunc.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer not larger in magnitude than the operand.</p>
</div>
<div class="section" id="id482">
<h5><a class="toc-backref" href="#id1358">Arguments:</a><a class="headerlink" href="#id482" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id483">
<h5><a class="toc-backref" href="#id1359">Semantics:</a><a class="headerlink" href="#id483" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">trunc</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-rint-intrinsic">
<h4><a class="toc-backref" href="#id1360">&#8216;<code class="docutils literal"><span class="pre">llvm.rint.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-rint-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id484">
<h5><a class="toc-backref" href="#id1361">Syntax:</a><a class="headerlink" href="#id484" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.rint</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id485">
<h5><a class="toc-backref" href="#id1362">Overview:</a><a class="headerlink" href="#id485" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.rint.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer. It may raise an inexact floating-point exception if the
operand isn&#8217;t an integer.</p>
</div>
<div class="section" id="id486">
<h5><a class="toc-backref" href="#id1363">Arguments:</a><a class="headerlink" href="#id486" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id487">
<h5><a class="toc-backref" href="#id1364">Semantics:</a><a class="headerlink" href="#id487" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">rint</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-nearbyint-intrinsic">
<h4><a class="toc-backref" href="#id1365">&#8216;<code class="docutils literal"><span class="pre">llvm.nearbyint.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-nearbyint-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id488">
<h5><a class="toc-backref" href="#id1366">Syntax:</a><a class="headerlink" href="#id488" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.nearbyint</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id489">
<h5><a class="toc-backref" href="#id1367">Overview:</a><a class="headerlink" href="#id489" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.nearbyint.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer.</p>
</div>
<div class="section" id="id490">
<h5><a class="toc-backref" href="#id1368">Arguments:</a><a class="headerlink" href="#id490" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id491">
<h5><a class="toc-backref" href="#id1369">Semantics:</a><a class="headerlink" href="#id491" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">nearbyint</span></code>
functions would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-round-intrinsic">
<h4><a class="toc-backref" href="#id1370">&#8216;<code class="docutils literal"><span class="pre">llvm.round.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-round-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id492">
<h5><a class="toc-backref" href="#id1371">Syntax:</a><a class="headerlink" href="#id492" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.round</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id493">
<h5><a class="toc-backref" href="#id1372">Overview:</a><a class="headerlink" href="#id493" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.round.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer.</p>
</div>
<div class="section" id="id494">
<h5><a class="toc-backref" href="#id1373">Arguments:</a><a class="headerlink" href="#id494" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id495">
<h5><a class="toc-backref" href="#id1374">Semantics:</a><a class="headerlink" href="#id495" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">round</span></code>
functions would, and handles error conditions in the same way.</p>
</div>
</div>
</div>
<div class="section" id="bit-manipulation-intrinsics">
<h3><a class="toc-backref" href="#id1375">Bit Manipulation Intrinsics</a><a class="headerlink" href="#bit-manipulation-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for a few important bit manipulation
operations. These allow efficient code generation for some algorithms.</p>
<div class="section" id="llvm-bitreverse-intrinsics">
<h4><a class="toc-backref" href="#id1376">&#8216;<code class="docutils literal"><span class="pre">llvm.bitreverse.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-bitreverse-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id496">
<h5><a class="toc-backref" href="#id1377">Syntax:</a><a class="headerlink" href="#id496" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic function. You can use bitreverse on any
integer type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitreverse</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitreverse</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitreverse</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id497">
<h5><a class="toc-backref" href="#id1378">Overview:</a><a class="headerlink" href="#id497" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.bitreverse</span></code>&#8216; family of intrinsics is used to reverse the
bitpattern of an integer value; for example <code class="docutils literal"><span class="pre">0b1234567</span></code> becomes
<code class="docutils literal"><span class="pre">0b7654321</span></code>.</p>
</div>
<div class="section" id="id498">
<h5><a class="toc-backref" href="#id1379">Semantics:</a><a class="headerlink" href="#id498" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.bitreverse.iN</span></code> intrinsic returns an i16 value that has bit
<code class="docutils literal"><span class="pre">M</span></code> in the input moved to bit <code class="docutils literal"><span class="pre">N-M</span></code> in the output.</p>
</div>
</div>
<div class="section" id="llvm-bswap-intrinsics">
<h4><a class="toc-backref" href="#id1380">&#8216;<code class="docutils literal"><span class="pre">llvm.bswap.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-bswap-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id499">
<h5><a class="toc-backref" href="#id1381">Syntax:</a><a class="headerlink" href="#id499" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic function. You can use bswap on any
integer type that is an even number of bytes (i.e. BitWidth % 16 == 0).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bswap</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bswap</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bswap</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id500">
<h5><a class="toc-backref" href="#id1382">Overview:</a><a class="headerlink" href="#id500" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.bswap</span></code>&#8216; family of intrinsics is used to byte swap integer
values with an even number of bytes (positive multiple of 16 bits).
These are useful for performing operations on data that is not in the
target&#8217;s native byte order.</p>
</div>
<div class="section" id="id501">
<h5><a class="toc-backref" href="#id1383">Semantics:</a><a class="headerlink" href="#id501" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.bswap.i16</span></code> intrinsic returns an i16 value that has the high
and low byte of the input i16 swapped. Similarly, the <code class="docutils literal"><span class="pre">llvm.bswap.i32</span></code>
intrinsic returns an i32 value that has the four bytes of the input i32
swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the
returned i32 will have its bytes in 3, 2, 1, 0 order. The
<code class="docutils literal"><span class="pre">llvm.bswap.i48</span></code>, <code class="docutils literal"><span class="pre">llvm.bswap.i64</span></code> and other intrinsics extend this
concept to additional even-byte lengths (6 bytes, 8 bytes and more,
respectively).</p>
</div>
</div>
<div class="section" id="llvm-ctpop-intrinsic">
<h4><a class="toc-backref" href="#id1384">&#8216;<code class="docutils literal"><span class="pre">llvm.ctpop.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ctpop-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id502">
<h5><a class="toc-backref" href="#id1385">Syntax:</a><a class="headerlink" href="#id502" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use llvm.ctpop on any integer
bit width, or on any vector with integer elements. Not all targets
support all bit widths or vector types, however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i8</span><span class="p">(</span><span class="n">i8</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">v2i32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id503">
<h5><a class="toc-backref" href="#id1386">Overview:</a><a class="headerlink" href="#id503" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctpop</span></code>&#8216; family of intrinsics counts the number of bits set
in a value.</p>
</div>
<div class="section" id="id504">
<h5><a class="toc-backref" href="#id1387">Arguments:</a><a class="headerlink" href="#id504" title="永久链接至标题">¶</a></h5>
<p>The only argument is the value to be counted. The argument may be of any
integer type, or a vector with integer elements. The return type must
match the argument type.</p>
</div>
<div class="section" id="id505">
<h5><a class="toc-backref" href="#id1388">Semantics:</a><a class="headerlink" href="#id505" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctpop</span></code>&#8216; intrinsic counts the 1&#8217;s in a variable, or within
each element of a vector.</p>
</div>
</div>
<div class="section" id="llvm-ctlz-intrinsic">
<h4><a class="toc-backref" href="#id1389">&#8216;<code class="docutils literal"><span class="pre">llvm.ctlz.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ctlz-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id506">
<h5><a class="toc-backref" href="#id1390">Syntax:</a><a class="headerlink" href="#id506" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.ctlz</span></code> on any
integer bit width, or any vector whose elements are integers. Not all
targets support all bit widths or vector types, however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span>   <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i8</span>  <span class="p">(</span><span class="n">i8</span>   <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i16</span> <span class="p">(</span><span class="n">i16</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i32</span> <span class="p">(</span><span class="n">i32</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i64</span> <span class="p">(</span><span class="n">i64</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declase</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">v2i32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id507">
<h5><a class="toc-backref" href="#id1391">Overview:</a><a class="headerlink" href="#id507" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctlz</span></code>&#8216; family of intrinsic functions counts the number of
leading zeros in a variable.</p>
</div>
<div class="section" id="id508">
<h5><a class="toc-backref" href="#id1392">Arguments:</a><a class="headerlink" href="#id508" title="永久链接至标题">¶</a></h5>
<p>The first argument is the value to be counted. This argument may be of
any integer type, or a vector with integer element type. The return
type must match the first argument type.</p>
<p>The second argument must be a constant and is a flag to indicate whether
the intrinsic should ensure that a zero as the first argument produces a
defined result. Historically some architectures did not provide a
defined result for zero values as efficiently, and many algorithms are
now predicated on avoiding zero-value inputs.</p>
</div>
<div class="section" id="id509">
<h5><a class="toc-backref" href="#id1393">Semantics:</a><a class="headerlink" href="#id509" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctlz</span></code>&#8216; intrinsic counts the leading (most significant)
zeros in a variable, or within each element of the vector. If
<code class="docutils literal"><span class="pre">src</span> <span class="pre">==</span> <span class="pre">0</span></code> then the result is the size in bits of the type of <code class="docutils literal"><span class="pre">src</span></code>
if <code class="docutils literal"><span class="pre">is_zero_undef</span> <span class="pre">==</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">undef</span></code> otherwise. For example,
<code class="docutils literal"><span class="pre">llvm.ctlz(i32</span> <span class="pre">2)</span> <span class="pre">=</span> <span class="pre">30</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-cttz-intrinsic">
<h4><a class="toc-backref" href="#id1394">&#8216;<code class="docutils literal"><span class="pre">llvm.cttz.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-cttz-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id510">
<h5><a class="toc-backref" href="#id1395">Syntax:</a><a class="headerlink" href="#id510" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.cttz</span></code> on any
integer bit width, or any vector of integer elements. Not all targets
support all bit widths or vector types, however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span>   <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i8</span>  <span class="p">(</span><span class="n">i8</span>   <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i16</span> <span class="p">(</span><span class="n">i16</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i32</span> <span class="p">(</span><span class="n">i32</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i64</span> <span class="p">(</span><span class="n">i64</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declase</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">v2i32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id511">
<h5><a class="toc-backref" href="#id1396">Overview:</a><a class="headerlink" href="#id511" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.cttz</span></code>&#8216; family of intrinsic functions counts the number of
trailing zeros.</p>
</div>
<div class="section" id="id512">
<h5><a class="toc-backref" href="#id1397">Arguments:</a><a class="headerlink" href="#id512" title="永久链接至标题">¶</a></h5>
<p>The first argument is the value to be counted. This argument may be of
any integer type, or a vector with integer element type. The return
type must match the first argument type.</p>
<p>The second argument must be a constant and is a flag to indicate whether
the intrinsic should ensure that a zero as the first argument produces a
defined result. Historically some architectures did not provide a
defined result for zero values as efficiently, and many algorithms are
now predicated on avoiding zero-value inputs.</p>
</div>
<div class="section" id="id513">
<h5><a class="toc-backref" href="#id1398">Semantics:</a><a class="headerlink" href="#id513" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.cttz</span></code>&#8216; intrinsic counts the trailing (least significant)
zeros in a variable, or within each element of a vector. If <code class="docutils literal"><span class="pre">src</span> <span class="pre">==</span> <span class="pre">0</span></code>
then the result is the size in bits of the type of <code class="docutils literal"><span class="pre">src</span></code> if
<code class="docutils literal"><span class="pre">is_zero_undef</span> <span class="pre">==</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">undef</span></code> otherwise. For example,
<code class="docutils literal"><span class="pre">llvm.cttz(2)</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="arithmetic-with-overflow-intrinsics">
<span id="int-overflow"></span><h3><a class="toc-backref" href="#id1399">Arithmetic with Overflow Intrinsics</a><a class="headerlink" href="#arithmetic-with-overflow-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for some arithmetic with overflow operations.</p>
<div class="section" id="llvm-sadd-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1400">&#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-sadd-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id514">
<h5><a class="toc-backref" href="#id1401">Syntax:</a><a class="headerlink" href="#id514" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.sadd.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id515">
<h5><a class="toc-backref" href="#id1402">Overview:</a><a class="headerlink" href="#id515" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed addition of the two arguments, and indicate whether an overflow
occurred during the signed summation.</p>
</div>
<div class="section" id="id516">
<h5><a class="toc-backref" href="#id1403">Arguments:</a><a class="headerlink" href="#id516" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo signed
addition.</p>
</div>
<div class="section" id="id517">
<h5><a class="toc-backref" href="#id1404">Semantics:</a><a class="headerlink" href="#id517" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed addition of the two variables. They return a structure &#8212; the
first element of which is the signed summation, and the second element
of which is a bit specifying if the signed summation resulted in an
overflow.</p>
</div>
<div class="section" id="id518">
<h5><a class="toc-backref" href="#id1405">Examples:</a><a class="headerlink" href="#id518" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.sadd.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-uadd-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1406">&#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-uadd-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id519">
<h5><a class="toc-backref" href="#id1407">Syntax:</a><a class="headerlink" href="#id519" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">uadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">uadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">uadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id520">
<h5><a class="toc-backref" href="#id1408">Overview:</a><a class="headerlink" href="#id520" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned addition of the two arguments, and indicate whether a carry
occurred during the unsigned summation.</p>
</div>
<div class="section" id="id521">
<h5><a class="toc-backref" href="#id1409">Arguments:</a><a class="headerlink" href="#id521" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo unsigned
addition.</p>
</div>
<div class="section" id="id522">
<h5><a class="toc-backref" href="#id1410">Semantics:</a><a class="headerlink" href="#id522" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned addition of the two arguments. They return a structure &#8212; the
first element of which is the sum, and the second element of which is a
bit specifying if the unsigned summation resulted in a carry.</p>
</div>
<div class="section" id="id523">
<h5><a class="toc-backref" href="#id1411">Examples:</a><a class="headerlink" href="#id523" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.uadd.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%carry</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-ssub-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1412">&#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-ssub-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id524">
<h5><a class="toc-backref" href="#id1413">Syntax:</a><a class="headerlink" href="#id524" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.ssub.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ssub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ssub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ssub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id525">
<h5><a class="toc-backref" href="#id1414">Overview:</a><a class="headerlink" href="#id525" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed subtraction of the two arguments, and indicate whether an
overflow occurred during the signed subtraction.</p>
</div>
<div class="section" id="id526">
<h5><a class="toc-backref" href="#id1415">Arguments:</a><a class="headerlink" href="#id526" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo signed
subtraction.</p>
</div>
<div class="section" id="id527">
<h5><a class="toc-backref" href="#id1416">Semantics:</a><a class="headerlink" href="#id527" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed subtraction of the two arguments. They return a structure &#8212; the
first element of which is the subtraction, and the second element of
which is a bit specifying if the signed subtraction resulted in an
overflow.</p>
</div>
<div class="section" id="id528">
<h5><a class="toc-backref" href="#id1417">Examples:</a><a class="headerlink" href="#id528" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.ssub.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-usub-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1418">&#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-usub-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id529">
<h5><a class="toc-backref" href="#id1419">Syntax:</a><a class="headerlink" href="#id529" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.usub.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">usub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">usub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">usub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id530">
<h5><a class="toc-backref" href="#id1420">Overview:</a><a class="headerlink" href="#id530" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned subtraction of the two arguments, and indicate whether an
overflow occurred during the unsigned subtraction.</p>
</div>
<div class="section" id="id531">
<h5><a class="toc-backref" href="#id1421">Arguments:</a><a class="headerlink" href="#id531" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo unsigned
subtraction.</p>
</div>
<div class="section" id="id532">
<h5><a class="toc-backref" href="#id1422">Semantics:</a><a class="headerlink" href="#id532" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned subtraction of the two arguments. They return a structure &#8212;
the first element of which is the subtraction, and the second element of
which is a bit specifying if the unsigned subtraction resulted in an
overflow.</p>
</div>
<div class="section" id="id533">
<h5><a class="toc-backref" href="#id1423">Examples:</a><a class="headerlink" href="#id533" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.usub.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-smul-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1424">&#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-smul-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id534">
<h5><a class="toc-backref" href="#id1425">Syntax:</a><a class="headerlink" href="#id534" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.smul.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">smul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">smul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">smul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id535">
<h5><a class="toc-backref" href="#id1426">Overview:</a><a class="headerlink" href="#id535" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed multiplication of the two arguments, and indicate whether an
overflow occurred during the signed multiplication.</p>
</div>
<div class="section" id="id536">
<h5><a class="toc-backref" href="#id1427">Arguments:</a><a class="headerlink" href="#id536" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo signed
multiplication.</p>
</div>
<div class="section" id="id537">
<h5><a class="toc-backref" href="#id1428">Semantics:</a><a class="headerlink" href="#id537" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed multiplication of the two arguments. They return a structure &#8212;
the first element of which is the multiplication, and the second element
of which is a bit specifying if the signed multiplication resulted in an
overflow.</p>
</div>
<div class="section" id="id538">
<h5><a class="toc-backref" href="#id1429">Examples:</a><a class="headerlink" href="#id538" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-umul-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1430">&#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-umul-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id539">
<h5><a class="toc-backref" href="#id1431">Syntax:</a><a class="headerlink" href="#id539" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.umul.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">umul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">umul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">umul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id540">
<h5><a class="toc-backref" href="#id1432">Overview:</a><a class="headerlink" href="#id540" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow</span></code>&#8216; family of intrinsic functions perform
a unsigned multiplication of the two arguments, and indicate whether an
overflow occurred during the unsigned multiplication.</p>
</div>
<div class="section" id="id541">
<h5><a class="toc-backref" href="#id1433">Arguments:</a><a class="headerlink" href="#id541" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo unsigned
multiplication.</p>
</div>
<div class="section" id="id542">
<h5><a class="toc-backref" href="#id1434">Semantics:</a><a class="headerlink" href="#id542" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned multiplication of the two arguments. They return a structure &#8212;
the first element of which is the multiplication, and the second
element of which is a bit specifying if the unsigned multiplication
resulted in an overflow.</p>
</div>
<div class="section" id="id543">
<h5><a class="toc-backref" href="#id1435">Examples:</a><a class="headerlink" href="#id543" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.umul.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="specialised-arithmetic-intrinsics">
<h3><a class="toc-backref" href="#id1436">Specialised Arithmetic Intrinsics</a><a class="headerlink" href="#specialised-arithmetic-intrinsics" title="永久链接至标题">¶</a></h3>
<div class="section" id="llvm-canonicalize-intrinsic">
<h4><a class="toc-backref" href="#id1437">&#8216;<code class="docutils literal"><span class="pre">llvm.canonicalize.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-canonicalize-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id544">
<h5><a class="toc-backref" href="#id1438">Syntax:</a><a class="headerlink" href="#id544" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">canonicalize</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">canonicalize</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id545">
<h5><a class="toc-backref" href="#id1439">Overview:</a><a class="headerlink" href="#id545" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.canonicalize.*</span></code>&#8216; intrinsic returns the platform specific canonical
encoding of a floating point number. This canonicalization is useful for
implementing certain numeric primitives such as frexp. The canonical encoding is
defined by IEEE-754-2008 to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">2.1</span><span class="o">.</span><span class="mi">8</span> <span class="n">canonical</span> <span class="n">encoding</span><span class="p">:</span> <span class="n">The</span> <span class="n">preferred</span> <span class="n">encoding</span> <span class="n">of</span> <span class="n">a</span> <span class="n">floating</span><span class="o">-</span><span class="n">point</span>
<span class="n">representation</span> <span class="ow">in</span> <span class="n">a</span> <span class="nb">format</span><span class="o">.</span> <span class="n">Applied</span> <span class="n">to</span> <span class="n">declets</span><span class="p">,</span> <span class="n">significands</span> <span class="n">of</span> <span class="n">finite</span>
<span class="n">numbers</span><span class="p">,</span> <span class="n">infinities</span><span class="p">,</span> <span class="ow">and</span> <span class="n">NaNs</span><span class="p">,</span> <span class="n">especially</span> <span class="ow">in</span> <span class="n">decimal</span> <span class="n">formats</span><span class="o">.</span>
</pre></div>
</div>
<p>This operation can also be considered equivalent to the IEEE-754-2008
conversion of a floating-point value to the same format. NaNs are handled
according to section 6.2.</p>
<p>Examples of non-canonical encodings:</p>
<ul class="simple">
<li>x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are
converted to a canonical representation per hardware-specific protocol.</li>
<li>Many normal decimal floating point numbers have non-canonical alternative
encodings.</li>
<li>Some machines, like GPUs or ARMv7 NEON, do not support subnormal values.
These are treated as non-canonical encodings of zero and with be flushed to
a zero of the same sign by this operation.</li>
</ul>
<p>Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with
default exception handling must signal an invalid exception, and produce a
quiet NaN result.</p>
<p>This function should always be implementable as multiplication by 1.0, provided
that the compiler does not constant fold the operation. Likewise, division by
1.0 and <code class="docutils literal"><span class="pre">llvm.minnum(x,</span> <span class="pre">x)</span></code> are possible implementations. Addition with
-0.0 is also sufficient provided that the rounding mode is not -Infinity.</p>
<p><code class="docutils literal"><span class="pre">&#64;llvm.canonicalize</span></code> must preserve the equality relation. That is:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">(&#64;llvm.canonicalize(x)</span> <span class="pre">==</span> <span class="pre">x)</span></code> is equivalent to <code class="docutils literal"><span class="pre">(x</span> <span class="pre">==</span> <span class="pre">x)</span></code></li>
<li><code class="docutils literal"><span class="pre">(&#64;llvm.canonicalize(x)</span> <span class="pre">==</span> <span class="pre">&#64;llvm.canonicalize(y))</span></code> is equivalent to
to <code class="docutils literal"><span class="pre">(x</span> <span class="pre">==</span> <span class="pre">y)</span></code></li>
</ul>
<p>Additionally, the sign of zero must be conserved:
<code class="docutils literal"><span class="pre">&#64;llvm.canonicalize(-0.0)</span> <span class="pre">=</span> <span class="pre">-0.0</span></code> and <code class="docutils literal"><span class="pre">&#64;llvm.canonicalize(+0.0)</span> <span class="pre">=</span> <span class="pre">+0.0</span></code></p>
<p>The payload bits of a NaN must be conserved, with two exceptions.
First, environments which use only a single canonical representation of NaN
must perform said canonicalization. Second, SNaNs must be quieted per the
usual methods.</p>
<p>The canonicalization operation may be optimized away if:</p>
<ul class="simple">
<li>The input is known to be canonical. For example, it was produced by a
floating-point operation that is required by the standard to be canonical.</li>
<li>The result is consumed only by (or fused with) other floating-point
operations. That is, the bits of the floating point value are not examined.</li>
</ul>
</div>
</div>
<div class="section" id="llvm-fmuladd-intrinsic">
<h4><a class="toc-backref" href="#id1440">&#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-fmuladd-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id546">
<h5><a class="toc-backref" href="#id1441">Syntax:</a><a class="headerlink" href="#id546" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fmuladd</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fmuladd</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id547">
<h5><a class="toc-backref" href="#id1442">Overview:</a><a class="headerlink" href="#id547" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; intrinsic functions represent multiply-add
expressions that can be fused if the code generator determines that (a) the
target instruction set has support for a fused operation, and (b) that the
fused operation is more efficient than the equivalent, separate pair of mul
and add instructions.</p>
</div>
<div class="section" id="id548">
<h5><a class="toc-backref" href="#id1443">Arguments:</a><a class="headerlink" href="#id548" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; intrinsics each take three arguments: two
multiplicands, a and b, and an addend c.</p>
</div>
<div class="section" id="id549">
<h5><a class="toc-backref" href="#id1444">Semantics:</a><a class="headerlink" href="#id549" title="永久链接至标题">¶</a></h5>
<p>The expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">call</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fmuladd</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to the expression a * b + c, except that rounding will
not be performed between the multiplication and addition steps if the
code generator fuses the operations. Fusion is not guaranteed, even if
the target platform supports it. If a fused multiply-add is required the
corresponding llvm.fma.* intrinsic function should be used
instead. This never sets errno, just as &#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216;.</p>
</div>
<div class="section" id="id550">
<h5><a class="toc-backref" href="#id1445">Examples:</a><a class="headerlink" href="#id550" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%r2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">float</span> <span class="vg">@llvm.fmuladd.f32</span><span class="p">(</span><span class="kt">float</span> <span class="nv">%a</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%b</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%c</span><span class="p">)</span> <span class="c">; yields float:r2 = (a * b) + c</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="half-precision-floating-point-intrinsics">
<h3><a class="toc-backref" href="#id1446">Half Precision Floating Point Intrinsics</a><a class="headerlink" href="#half-precision-floating-point-intrinsics" title="永久链接至标题">¶</a></h3>
<p>For most target platforms, half precision floating point is a
storage-only format. This means that it is a dense encoding (in memory)
but does not support computation in the format.</p>
<p>This means that code must first load the half-precision floating point
value as an i16, then convert it to float with
<a class="reference internal" href="#int-convert-from-fp16"><span class="std std-ref">llvm.convert.from.fp16</span></a>. Computation can
then be performed on the float value (including extending to double
etc). To store the value back to memory, it is first converted to float
if needed, then converted to i16 with
<a class="reference internal" href="#int-convert-to-fp16"><span class="std std-ref">llvm.convert.to.fp16</span></a>, then storing as an
i16 value.</p>
<div class="section" id="llvm-convert-to-fp16-intrinsic">
<span id="int-convert-to-fp16"></span><h4><a class="toc-backref" href="#id1447">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-convert-to-fp16-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id551">
<h5><a class="toc-backref" href="#id1448">Syntax:</a><a class="headerlink" href="#id551" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id552">
<h5><a class="toc-backref" href="#id1449">Overview:</a><a class="headerlink" href="#id552" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; intrinsic function performs a conversion from a
conventional floating point type to half precision floating point format.</p>
</div>
<div class="section" id="id553">
<h5><a class="toc-backref" href="#id1450">Arguments:</a><a class="headerlink" href="#id553" title="永久链接至标题">¶</a></h5>
<p>The intrinsic function contains single argument - the value to be
converted.</p>
</div>
<div class="section" id="id554">
<h5><a class="toc-backref" href="#id1451">Semantics:</a><a class="headerlink" href="#id554" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; intrinsic function performs a conversion from a
conventional floating point format to half precision floating point format. The
return value is an <code class="docutils literal"><span class="pre">i16</span></code> which contains the converted number.</p>
</div>
<div class="section" id="id555">
<h5><a class="toc-backref" href="#id1452">Examples:</a><a class="headerlink" href="#id555" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i16</span> <span class="vg">@llvm.convert.to.fp16.f32</span><span class="p">(</span><span class="kt">float</span> <span class="nv">%a</span><span class="p">)</span>
<span class="k">store</span> <span class="k">i16</span> <span class="nv">%res</span><span class="p">,</span> <span class="k">i16</span><span class="p">*</span> <span class="vg">@x</span><span class="p">,</span> <span class="k">align</span> <span class="m">2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-convert-from-fp16-intrinsic">
<span id="int-convert-from-fp16"></span><h4><a class="toc-backref" href="#id1453">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-convert-from-fp16-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id556">
<h5><a class="toc-backref" href="#id1454">Syntax:</a><a class="headerlink" href="#id556" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id557">
<h5><a class="toc-backref" href="#id1455">Overview:</a><a class="headerlink" href="#id557" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; intrinsic function performs a
conversion from half precision floating point format to single precision
floating point format.</p>
</div>
<div class="section" id="id558">
<h5><a class="toc-backref" href="#id1456">Arguments:</a><a class="headerlink" href="#id558" title="永久链接至标题">¶</a></h5>
<p>The intrinsic function contains single argument - the value to be
converted.</p>
</div>
<div class="section" id="id559">
<h5><a class="toc-backref" href="#id1457">Semantics:</a><a class="headerlink" href="#id559" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; intrinsic function performs a
conversion from half single precision floating point format to single
precision floating point format. The input half-float value is
represented by an <code class="docutils literal"><span class="pre">i16</span></code> value.</p>
</div>
<div class="section" id="id560">
<h5><a class="toc-backref" href="#id1458">Examples:</a><a class="headerlink" href="#id560" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%a</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i16</span><span class="p">,</span> <span class="k">i16</span><span class="p">*</span> <span class="vg">@x</span><span class="p">,</span> <span class="k">align</span> <span class="m">2</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">float</span> <span class="vg">@llvm.convert.from.fp16</span><span class="p">(</span><span class="k">i16</span> <span class="nv">%a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="debugger-intrinsics">
<span id="dbg-intrinsics"></span><h3><a class="toc-backref" href="#id1459">Debugger Intrinsics</a><a class="headerlink" href="#debugger-intrinsics" title="永久链接至标题">¶</a></h3>
<p>The LLVM debugger intrinsics (which all start with <code class="docutils literal"><span class="pre">llvm.dbg.</span></code>
prefix), are described in the <a class="reference external" href="SourceLevelDebugging.html#format_common_intrinsics">LLVM Source Level
Debugging</a>
document.</p>
</div>
<div class="section" id="exception-handling-intrinsics">
<h3><a class="toc-backref" href="#id1460">Exception Handling Intrinsics</a><a class="headerlink" href="#exception-handling-intrinsics" title="永久链接至标题">¶</a></h3>
<p>The LLVM exception handling intrinsics (which all start with
<code class="docutils literal"><span class="pre">llvm.eh.</span></code> prefix), are described in the <a class="reference external" href="ExceptionHandling.html#format_common_intrinsics">LLVM Exception
Handling</a> document.</p>
</div>
<div class="section" id="trampoline-intrinsics">
<span id="int-trampoline"></span><h3><a class="toc-backref" href="#id1461">Trampoline Intrinsics</a><a class="headerlink" href="#trampoline-intrinsics" title="永久链接至标题">¶</a></h3>
<p>These intrinsics make it possible to excise one parameter, marked with
the <a class="reference internal" href="#nest"><span class="std std-ref">nest</span></a> attribute, from a function. The result is a
callable function pointer lacking the nest parameter - the caller does
not need to provide a value for it. Instead, the value to use is stored
in advance in a &#8220;trampoline&#8221;, a block of memory usually allocated on the
stack, which also contains code to splice the nest value into the
argument list. This is used to implement the GCC nested function address
extension.</p>
<p>For example, if the function is <code class="docutils literal"><span class="pre">i32</span> <span class="pre">f(i8*</span> <span class="pre">nest</span> <span class="pre">%c,</span> <span class="pre">i32</span> <span class="pre">%x,</span> <span class="pre">i32</span> <span class="pre">%y)</span></code>
then the resulting function pointer has signature <code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i32,</span> <span class="pre">i32)*</span></code>.
It can be created as follows:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%tramp</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="k">align</span> <span class="m">4</span> <span class="c">; size and alignment only correct for X86</span>
<span class="nv">%tramp1</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="nv">%tramp</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span>
<span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.init.trampoline</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%tramp1</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">(</span><span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">)*</span> <span class="vg">@f</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*),</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%nval</span><span class="p">)</span>
<span class="nv">%p</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.adjust.trampoline</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%tramp1</span><span class="p">)</span>
<span class="nv">%fp</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%p</span> <span class="k">to</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">)*</span>
</pre></div>
</div>
<p>The call <code class="docutils literal"><span class="pre">%val</span> <span class="pre">=</span> <span class="pre">call</span> <span class="pre">i32</span> <span class="pre">%fp(i32</span> <span class="pre">%x,</span> <span class="pre">i32</span> <span class="pre">%y)</span></code> is then equivalent to
<code class="docutils literal"><span class="pre">%val</span> <span class="pre">=</span> <span class="pre">call</span> <span class="pre">i32</span> <span class="pre">%f(i8*</span> <span class="pre">%nval,</span> <span class="pre">i32</span> <span class="pre">%x,</span> <span class="pre">i32</span> <span class="pre">%y)</span></code>.</p>
<div class="section" id="llvm-init-trampoline-intrinsic">
<span id="int-it"></span><h4><a class="toc-backref" href="#id1462">&#8216;<code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-init-trampoline-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id561">
<h5><a class="toc-backref" href="#id1463">Syntax:</a><a class="headerlink" href="#id561" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">trampoline</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">tramp</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">func</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">nval</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id562">
<h5><a class="toc-backref" href="#id1464">Overview:</a><a class="headerlink" href="#id562" title="永久链接至标题">¶</a></h5>
<p>This fills the memory pointed to by <code class="docutils literal"><span class="pre">tramp</span></code> with executable code,
turning it into a trampoline.</p>
</div>
<div class="section" id="id563">
<h5><a class="toc-backref" href="#id1465">Arguments:</a><a class="headerlink" href="#id563" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code> intrinsic takes three arguments, all
pointers. The <code class="docutils literal"><span class="pre">tramp</span></code> argument must point to a sufficiently large and
sufficiently aligned block of memory; this memory is written to by the
intrinsic. Note that the size and the alignment are target-specific -
LLVM currently provides no portable way of determining them, so a
front-end that generates this intrinsic needs to have some
target-specific knowledge. The <code class="docutils literal"><span class="pre">func</span></code> argument must hold a function
bitcast to an <code class="docutils literal"><span class="pre">i8*</span></code>.</p>
</div>
<div class="section" id="id564">
<h5><a class="toc-backref" href="#id1466">Semantics:</a><a class="headerlink" href="#id564" title="永久链接至标题">¶</a></h5>
<p>The block of memory pointed to by <code class="docutils literal"><span class="pre">tramp</span></code> is filled with target
dependent code, turning it into a function. Then <code class="docutils literal"><span class="pre">tramp</span></code> needs to be
passed to <a class="reference internal" href="#int-at"><span class="std std-ref">llvm.adjust.trampoline</span></a> to get a pointer which can
be <a class="reference internal" href="#int-trampoline"><span class="std std-ref">bitcast (to a new function) and called</span></a>. The new
function&#8217;s signature is the same as that of <code class="docutils literal"><span class="pre">func</span></code> with any arguments
marked with the <code class="docutils literal"><span class="pre">nest</span></code> attribute removed. At most one such <code class="docutils literal"><span class="pre">nest</span></code>
argument is allowed, and it must be of pointer type. Calling the new
function is equivalent to calling <code class="docutils literal"><span class="pre">func</span></code> with the same argument list,
but with <code class="docutils literal"><span class="pre">nval</span></code> used for the missing <code class="docutils literal"><span class="pre">nest</span></code> argument. If, after
calling <code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code>, the memory pointed to by <code class="docutils literal"><span class="pre">tramp</span></code> is
modified, then the effect of any later call to the returned function
pointer is undefined.</p>
</div>
</div>
<div class="section" id="llvm-adjust-trampoline-intrinsic">
<span id="int-at"></span><h4><a class="toc-backref" href="#id1467">&#8216;<code class="docutils literal"><span class="pre">llvm.adjust.trampoline</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-adjust-trampoline-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id565">
<h5><a class="toc-backref" href="#id1468">Syntax:</a><a class="headerlink" href="#id565" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">adjust</span><span class="o">.</span><span class="n">trampoline</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">tramp</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id566">
<h5><a class="toc-backref" href="#id1469">Overview:</a><a class="headerlink" href="#id566" title="永久链接至标题">¶</a></h5>
<p>This performs any required machine-specific adjustment to the address of
a trampoline (passed as <code class="docutils literal"><span class="pre">tramp</span></code>).</p>
</div>
<div class="section" id="id567">
<h5><a class="toc-backref" href="#id1470">Arguments:</a><a class="headerlink" href="#id567" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">tramp</span></code> must point to a block of memory which already has trampoline
code filled in by a previous call to
<a class="reference internal" href="#int-it"><span class="std std-ref">llvm.init.trampoline</span></a>.</p>
</div>
<div class="section" id="id568">
<h5><a class="toc-backref" href="#id1471">Semantics:</a><a class="headerlink" href="#id568" title="永久链接至标题">¶</a></h5>
<p>On some architectures the address of the code to be executed needs to be
different than the address where the trampoline is actually stored. This
intrinsic returns the executable address corresponding to <code class="docutils literal"><span class="pre">tramp</span></code>
after performing the required machine specific adjustments. The pointer
returned can then be <a class="reference internal" href="#int-trampoline"><span class="std std-ref">bitcast and executed</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="masked-vector-load-and-store-intrinsics">
<span id="int-mload-mstore"></span><h3><a class="toc-backref" href="#id1472">Masked Vector Load and Store Intrinsics</a><a class="headerlink" href="#masked-vector-load-and-store-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for predicated vector load and store operations. The predicate is specified by a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the &#8220;off&#8221; lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed.</p>
<div class="section" id="llvm-masked-load-intrinsics">
<span id="int-mload"></span><h4><a class="toc-backref" href="#id1473">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.load.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-load-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id569">
<h5><a class="toc-backref" href="#id1474">Syntax:</a><a class="headerlink" href="#id569" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The loaded data is a vector of any integer, floating point or pointer data type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v16f32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v2f64</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">double</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v8p0f64</span>    <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">function</span> <span class="n">pointers</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v8p0f_i32f</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id570">
<h5><a class="toc-backref" href="#id1475">Overview:</a><a class="headerlink" href="#id570" title="永久链接至标题">¶</a></h5>
<p>Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand.</p>
</div>
<div class="section" id="id571">
<h5><a class="toc-backref" href="#id1476">Arguments:</a><a class="headerlink" href="#id571" title="永久链接至标题">¶</a></h5>
<p>The first operand is the base pointer for the load. The second operand is the alignment of the source location. It must be a constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the base pointer and the type of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand are the same vector types.</p>
</div>
<div class="section" id="id572">
<h5><a class="toc-backref" href="#id1477">Semantics:</a><a class="headerlink" href="#id572" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.load</span></code>&#8216; intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar load operations.
The result of this operation is equivalent to a regular vector load instruction followed by a &#8216;select&#8217; between the loaded and the passthru values, predicated on the same mask. However, using this intrinsic prevents exceptions on memory access to masked-off lanes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">call</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v16f32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">passthru</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">The</span> <span class="n">result</span> <span class="n">of</span> <span class="n">the</span> <span class="n">two</span> <span class="n">following</span> <span class="n">instructions</span> <span class="ow">is</span> <span class="n">identical</span> <span class="n">aside</span> <span class="kn">from</span> <span class="nn">potential</span> <span class="n">memory</span> <span class="n">access</span> <span class="n">exception</span>
<span class="o">%</span><span class="n">loadlal</span> <span class="o">=</span> <span class="n">load</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">select</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">loadlal</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">passthru</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-masked-store-intrinsics">
<span id="int-mstore"></span><h4><a class="toc-backref" href="#id1478">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.store.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-store-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id573">
<h5><a class="toc-backref" href="#id1479">Syntax:</a><a class="headerlink" href="#id573" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating point or pointer data type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v8i32</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span>  <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span>   <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span>  <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;*</span>   <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">8</span>  <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v16f32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">double</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v8p0f64</span>    <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">function</span> <span class="n">pointers</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v4p0f_i32f</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id574">
<h5><a class="toc-backref" href="#id1480">Overview:</a><a class="headerlink" href="#id574" title="永久链接至标题">¶</a></h5>
<p>Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes.</p>
</div>
<div class="section" id="id575">
<h5><a class="toc-backref" href="#id1481">Arguments:</a><a class="headerlink" href="#id575" title="永久链接至标题">¶</a></h5>
<p>The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements.</p>
</div>
<div class="section" id="id576">
<h5><a class="toc-backref" href="#id1482">Semantics:</a><a class="headerlink" href="#id576" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.store</span></code>&#8216; intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.
The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">call</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v16f32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">mask</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">The</span> <span class="n">result</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">instructions</span> <span class="ow">is</span> <span class="n">identical</span> <span class="n">aside</span> <span class="kn">from</span> <span class="nn">potential</span> <span class="n">data</span> <span class="n">races</span> <span class="ow">and</span> <span class="n">memory</span> <span class="n">access</span> <span class="n">exceptions</span>
<span class="o">%</span><span class="n">oldval</span> <span class="o">=</span> <span class="n">load</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">select</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">oldval</span>
<span class="n">store</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">res</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="masked-vector-gather-and-scatter-intrinsics">
<h3><a class="toc-backref" href="#id1483">Masked Vector Gather and Scatter Intrinsics</a><a class="headerlink" href="#masked-vector-gather-and-scatter-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for vector gather and scatter operations. They are similar to <a class="reference internal" href="#int-mload-mstore"><span class="std std-ref">Masked Vector Load and Store</span></a>, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the &#8220;off&#8221; lanes are not accessed. When all bits are off, no memory is accessed.</p>
<div class="section" id="llvm-masked-gather-intrinsics">
<span id="int-mgather"></span><h4><a class="toc-backref" href="#id1484">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.gather.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-gather-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id577">
<h5><a class="toc-backref" href="#id1485">Syntax:</a><a class="headerlink" href="#id577" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating point or pointer data type gathered together into one vector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v16f32</span>   <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v2f64</span>    <span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v8p0f32</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="nb">float</span><span class="o">**&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id578">
<h5><a class="toc-backref" href="#id1486">Overview:</a><a class="headerlink" href="#id578" title="永久链接至标题">¶</a></h5>
<p>Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers &#8216;<code class="docutils literal"><span class="pre">ptrs</span></code>&#8216;. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand.</p>
</div>
<div class="section" id="id579">
<h5><a class="toc-backref" href="#id1487">Arguments:</a><a class="headerlink" href="#id579" title="永久链接至标题">¶</a></h5>
<p>The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be a constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand are the same vector types.</p>
</div>
<div class="section" id="id580">
<h5><a class="toc-backref" href="#id1488">Semantics:</a><a class="headerlink" href="#id580" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.gather</span></code>&#8216; intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.
The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">call</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v4f64</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="o">&gt;</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">The</span> <span class="n">gather</span> <span class="k">with</span> <span class="nb">all</span><span class="o">-</span><span class="n">true</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">following</span> <span class="n">instruction</span> <span class="n">sequence</span>
<span class="o">%</span><span class="n">ptr0</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">%</span><span class="n">ptr2</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">2</span>
<span class="o">%</span><span class="n">ptr3</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">3</span>

<span class="o">%</span><span class="n">val0</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr0</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="o">%</span><span class="n">val1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr1</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="o">%</span><span class="n">val2</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr2</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="o">%</span><span class="n">val3</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr3</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>

<span class="o">%</span><span class="n">vec0</span>    <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span><span class="n">undef</span><span class="p">,</span> <span class="o">%</span><span class="n">val0</span><span class="p">,</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">vec01</span>   <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;%</span><span class="n">vec0</span><span class="p">,</span> <span class="o">%</span><span class="n">val1</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">%</span><span class="n">vec012</span>  <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;%</span><span class="n">vec01</span><span class="p">,</span> <span class="o">%</span><span class="n">val2</span><span class="p">,</span> <span class="mi">2</span>
<span class="o">%</span><span class="n">vec0123</span> <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;%</span><span class="n">vec012</span><span class="p">,</span> <span class="o">%</span><span class="n">val3</span><span class="p">,</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-masked-scatter-intrinsics">
<span id="int-mscatter"></span><h4><a class="toc-backref" href="#id1489">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.scatter.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-scatter-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id581">
<h5><a class="toc-backref" href="#id1490">Syntax:</a><a class="headerlink" href="#id581" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v8i32</span>   <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span>     <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span>     <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v16f32</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span>  <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v4p0f64</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">**&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id582">
<h5><a class="toc-backref" href="#id1491">Overview:</a><a class="headerlink" href="#id582" title="永久链接至标题">¶</a></h5>
<p>Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes.</p>
</div>
<div class="section" id="id583">
<h5><a class="toc-backref" href="#id1492">Arguments:</a><a class="headerlink" href="#id583" title="永久链接至标题">¶</a></h5>
<p>The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements.</p>
</div>
<div class="section" id="id584">
<h5><a class="toc-backref" href="#id1493">Semantics:</a><a class="headerlink" href="#id584" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.scatter</span></code>&#8216; intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;;</span> <span class="n">This</span> <span class="n">instruction</span> <span class="n">unconditionaly</span> <span class="n">stores</span> <span class="n">data</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">multiple</span> <span class="n">addresses</span>
<span class="n">call</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v8i32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="o">..</span> <span class="n">true</span><span class="o">&gt;</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">scalar</span> <span class="n">stores</span>
<span class="o">%</span><span class="n">val0</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">val1</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">..</span>
<span class="o">%</span><span class="n">val7</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">7</span>
<span class="o">%</span><span class="n">ptr0</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">..</span>
<span class="o">%</span><span class="n">ptr7</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">7</span>
<span class="p">;;</span> <span class="n">Note</span><span class="p">:</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">stores</span> <span class="ow">is</span> <span class="n">important</span> <span class="n">when</span> <span class="n">they</span> <span class="n">overlap</span><span class="p">:</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">val0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr0</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">val1</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr1</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="o">..</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">val7</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr7</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="memory-use-markers">
<h3><a class="toc-backref" href="#id1494">Memory Use Markers</a><a class="headerlink" href="#memory-use-markers" title="永久链接至标题">¶</a></h3>
<p>This class of intrinsics provides information about the lifetime of
memory objects and ranges where variables are immutable.</p>
<div class="section" id="llvm-lifetime-start-intrinsic">
<span id="int-lifestart"></span><h4><a class="toc-backref" href="#id1495">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.start</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-lifetime-start-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id585">
<h5><a class="toc-backref" href="#id1496">Syntax:</a><a class="headerlink" href="#id585" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">lifetime</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id586">
<h5><a class="toc-backref" href="#id1497">Overview:</a><a class="headerlink" href="#id586" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.start</span></code>&#8216; intrinsic specifies the start of a memory
object&#8217;s lifetime.</p>
</div>
<div class="section" id="id587">
<h5><a class="toc-backref" href="#id1498">Arguments:</a><a class="headerlink" href="#id587" title="永久链接至标题">¶</a></h5>
<p>The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized. The second argument is a pointer
to the object.</p>
</div>
<div class="section" id="id588">
<h5><a class="toc-backref" href="#id1499">Semantics:</a><a class="headerlink" href="#id588" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that before this point in the code, the value
of the memory pointed to by <code class="docutils literal"><span class="pre">ptr</span></code> is dead. This means that it is known
to never be used and has an undefined value. A load from the pointer
that precedes this intrinsic can be replaced with <code class="docutils literal"><span class="pre">'undef'</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-lifetime-end-intrinsic">
<span id="int-lifeend"></span><h4><a class="toc-backref" href="#id1500">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.end</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-lifetime-end-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id589">
<h5><a class="toc-backref" href="#id1501">Syntax:</a><a class="headerlink" href="#id589" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">lifetime</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id590">
<h5><a class="toc-backref" href="#id1502">Overview:</a><a class="headerlink" href="#id590" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.end</span></code>&#8216; intrinsic specifies the end of a memory
object&#8217;s lifetime.</p>
</div>
<div class="section" id="id591">
<h5><a class="toc-backref" href="#id1503">Arguments:</a><a class="headerlink" href="#id591" title="永久链接至标题">¶</a></h5>
<p>The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized. The second argument is a pointer
to the object.</p>
</div>
<div class="section" id="id592">
<h5><a class="toc-backref" href="#id1504">Semantics:</a><a class="headerlink" href="#id592" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that after this point in the code, the value of
the memory pointed to by <code class="docutils literal"><span class="pre">ptr</span></code> is dead. This means that it is known to
never be used and has an undefined value. Any stores into the memory
object following this intrinsic may be removed as dead.</p>
</div>
</div>
<div class="section" id="llvm-invariant-start-intrinsic">
<h4><a class="toc-backref" href="#id1505">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.start</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-invariant-start-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id593">
<h5><a class="toc-backref" href="#id1506">Syntax:</a><a class="headerlink" href="#id593" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{}</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">invariant</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id594">
<h5><a class="toc-backref" href="#id1507">Overview:</a><a class="headerlink" href="#id594" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.invariant.start</span></code>&#8216; intrinsic specifies that the contents of
a memory object will not change.</p>
</div>
<div class="section" id="id595">
<h5><a class="toc-backref" href="#id1508">Arguments:</a><a class="headerlink" href="#id595" title="永久链接至标题">¶</a></h5>
<p>The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized. The second argument is a pointer
to the object.</p>
</div>
<div class="section" id="id596">
<h5><a class="toc-backref" href="#id1509">Semantics:</a><a class="headerlink" href="#id596" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that until an <code class="docutils literal"><span class="pre">llvm.invariant.end</span></code> that uses
the return value, the referenced memory location is constant and
unchanging.</p>
</div>
</div>
<div class="section" id="llvm-invariant-end-intrinsic">
<h4><a class="toc-backref" href="#id1510">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.end</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-invariant-end-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id597">
<h5><a class="toc-backref" href="#id1511">Syntax:</a><a class="headerlink" href="#id597" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">invariant</span><span class="o">.</span><span class="n">end</span><span class="p">({}</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">start</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id598">
<h5><a class="toc-backref" href="#id1512">Overview:</a><a class="headerlink" href="#id598" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.invariant.end</span></code>&#8216; intrinsic specifies that the contents of a
memory object are mutable.</p>
</div>
<div class="section" id="id599">
<h5><a class="toc-backref" href="#id1513">Arguments:</a><a class="headerlink" href="#id599" title="永久链接至标题">¶</a></h5>
<p>The first argument is the matching <code class="docutils literal"><span class="pre">llvm.invariant.start</span></code> intrinsic.
The second argument is a constant integer representing the size of the
object, or -1 if it is variable sized and the third argument is a
pointer to the object.</p>
</div>
<div class="section" id="id600">
<h5><a class="toc-backref" href="#id1514">Semantics:</a><a class="headerlink" href="#id600" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that the memory is mutable again.</p>
</div>
</div>
<div class="section" id="llvm-invariant-group-barrier-intrinsic">
<h4><a class="toc-backref" href="#id1515">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-invariant-group-barrier-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id601">
<h5><a class="toc-backref" href="#id1516">Syntax:</a><a class="headerlink" href="#id601" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">invariant</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">barrier</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id602">
<h5><a class="toc-backref" href="#id1517">Overview:</a><a class="headerlink" href="#id602" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code>&#8216; intrinsic can be used when an invariant
established by invariant.group metadata no longer holds, to obtain a new pointer
value that does not carry the invariant information.</p>
</div>
<div class="section" id="id603">
<h5><a class="toc-backref" href="#id1518">Arguments:</a><a class="headerlink" href="#id603" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code> takes only one argument, which is
the pointer to the memory for which the <code class="docutils literal"><span class="pre">invariant.group</span></code> no longer holds.</p>
</div>
<div class="section" id="id604">
<h5><a class="toc-backref" href="#id1519">Semantics:</a><a class="headerlink" href="#id604" title="永久链接至标题">¶</a></h5>
<p>Returns another pointer that aliases its argument but which is considered different
for the purposes of <code class="docutils literal"><span class="pre">load</span></code>/<code class="docutils literal"><span class="pre">store</span></code> <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata.</p>
</div>
</div>
</div>
<div class="section" id="general-intrinsics">
<h3><a class="toc-backref" href="#id1520">General Intrinsics</a><a class="headerlink" href="#general-intrinsics" title="永久链接至标题">¶</a></h3>
<p>This class of intrinsics is designed to be generic and has no specific
purpose.</p>
<div class="section" id="llvm-var-annotation-intrinsic">
<h4><a class="toc-backref" href="#id1521">&#8216;<code class="docutils literal"><span class="pre">llvm.var.annotation</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-var-annotation-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id605">
<h5><a class="toc-backref" href="#id1522">Syntax:</a><a class="headerlink" href="#id605" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">annotation</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id606">
<h5><a class="toc-backref" href="#id1523">Overview:</a><a class="headerlink" href="#id606" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.var.annotation</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id607">
<h5><a class="toc-backref" href="#id1524">Arguments:</a><a class="headerlink" href="#id607" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a value, the second is a pointer to a
global string, the third is a pointer to a global string which is the
source file name, and the last argument is the line number.</p>
</div>
<div class="section" id="id608">
<h5><a class="toc-backref" href="#id1525">Semantics:</a><a class="headerlink" href="#id608" title="永久链接至标题">¶</a></h5>
<p>This intrinsic allows annotation of local variables with arbitrary
strings. This can be useful for special purpose optimizations that want
to look for these annotations. These have no other defined use; they are
ignored by code generation and optimization.</p>
</div>
</div>
<div class="section" id="llvm-ptr-annotation-intrinsic">
<h4><a class="toc-backref" href="#id1526">&#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ptr-annotation-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id609">
<h5><a class="toc-backref" href="#id1527">Syntax:</a><a class="headerlink" href="#id609" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use &#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation</span></code>&#8216; on a
pointer to an integer of any width. <em>NOTE</em> you must specify an address space for
the pointer. The identifier for the default address space is the integer
&#8216;<code class="docutils literal"><span class="pre">0</span></code>&#8216;.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span>   <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i8</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span><span class="o">*</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span><span class="o">*</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span><span class="o">*</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id610">
<h5><a class="toc-backref" href="#id1528">Overview:</a><a class="headerlink" href="#id610" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id611">
<h5><a class="toc-backref" href="#id1529">Arguments:</a><a class="headerlink" href="#id611" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to an integer value of arbitrary bitwidth
(result of some expression), the second is a pointer to a global string, the
third is a pointer to a global string which is the source file name, and the
last argument is the line number. It returns the value of the first argument.</p>
</div>
<div class="section" id="id612">
<h5><a class="toc-backref" href="#id1530">Semantics:</a><a class="headerlink" href="#id612" title="永久链接至标题">¶</a></h5>
<p>This intrinsic allows annotation of a pointer to an integer with arbitrary
strings. This can be useful for special purpose optimizations that want to look
for these annotations. These have no other defined use; they are ignored by code
generation and optimization.</p>
</div>
</div>
<div class="section" id="llvm-annotation-intrinsic">
<h4><a class="toc-backref" href="#id1531">&#8216;<code class="docutils literal"><span class="pre">llvm.annotation.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-annotation-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id613">
<h5><a class="toc-backref" href="#id1532">Syntax:</a><a class="headerlink" href="#id613" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use &#8216;<code class="docutils literal"><span class="pre">llvm.annotation</span></code>&#8216; on
any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i8</span><span class="p">(</span><span class="n">i8</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id614">
<h5><a class="toc-backref" href="#id1533">Overview:</a><a class="headerlink" href="#id614" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.annotation</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id615">
<h5><a class="toc-backref" href="#id1534">Arguments:</a><a class="headerlink" href="#id615" title="永久链接至标题">¶</a></h5>
<p>The first argument is an integer value (result of some expression), the
second is a pointer to a global string, the third is a pointer to a
global string which is the source file name, and the last argument is
the line number. It returns the value of the first argument.</p>
</div>
<div class="section" id="id616">
<h5><a class="toc-backref" href="#id1535">Semantics:</a><a class="headerlink" href="#id616" title="永久链接至标题">¶</a></h5>
<p>This intrinsic allows annotations to be put on arbitrary expressions
with arbitrary strings. This can be useful for special purpose
optimizations that want to look for these annotations. These have no
other defined use; they are ignored by code generation and optimization.</p>
</div>
</div>
<div class="section" id="llvm-trap-intrinsic">
<h4><a class="toc-backref" href="#id1536">&#8216;<code class="docutils literal"><span class="pre">llvm.trap</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-trap-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id617">
<h5><a class="toc-backref" href="#id1537">Syntax:</a><a class="headerlink" href="#id617" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">trap</span><span class="p">()</span> <span class="n">noreturn</span> <span class="n">nounwind</span>
</pre></div>
</div>
</div>
<div class="section" id="id618">
<h5><a class="toc-backref" href="#id1538">Overview:</a><a class="headerlink" href="#id618" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.trap</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id619">
<h5><a class="toc-backref" href="#id1539">Arguments:</a><a class="headerlink" href="#id619" title="永久链接至标题">¶</a></h5>
<p>None.</p>
</div>
<div class="section" id="id620">
<h5><a class="toc-backref" href="#id1540">Semantics:</a><a class="headerlink" href="#id620" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is lowered to the target dependent trap instruction. If
the target does not have a trap instruction, this intrinsic will be
lowered to a call of the <code class="docutils literal"><span class="pre">abort()</span></code> function.</p>
</div>
</div>
<div class="section" id="llvm-debugtrap-intrinsic">
<h4><a class="toc-backref" href="#id1541">&#8216;<code class="docutils literal"><span class="pre">llvm.debugtrap</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-debugtrap-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id621">
<h5><a class="toc-backref" href="#id1542">Syntax:</a><a class="headerlink" href="#id621" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">debugtrap</span><span class="p">()</span> <span class="n">nounwind</span>
</pre></div>
</div>
</div>
<div class="section" id="id622">
<h5><a class="toc-backref" href="#id1543">Overview:</a><a class="headerlink" href="#id622" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.debugtrap</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id623">
<h5><a class="toc-backref" href="#id1544">Arguments:</a><a class="headerlink" href="#id623" title="永久链接至标题">¶</a></h5>
<p>None.</p>
</div>
<div class="section" id="id624">
<h5><a class="toc-backref" href="#id1545">Semantics:</a><a class="headerlink" href="#id624" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is lowered to code which is intended to cause an
execution trap with the intention of requesting the attention of a
debugger.</p>
</div>
</div>
<div class="section" id="llvm-stackprotector-intrinsic">
<h4><a class="toc-backref" href="#id1546">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotector</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stackprotector-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id625">
<h5><a class="toc-backref" href="#id1547">Syntax:</a><a class="headerlink" href="#id625" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackprotector</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">guard</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">**</span> <span class="o">&lt;</span><span class="n">slot</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id626">
<h5><a class="toc-backref" href="#id1548">Overview:</a><a class="headerlink" href="#id626" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotector</span></code> intrinsic takes the <code class="docutils literal"><span class="pre">guard</span></code> and stores it
onto the stack at <code class="docutils literal"><span class="pre">slot</span></code>. The stack slot is adjusted to ensure that it
is placed on the stack before local variables.</p>
</div>
<div class="section" id="id627">
<h5><a class="toc-backref" href="#id1549">Arguments:</a><a class="headerlink" href="#id627" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotector</span></code> intrinsic requires two pointer arguments.
The first argument is the value loaded from the stack guard
<code class="docutils literal"><span class="pre">&#64;__stack_chk_guard</span></code>. The second variable is an <code class="docutils literal"><span class="pre">alloca</span></code> that has
enough space to hold the value of the guard.</p>
</div>
<div class="section" id="id628">
<h5><a class="toc-backref" href="#id1550">Semantics:</a><a class="headerlink" href="#id628" title="永久链接至标题">¶</a></h5>
<p>This intrinsic causes the prologue/epilogue inserter to force the position of
the <code class="docutils literal"><span class="pre">AllocaInst</span></code> stack slot to be before local variables on the stack. This is
to ensure that if a local variable on the stack is overwritten, it will destroy
the value of the guard. When the function exits, the guard on the stack is
checked against the original guard by <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code>. If they are
different, then <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code> causes the program to abort by
calling the <code class="docutils literal"><span class="pre">__stack_chk_fail()</span></code> function.</p>
</div>
</div>
<div class="section" id="llvm-stackprotectorcheck-intrinsic">
<h4><a class="toc-backref" href="#id1551">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stackprotectorcheck-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id629">
<h5><a class="toc-backref" href="#id1552">Syntax:</a><a class="headerlink" href="#id629" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackprotectorcheck</span><span class="p">(</span><span class="n">i8</span><span class="o">**</span> <span class="o">&lt;</span><span class="n">guard</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id630">
<h5><a class="toc-backref" href="#id1553">Overview:</a><a class="headerlink" href="#id630" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code> intrinsic compares <code class="docutils literal"><span class="pre">guard</span></code> against an already
created stack protector and if they are not equal calls the
<code class="docutils literal"><span class="pre">__stack_chk_fail()</span></code> function.</p>
</div>
<div class="section" id="id631">
<h5><a class="toc-backref" href="#id1554">Arguments:</a><a class="headerlink" href="#id631" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code> intrinsic requires one pointer argument, the
the variable <code class="docutils literal"><span class="pre">&#64;__stack_chk_guard</span></code>.</p>
</div>
<div class="section" id="id632">
<h5><a class="toc-backref" href="#id1555">Semantics:</a><a class="headerlink" href="#id632" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is provided to perform the stack protector check by comparing
<code class="docutils literal"><span class="pre">guard</span></code> with the stack slot created by <code class="docutils literal"><span class="pre">llvm.stackprotector</span></code> and if the
values do not match call the <code class="docutils literal"><span class="pre">__stack_chk_fail()</span></code> function.</p>
<p>The reason to provide this as an IR level intrinsic instead of implementing it
via other IR operations is that in order to perform this operation at the IR
level without an intrinsic, one would need to create additional basic blocks to
handle the success/failure cases. This makes it difficult to stop the stack
protector check from disrupting sibling tail calls in Codegen. With this
intrinsic, we are able to generate the stack protector basic blocks late in
codegen after the tail call decision has occurred.</p>
</div>
</div>
<div class="section" id="llvm-objectsize-intrinsic">
<h4><a class="toc-backref" href="#id1556">&#8216;<code class="docutils literal"><span class="pre">llvm.objectsize</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-objectsize-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id633">
<h5><a class="toc-backref" href="#id1557">Syntax:</a><a class="headerlink" href="#id633" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">objectsize</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="nb">min</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">objectsize</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="nb">min</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id634">
<h5><a class="toc-backref" href="#id1558">Overview:</a><a class="headerlink" href="#id634" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> intrinsic is designed to provide information to
the optimizers to determine at compile time whether a) an operation
(like memcpy) will overflow a buffer that corresponds to an object, or
b) that a runtime check for overflow isn&#8217;t necessary. An object in this
context means an allocation of a specific class, structure, array, or
other object.</p>
</div>
<div class="section" id="id635">
<h5><a class="toc-backref" href="#id1559">Arguments:</a><a class="headerlink" href="#id635" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> intrinsic takes two arguments. The first
argument is a pointer to or into the <code class="docutils literal"><span class="pre">object</span></code>. The second argument is
a boolean and determines whether <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> returns 0 (if true)
or -1 (if false) when the object size is unknown. The second argument
only accepts constants.</p>
</div>
<div class="section" id="id636">
<h5><a class="toc-backref" href="#id1560">Semantics:</a><a class="headerlink" href="#id636" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> intrinsic is lowered to a constant representing
the size of the object concerned. If the size cannot be determined at
compile time, <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> returns <code class="docutils literal"><span class="pre">i32/i64</span> <span class="pre">-1</span> <span class="pre">or</span> <span class="pre">0</span></code> (depending
on the <code class="docutils literal"><span class="pre">min</span></code> argument).</p>
</div>
</div>
<div class="section" id="llvm-expect-intrinsic">
<h4><a class="toc-backref" href="#id1561">&#8216;<code class="docutils literal"><span class="pre">llvm.expect</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-expect-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id637">
<h5><a class="toc-backref" href="#id1562">Syntax:</a><a class="headerlink" href="#id637" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.expect</span></code> on any
integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">i1</span><span class="p">(</span><span class="n">i1</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">expected_val</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">expected_val</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="n">expected_val</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id638">
<h5><a class="toc-backref" href="#id1563">Overview:</a><a class="headerlink" href="#id638" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.expect</span></code> intrinsic provides information about expected (the
most probable) value of <code class="docutils literal"><span class="pre">val</span></code>, which can be used by optimizers.</p>
</div>
<div class="section" id="id639">
<h5><a class="toc-backref" href="#id1564">Arguments:</a><a class="headerlink" href="#id639" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.expect</span></code> intrinsic takes two arguments. The first argument is
a value. The second argument is an expected value, this needs to be a
constant value, variables are not allowed.</p>
</div>
<div class="section" id="id640">
<h5><a class="toc-backref" href="#id1565">Semantics:</a><a class="headerlink" href="#id640" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is lowered to the <code class="docutils literal"><span class="pre">val</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-assume-intrinsic">
<span id="int-assume"></span><h4><a class="toc-backref" href="#id1566">&#8216;<code class="docutils literal"><span class="pre">llvm.assume</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-assume-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id641">
<h5><a class="toc-backref" href="#id1567">Syntax:</a><a class="headerlink" href="#id641" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">assume</span><span class="p">(</span><span class="n">i1</span> <span class="o">%</span><span class="n">cond</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id642">
<h5><a class="toc-backref" href="#id1568">Overview:</a><a class="headerlink" href="#id642" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.assume</span></code> allows the optimizer to assume that the provided
condition is true. This information can then be used in simplifying other parts
of the code.</p>
</div>
<div class="section" id="id643">
<h5><a class="toc-backref" href="#id1569">Arguments:</a><a class="headerlink" href="#id643" title="永久链接至标题">¶</a></h5>
<p>The condition which the optimizer may assume is always true.</p>
</div>
<div class="section" id="id644">
<h5><a class="toc-backref" href="#id1570">Semantics:</a><a class="headerlink" href="#id644" title="永久链接至标题">¶</a></h5>
<p>The intrinsic allows the optimizer to assume that the provided condition is
always true whenever the control flow reaches the intrinsic call. No code is
generated for this intrinsic, and instructions that contribute only to the
provided condition are not used for code generation. If the condition is
violated during execution, the behavior is undefined.</p>
<p>Note that the optimizer might limit the transformations performed on values
used by the <code class="docutils literal"><span class="pre">llvm.assume</span></code> intrinsic in order to preserve the instructions
only used to form the intrinsic&#8217;s input argument. This might prove undesirable
if the extra information provided by the <code class="docutils literal"><span class="pre">llvm.assume</span></code> intrinsic does not cause
sufficient overall improvement in code quality. For this reason,
<code class="docutils literal"><span class="pre">llvm.assume</span></code> should not be used to document basic mathematical invariants
that the optimizer can otherwise deduce or facts that are of little use to the
optimizer.</p>
</div>
</div>
<div class="section" id="llvm-bitset-test-intrinsic">
<span id="bitset-test"></span><h4><a class="toc-backref" href="#id1571">&#8216;<code class="docutils literal"><span class="pre">llvm.bitset.test</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-bitset-test-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id645">
<h5><a class="toc-backref" href="#id1572">Syntax:</a><a class="headerlink" href="#id645" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitset</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">%</span><span class="n">bitset</span><span class="p">)</span> <span class="n">nounwind</span> <span class="n">readnone</span>
</pre></div>
</div>
</div>
<div class="section" id="id646">
<h5><a class="toc-backref" href="#id1573">Arguments:</a><a class="headerlink" href="#id646" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to be tested. The second argument is a
metadata object representing an identifier for a <a class="reference internal" href="BitSets.html"><span class="doc">bitset</span></a>.</p>
</div>
<div class="section" id="id647">
<h5><a class="toc-backref" href="#id1574">Overview:</a><a class="headerlink" href="#id647" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.bitset.test</span></code> intrinsic tests whether the given pointer is a
member of the given bitset.</p>
</div>
</div>
<div class="section" id="llvm-donothing-intrinsic">
<h4><a class="toc-backref" href="#id1575">&#8216;<code class="docutils literal"><span class="pre">llvm.donothing</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-donothing-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id648">
<h5><a class="toc-backref" href="#id1576">Syntax:</a><a class="headerlink" href="#id648" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">donothing</span><span class="p">()</span> <span class="n">nounwind</span> <span class="n">readnone</span>
</pre></div>
</div>
</div>
<div class="section" id="id649">
<h5><a class="toc-backref" href="#id1577">Overview:</a><a class="headerlink" href="#id649" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.donothing</span></code> intrinsic doesn&#8217;t perform any operation. It&#8217;s one of only
two intrinsics (besides <code class="docutils literal"><span class="pre">llvm.experimental.patchpoint</span></code>) that can be called
with an invoke instruction.</p>
</div>
<div class="section" id="id650">
<h5><a class="toc-backref" href="#id1578">Arguments:</a><a class="headerlink" href="#id650" title="永久链接至标题">¶</a></h5>
<p>None.</p>
</div>
<div class="section" id="id651">
<h5><a class="toc-backref" href="#id1579">Semantics:</a><a class="headerlink" href="#id651" title="永久链接至标题">¶</a></h5>
<p>This intrinsic does nothing, and it&#8217;s removed by optimizers and ignored
by codegen.</p>
</div>
</div>
</div>
<div class="section" id="stack-map-intrinsics">
<h3><a class="toc-backref" href="#id1580">Stack Map Intrinsics</a><a class="headerlink" href="#stack-map-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides experimental intrinsics to support runtime patching
mechanisms commonly desired in dynamic language JITs. These intrinsics
are described in <a class="reference internal" href="StackMaps.html"><span class="doc">Stack maps and patch points in LLVM</span></a>.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="CMake.html" title="Building LLVM with CMake"
             >下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="概述"
             >上一页</a> |</li>
  <li><a href="http://llvm.org/">LLVM 官网</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">LLVM 中文文档</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; 版权所有 2003-2016, LLVM Project.
      最后更新于 2016-04-18.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1 创建。
    </div>
    <div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="CMake.html" title="Building LLVM with CMake"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="概述"
             accesskey="P">上一页</a> |</li>
  <li><a href="http://llvm.org/">LLVM 官网</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">LLVM 中文文档</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="llvm-language-reference-manual">
<h1>LLVM 语法参考手册<a class="headerlink" href="#llvm-language-reference-manual" title="永久链接至标题">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id652">摘要</a></li>
<li><a class="reference internal" href="#introduction" id="id653">简介</a><ul>
<li><a class="reference internal" href="#well-formedness" id="id654">结构良好性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#identifiers" id="id655">标识符</a></li>
<li><a class="reference internal" href="#high-level-structure" id="id656">High Level Structure</a><ul>
<li><a class="reference internal" href="#module-structure" id="id657">Module Structure</a></li>
<li><a class="reference internal" href="#linkage-types" id="id658">Linkage Types</a></li>
<li><a class="reference internal" href="#calling-conventions" id="id659">Calling Conventions</a></li>
<li><a class="reference internal" href="#visibility-styles" id="id660">Visibility Styles</a></li>
<li><a class="reference internal" href="#dll-storage-classes" id="id661">DLL Storage Classes</a></li>
<li><a class="reference internal" href="#thread-local-storage-models" id="id662">Thread Local Storage Models</a></li>
<li><a class="reference internal" href="#structure-types" id="id663">Structure Types</a></li>
<li><a class="reference internal" href="#global-variables" id="id664">Global Variables</a></li>
<li><a class="reference internal" href="#functions" id="id665">Functions</a></li>
<li><a class="reference internal" href="#aliases" id="id666">Aliases</a></li>
<li><a class="reference internal" href="#comdats" id="id667">Comdats</a></li>
<li><a class="reference internal" href="#named-metadata" id="id668">Named Metadata</a></li>
<li><a class="reference internal" href="#parameter-attributes" id="id669">Parameter Attributes</a></li>
<li><a class="reference internal" href="#garbage-collector-strategy-names" id="id670">Garbage Collector Strategy Names</a></li>
<li><a class="reference internal" href="#prefix-data" id="id671">Prefix Data</a></li>
<li><a class="reference internal" href="#prologue-data" id="id672">Prologue Data</a></li>
<li><a class="reference internal" href="#personality-function" id="id673">Personality Function</a></li>
<li><a class="reference internal" href="#attribute-groups" id="id674">Attribute Groups</a></li>
<li><a class="reference internal" href="#function-attributes" id="id675">Function Attributes</a></li>
<li><a class="reference internal" href="#operand-bundles" id="id676">Operand Bundles</a><ul>
<li><a class="reference internal" href="#deoptimization-operand-bundles" id="id677">Deoptimization Operand Bundles</a></li>
<li><a class="reference internal" href="#funclet-operand-bundles" id="id678">Funclet Operand Bundles</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-level-inline-assembly" id="id679">Module-Level Inline Assembly</a></li>
<li><a class="reference internal" href="#data-layout" id="id680">Data Layout</a></li>
<li><a class="reference internal" href="#target-triple" id="id681">Target Triple</a></li>
<li><a class="reference internal" href="#pointer-aliasing-rules" id="id682">Pointer Aliasing Rules</a></li>
<li><a class="reference internal" href="#volatile-memory-accesses" id="id683">Volatile Memory Accesses</a></li>
<li><a class="reference internal" href="#memory-model-for-concurrent-operations" id="id684">Memory Model for Concurrent Operations</a></li>
<li><a class="reference internal" href="#atomic-memory-ordering-constraints" id="id685">Atomic Memory Ordering Constraints</a></li>
<li><a class="reference internal" href="#fast-math-flags" id="id686">Fast-Math Flags</a></li>
<li><a class="reference internal" href="#use-list-order-directives" id="id687">Use-list Order Directives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-system" id="id688">Type System</a><ul>
<li><a class="reference internal" href="#void-type" id="id689">Void Type</a></li>
<li><a class="reference internal" href="#function-type" id="id690">Function Type</a></li>
<li><a class="reference internal" href="#first-class-types" id="id691">First Class Types</a><ul>
<li><a class="reference internal" href="#single-value-types" id="id692">Single Value Types</a><ul>
<li><a class="reference internal" href="#integer-type" id="id693">Integer Type</a></li>
<li><a class="reference internal" href="#floating-point-types" id="id694">Floating Point Types</a></li>
<li><a class="reference internal" href="#x86-mmx-type" id="id695">X86_mmx Type</a></li>
<li><a class="reference internal" href="#pointer-type" id="id696">Pointer Type</a></li>
<li><a class="reference internal" href="#vector-type" id="id697">Vector Type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#label-type" id="id698">Label Type</a></li>
<li><a class="reference internal" href="#token-type" id="id699">Token Type</a></li>
<li><a class="reference internal" href="#metadata-type" id="id700">Metadata Type</a></li>
<li><a class="reference internal" href="#aggregate-types" id="id701">Aggregate Types</a><ul>
<li><a class="reference internal" href="#array-type" id="id702">Array Type</a></li>
<li><a class="reference internal" href="#structure-type" id="id703">Structure Type</a></li>
<li><a class="reference internal" href="#opaque-structure-types" id="id704">Opaque Structure Types</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#constants" id="id705">Constants</a><ul>
<li><a class="reference internal" href="#simple-constants" id="id706">Simple Constants</a></li>
<li><a class="reference internal" href="#complex-constants" id="id707">Complex Constants</a></li>
<li><a class="reference internal" href="#global-variable-and-function-addresses" id="id708">Global Variable and Function Addresses</a></li>
<li><a class="reference internal" href="#undefined-values" id="id709">Undefined Values</a></li>
<li><a class="reference internal" href="#poison-values" id="id710">Poison Values</a></li>
<li><a class="reference internal" href="#addresses-of-basic-blocks" id="id711">Addresses of Basic Blocks</a></li>
<li><a class="reference internal" href="#constant-expressions" id="id712">Constant Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-values" id="id713">Other Values</a><ul>
<li><a class="reference internal" href="#inline-assembler-expressions" id="id714">Inline Assembler Expressions</a><ul>
<li><a class="reference internal" href="#inline-asm-constraint-string" id="id715">Inline Asm Constraint String</a><ul>
<li><a class="reference internal" href="#output-constraints" id="id716">Output constraints</a></li>
<li><a class="reference internal" href="#input-constraints" id="id717">Input constraints</a></li>
<li><a class="reference internal" href="#indirect-inputs-and-outputs" id="id718">Indirect inputs and outputs</a></li>
<li><a class="reference internal" href="#clobber-constraints" id="id719">Clobber constraints</a></li>
<li><a class="reference internal" href="#constraint-codes" id="id720">Constraint Codes</a></li>
<li><a class="reference internal" href="#supported-constraint-code-list" id="id721">Supported Constraint Code List</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asm-template-argument-modifiers" id="id722">Asm template argument modifiers</a></li>
<li><a class="reference internal" href="#inline-asm-metadata" id="id723">Inline Asm Metadata</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#metadata" id="id724">Metadata</a><ul>
<li><a class="reference internal" href="#metadata-nodes-and-metadata-strings" id="id725">Metadata Nodes and Metadata Strings</a><ul>
<li><a class="reference internal" href="#specialized-metadata-nodes" id="id726">Specialized Metadata Nodes</a><ul>
<li><a class="reference internal" href="#dicompileunit" id="id727">DICompileUnit</a></li>
<li><a class="reference internal" href="#difile" id="id728">DIFile</a></li>
<li><a class="reference internal" href="#dibasictype" id="id729">DIBasicType</a></li>
<li><a class="reference internal" href="#disubroutinetype" id="id730">DISubroutineType</a></li>
<li><a class="reference internal" href="#diderivedtype" id="id731">DIDerivedType</a></li>
<li><a class="reference internal" href="#dicompositetype" id="id732">DICompositeType</a></li>
<li><a class="reference internal" href="#disubrange" id="id733">DISubrange</a></li>
<li><a class="reference internal" href="#dienumerator" id="id734">DIEnumerator</a></li>
<li><a class="reference internal" href="#ditemplatetypeparameter" id="id735">DITemplateTypeParameter</a></li>
<li><a class="reference internal" href="#ditemplatevalueparameter" id="id736">DITemplateValueParameter</a></li>
<li><a class="reference internal" href="#dinamespace" id="id737">DINamespace</a></li>
<li><a class="reference internal" href="#diglobalvariable" id="id738">DIGlobalVariable</a></li>
<li><a class="reference internal" href="#disubprogram" id="id739">DISubprogram</a></li>
<li><a class="reference internal" href="#dilexicalblock" id="id740">DILexicalBlock</a></li>
<li><a class="reference internal" href="#dilexicalblockfile" id="id741">DILexicalBlockFile</a></li>
<li><a class="reference internal" href="#dilocation" id="id742">DILocation</a></li>
<li><a class="reference internal" href="#dilocalvariable" id="id743">DILocalVariable</a></li>
<li><a class="reference internal" href="#diexpression" id="id744">DIExpression</a></li>
<li><a class="reference internal" href="#diobjcproperty" id="id745">DIObjCProperty</a></li>
<li><a class="reference internal" href="#diimportedentity" id="id746">DIImportedEntity</a></li>
<li><a class="reference internal" href="#dimacro" id="id747">DIMacro</a></li>
<li><a class="reference internal" href="#dimacrofile" id="id748">DIMacroFile</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tbaa-metadata" id="id749">&#8216;<code class="docutils literal"><span class="pre">tbaa</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#tbaa-struct-metadata" id="id750">&#8216;<code class="docutils literal"><span class="pre">tbaa.struct</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#noalias-and-alias-scope-metadata" id="id751">&#8216;<code class="docutils literal"><span class="pre">noalias</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">alias.scope</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#fpmath-metadata" id="id752">&#8216;<code class="docutils literal"><span class="pre">fpmath</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#range-metadata" id="id753">&#8216;<code class="docutils literal"><span class="pre">range</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#unpredictable-metadata" id="id754">&#8216;<code class="docutils literal"><span class="pre">unpredictable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop" id="id755">&#8216;<code class="docutils literal"><span class="pre">llvm.loop</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-loop-vectorize-and-llvm-loop-interleave" id="id756">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-loop-interleave-count-metadata" id="id757">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-vectorize-enable-metadata" id="id758">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.enable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-vectorize-width-metadata" id="id759">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll" id="id760">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-count-metadata" id="id761">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-disable-metadata" id="id762">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.disable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-runtime-disable-metadata" id="id763">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.runtime.disable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-enable-metadata" id="id764">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.enable</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-loop-unroll-full-metadata" id="id765">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.full</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-mem" id="id766">&#8216;<code class="docutils literal"><span class="pre">llvm.mem</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#llvm-mem-parallel-loop-access-metadata" id="id767">&#8216;<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code>&#8216; Metadata</a></li>
<li><a class="reference internal" href="#llvm-bitsets" id="id768">&#8216;<code class="docutils literal"><span class="pre">llvm.bitsets</span></code>&#8216;</a></li>
<li><a class="reference internal" href="#invariant-group-metadata" id="id769">&#8216;<code class="docutils literal"><span class="pre">invariant.group</span></code>&#8216; Metadata</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-flags-metadata" id="id770">Module Flags Metadata</a><ul>
<li><a class="reference internal" href="#objective-c-garbage-collection-module-flags-metadata" id="id771">Objective-C Garbage Collection Module Flags Metadata</a></li>
<li><a class="reference internal" href="#automatic-linker-flags-module-flags-metadata" id="id772">Automatic Linker Flags Module Flags Metadata</a></li>
<li><a class="reference internal" href="#c-type-width-module-flags-metadata" id="id773">C type width Module Flags Metadata</a></li>
</ul>
</li>
<li><a class="reference internal" href="#intrinsic-global-variables" id="id774">Intrinsic Global Variables</a><ul>
<li><a class="reference internal" href="#the-llvm-used-global-variable" id="id775">The &#8216;<code class="docutils literal"><span class="pre">llvm.used</span></code>&#8216; Global Variable</a></li>
<li><a class="reference internal" href="#the-llvm-compiler-used-global-variable" id="id776">The &#8216;<code class="docutils literal"><span class="pre">llvm.compiler.used</span></code>&#8216; Global Variable</a></li>
<li><a class="reference internal" href="#the-llvm-global-ctors-global-variable" id="id777">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_ctors</span></code>&#8216; Global Variable</a></li>
<li><a class="reference internal" href="#the-llvm-global-dtors-global-variable" id="id778">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_dtors</span></code>&#8216; Global Variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instruction-reference" id="id779">Instruction Reference</a><ul>
<li><a class="reference internal" href="#terminator-instructions" id="id780">Terminator Instructions</a><ul>
<li><a class="reference internal" href="#ret-instruction" id="id781">&#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#syntax" id="id782">Syntax:</a></li>
<li><a class="reference internal" href="#overview" id="id783">Overview:</a></li>
<li><a class="reference internal" href="#arguments" id="id784">Arguments:</a></li>
<li><a class="reference internal" href="#semantics" id="id785">Semantics:</a></li>
<li><a class="reference internal" href="#example" id="id786">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#br-instruction" id="id787">&#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id19" id="id788">Syntax:</a></li>
<li><a class="reference internal" href="#id20" id="id789">Overview:</a></li>
<li><a class="reference internal" href="#id21" id="id790">Arguments:</a></li>
<li><a class="reference internal" href="#id22" id="id791">Semantics:</a></li>
<li><a class="reference internal" href="#id23" id="id792">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#switch-instruction" id="id793">&#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id24" id="id794">Syntax:</a></li>
<li><a class="reference internal" href="#id25" id="id795">Overview:</a></li>
<li><a class="reference internal" href="#id26" id="id796">Arguments:</a></li>
<li><a class="reference internal" href="#id27" id="id797">Semantics:</a></li>
<li><a class="reference internal" href="#implementation" id="id798">Implementation:</a></li>
<li><a class="reference internal" href="#id28" id="id799">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indirectbr-instruction" id="id800">&#8216;<code class="docutils literal"><span class="pre">indirectbr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id29" id="id801">Syntax:</a></li>
<li><a class="reference internal" href="#id30" id="id802">Overview:</a></li>
<li><a class="reference internal" href="#id31" id="id803">Arguments:</a></li>
<li><a class="reference internal" href="#id32" id="id804">Semantics:</a></li>
<li><a class="reference internal" href="#id33" id="id805">Implementation:</a></li>
<li><a class="reference internal" href="#id34" id="id806">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoke-instruction" id="id807">&#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id35" id="id808">Syntax:</a></li>
<li><a class="reference internal" href="#id36" id="id809">Overview:</a></li>
<li><a class="reference internal" href="#id37" id="id810">Arguments:</a></li>
<li><a class="reference internal" href="#id38" id="id811">Semantics:</a></li>
<li><a class="reference internal" href="#id39" id="id812">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resume-instruction" id="id813">&#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id40" id="id814">Syntax:</a></li>
<li><a class="reference internal" href="#id41" id="id815">Overview:</a></li>
<li><a class="reference internal" href="#id42" id="id816">Arguments:</a></li>
<li><a class="reference internal" href="#id43" id="id817">Semantics:</a></li>
<li><a class="reference internal" href="#id44" id="id818">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#catchswitch-instruction" id="id819">&#8216;<code class="docutils literal"><span class="pre">catchswitch</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id45" id="id820">Syntax:</a></li>
<li><a class="reference internal" href="#id46" id="id821">Overview:</a></li>
<li><a class="reference internal" href="#id47" id="id822">Arguments:</a></li>
<li><a class="reference internal" href="#id48" id="id823">Semantics:</a></li>
<li><a class="reference internal" href="#id49" id="id824">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#catchret-instruction" id="id825">&#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id50" id="id826">Syntax:</a></li>
<li><a class="reference internal" href="#id51" id="id827">Overview:</a></li>
<li><a class="reference internal" href="#id52" id="id828">Arguments:</a></li>
<li><a class="reference internal" href="#id53" id="id829">Semantics:</a></li>
<li><a class="reference internal" href="#id54" id="id830">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cleanupret-instruction" id="id831">&#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id55" id="id832">Syntax:</a></li>
<li><a class="reference internal" href="#id56" id="id833">Overview:</a></li>
<li><a class="reference internal" href="#id57" id="id834">Arguments:</a></li>
<li><a class="reference internal" href="#id60" id="id835">Semantics:</a></li>
<li><a class="reference internal" href="#id61" id="id836">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unreachable-instruction" id="id837">&#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id62" id="id838">Syntax:</a></li>
<li><a class="reference internal" href="#id63" id="id839">Overview:</a></li>
<li><a class="reference internal" href="#id64" id="id840">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#binary-operations" id="id841">Binary Operations</a><ul>
<li><a class="reference internal" href="#add-instruction" id="id842">&#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id65" id="id843">Syntax:</a></li>
<li><a class="reference internal" href="#id66" id="id844">Overview:</a></li>
<li><a class="reference internal" href="#id67" id="id845">Arguments:</a></li>
<li><a class="reference internal" href="#id68" id="id846">Semantics:</a></li>
<li><a class="reference internal" href="#id69" id="id847">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fadd-instruction" id="id848">&#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id70" id="id849">Syntax:</a></li>
<li><a class="reference internal" href="#id71" id="id850">Overview:</a></li>
<li><a class="reference internal" href="#id72" id="id851">Arguments:</a></li>
<li><a class="reference internal" href="#id73" id="id852">Semantics:</a></li>
<li><a class="reference internal" href="#id74" id="id853">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sub-instruction" id="id854">&#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id75" id="id855">Syntax:</a></li>
<li><a class="reference internal" href="#id76" id="id856">Overview:</a></li>
<li><a class="reference internal" href="#id77" id="id857">Arguments:</a></li>
<li><a class="reference internal" href="#id78" id="id858">Semantics:</a></li>
<li><a class="reference internal" href="#id79" id="id859">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fsub-instruction" id="id860">&#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id80" id="id861">Syntax:</a></li>
<li><a class="reference internal" href="#id81" id="id862">Overview:</a></li>
<li><a class="reference internal" href="#id82" id="id863">Arguments:</a></li>
<li><a class="reference internal" href="#id83" id="id864">Semantics:</a></li>
<li><a class="reference internal" href="#id84" id="id865">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mul-instruction" id="id866">&#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id85" id="id867">Syntax:</a></li>
<li><a class="reference internal" href="#id86" id="id868">Overview:</a></li>
<li><a class="reference internal" href="#id87" id="id869">Arguments:</a></li>
<li><a class="reference internal" href="#id88" id="id870">Semantics:</a></li>
<li><a class="reference internal" href="#id89" id="id871">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fmul-instruction" id="id872">&#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id90" id="id873">Syntax:</a></li>
<li><a class="reference internal" href="#id91" id="id874">Overview:</a></li>
<li><a class="reference internal" href="#id92" id="id875">Arguments:</a></li>
<li><a class="reference internal" href="#id93" id="id876">Semantics:</a></li>
<li><a class="reference internal" href="#id94" id="id877">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#udiv-instruction" id="id878">&#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id95" id="id879">Syntax:</a></li>
<li><a class="reference internal" href="#id96" id="id880">Overview:</a></li>
<li><a class="reference internal" href="#id97" id="id881">Arguments:</a></li>
<li><a class="reference internal" href="#id98" id="id882">Semantics:</a></li>
<li><a class="reference internal" href="#id99" id="id883">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sdiv-instruction" id="id884">&#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id100" id="id885">Syntax:</a></li>
<li><a class="reference internal" href="#id101" id="id886">Overview:</a></li>
<li><a class="reference internal" href="#id102" id="id887">Arguments:</a></li>
<li><a class="reference internal" href="#id103" id="id888">Semantics:</a></li>
<li><a class="reference internal" href="#id104" id="id889">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fdiv-instruction" id="id890">&#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id105" id="id891">Syntax:</a></li>
<li><a class="reference internal" href="#id106" id="id892">Overview:</a></li>
<li><a class="reference internal" href="#id107" id="id893">Arguments:</a></li>
<li><a class="reference internal" href="#id108" id="id894">Semantics:</a></li>
<li><a class="reference internal" href="#id109" id="id895">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#urem-instruction" id="id896">&#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id110" id="id897">Syntax:</a></li>
<li><a class="reference internal" href="#id111" id="id898">Overview:</a></li>
<li><a class="reference internal" href="#id112" id="id899">Arguments:</a></li>
<li><a class="reference internal" href="#id113" id="id900">Semantics:</a></li>
<li><a class="reference internal" href="#id114" id="id901">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#srem-instruction" id="id902">&#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id115" id="id903">Syntax:</a></li>
<li><a class="reference internal" href="#id116" id="id904">Overview:</a></li>
<li><a class="reference internal" href="#id117" id="id905">Arguments:</a></li>
<li><a class="reference internal" href="#id118" id="id906">Semantics:</a></li>
<li><a class="reference internal" href="#id119" id="id907">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frem-instruction" id="id908">&#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id120" id="id909">Syntax:</a></li>
<li><a class="reference internal" href="#id121" id="id910">Overview:</a></li>
<li><a class="reference internal" href="#id122" id="id911">Arguments:</a></li>
<li><a class="reference internal" href="#id123" id="id912">Semantics:</a></li>
<li><a class="reference internal" href="#id124" id="id913">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-binary-operations" id="id914">Bitwise Binary Operations</a><ul>
<li><a class="reference internal" href="#shl-instruction" id="id915">&#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id125" id="id916">Syntax:</a></li>
<li><a class="reference internal" href="#id126" id="id917">Overview:</a></li>
<li><a class="reference internal" href="#id127" id="id918">Arguments:</a></li>
<li><a class="reference internal" href="#id128" id="id919">Semantics:</a></li>
<li><a class="reference internal" href="#id129" id="id920">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lshr-instruction" id="id921">&#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id130" id="id922">Syntax:</a></li>
<li><a class="reference internal" href="#id131" id="id923">Overview:</a></li>
<li><a class="reference internal" href="#id132" id="id924">Arguments:</a></li>
<li><a class="reference internal" href="#id133" id="id925">Semantics:</a></li>
<li><a class="reference internal" href="#id134" id="id926">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ashr-instruction" id="id927">&#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id135" id="id928">Syntax:</a></li>
<li><a class="reference internal" href="#id136" id="id929">Overview:</a></li>
<li><a class="reference internal" href="#id137" id="id930">Arguments:</a></li>
<li><a class="reference internal" href="#id138" id="id931">Semantics:</a></li>
<li><a class="reference internal" href="#id139" id="id932">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#and-instruction" id="id933">&#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id140" id="id934">Syntax:</a></li>
<li><a class="reference internal" href="#id141" id="id935">Overview:</a></li>
<li><a class="reference internal" href="#id142" id="id936">Arguments:</a></li>
<li><a class="reference internal" href="#id143" id="id937">Semantics:</a></li>
<li><a class="reference internal" href="#id144" id="id938">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-instruction" id="id939">&#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id145" id="id940">Syntax:</a></li>
<li><a class="reference internal" href="#id146" id="id941">Overview:</a></li>
<li><a class="reference internal" href="#id147" id="id942">Arguments:</a></li>
<li><a class="reference internal" href="#id148" id="id943">Semantics:</a></li>
<li><a class="reference internal" href="#id149" id="id944">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xor-instruction" id="id945">&#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id150" id="id946">Syntax:</a></li>
<li><a class="reference internal" href="#id151" id="id947">Overview:</a></li>
<li><a class="reference internal" href="#id152" id="id948">Arguments:</a></li>
<li><a class="reference internal" href="#id153" id="id949">Semantics:</a></li>
<li><a class="reference internal" href="#id154" id="id950">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#vector-operations" id="id951">Vector Operations</a><ul>
<li><a class="reference internal" href="#extractelement-instruction" id="id952">&#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id155" id="id953">Syntax:</a></li>
<li><a class="reference internal" href="#id156" id="id954">Overview:</a></li>
<li><a class="reference internal" href="#id157" id="id955">Arguments:</a></li>
<li><a class="reference internal" href="#id158" id="id956">Semantics:</a></li>
<li><a class="reference internal" href="#id159" id="id957">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#insertelement-instruction" id="id958">&#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id160" id="id959">Syntax:</a></li>
<li><a class="reference internal" href="#id161" id="id960">Overview:</a></li>
<li><a class="reference internal" href="#id162" id="id961">Arguments:</a></li>
<li><a class="reference internal" href="#id163" id="id962">Semantics:</a></li>
<li><a class="reference internal" href="#id164" id="id963">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shufflevector-instruction" id="id964">&#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id165" id="id965">Syntax:</a></li>
<li><a class="reference internal" href="#id166" id="id966">Overview:</a></li>
<li><a class="reference internal" href="#id167" id="id967">Arguments:</a></li>
<li><a class="reference internal" href="#id168" id="id968">Semantics:</a></li>
<li><a class="reference internal" href="#id169" id="id969">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#aggregate-operations" id="id970">Aggregate Operations</a><ul>
<li><a class="reference internal" href="#extractvalue-instruction" id="id971">&#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id170" id="id972">Syntax:</a></li>
<li><a class="reference internal" href="#id171" id="id973">Overview:</a></li>
<li><a class="reference internal" href="#id172" id="id974">Arguments:</a></li>
<li><a class="reference internal" href="#id173" id="id975">Semantics:</a></li>
<li><a class="reference internal" href="#id174" id="id976">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#insertvalue-instruction" id="id977">&#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id175" id="id978">Syntax:</a></li>
<li><a class="reference internal" href="#id176" id="id979">Overview:</a></li>
<li><a class="reference internal" href="#id177" id="id980">Arguments:</a></li>
<li><a class="reference internal" href="#id178" id="id981">Semantics:</a></li>
<li><a class="reference internal" href="#id179" id="id982">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#memory-access-and-addressing-operations" id="id983">Memory Access and Addressing Operations</a><ul>
<li><a class="reference internal" href="#alloca-instruction" id="id984">&#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id180" id="id985">Syntax:</a></li>
<li><a class="reference internal" href="#id181" id="id986">Overview:</a></li>
<li><a class="reference internal" href="#id182" id="id987">Arguments:</a></li>
<li><a class="reference internal" href="#id183" id="id988">Semantics:</a></li>
<li><a class="reference internal" href="#id184" id="id989">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#load-instruction" id="id990">&#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id185" id="id991">Syntax:</a></li>
<li><a class="reference internal" href="#id186" id="id992">Overview:</a></li>
<li><a class="reference internal" href="#id187" id="id993">Arguments:</a></li>
<li><a class="reference internal" href="#id188" id="id994">Semantics:</a></li>
<li><a class="reference internal" href="#id189" id="id995">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#store-instruction" id="id996">&#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id190" id="id997">Syntax:</a></li>
<li><a class="reference internal" href="#id191" id="id998">Overview:</a></li>
<li><a class="reference internal" href="#id192" id="id999">Arguments:</a></li>
<li><a class="reference internal" href="#id193" id="id1000">Semantics:</a></li>
<li><a class="reference internal" href="#id194" id="id1001">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fence-instruction" id="id1002">&#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id195" id="id1003">Syntax:</a></li>
<li><a class="reference internal" href="#id196" id="id1004">Overview:</a></li>
<li><a class="reference internal" href="#id197" id="id1005">Arguments:</a></li>
<li><a class="reference internal" href="#id198" id="id1006">Semantics:</a></li>
<li><a class="reference internal" href="#id199" id="id1007">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cmpxchg-instruction" id="id1008">&#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id200" id="id1009">Syntax:</a></li>
<li><a class="reference internal" href="#id201" id="id1010">Overview:</a></li>
<li><a class="reference internal" href="#id202" id="id1011">Arguments:</a></li>
<li><a class="reference internal" href="#id203" id="id1012">Semantics:</a></li>
<li><a class="reference internal" href="#id204" id="id1013">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#atomicrmw-instruction" id="id1014">&#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id205" id="id1015">Syntax:</a></li>
<li><a class="reference internal" href="#id206" id="id1016">Overview:</a></li>
<li><a class="reference internal" href="#id207" id="id1017">Arguments:</a></li>
<li><a class="reference internal" href="#id208" id="id1018">Semantics:</a></li>
<li><a class="reference internal" href="#id209" id="id1019">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#getelementptr-instruction" id="id1020">&#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id210" id="id1021">Syntax:</a></li>
<li><a class="reference internal" href="#id211" id="id1022">Overview:</a></li>
<li><a class="reference internal" href="#id212" id="id1023">Arguments:</a></li>
<li><a class="reference internal" href="#id213" id="id1024">Semantics:</a></li>
<li><a class="reference internal" href="#id214" id="id1025">Example:</a></li>
<li><a class="reference internal" href="#vector-of-pointers" id="id1026">Vector of pointers:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conversion-operations" id="id1027">Conversion Operations</a><ul>
<li><a class="reference internal" href="#trunc-to-instruction" id="id1028">&#8216;<code class="docutils literal"><span class="pre">trunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id215" id="id1029">Syntax:</a></li>
<li><a class="reference internal" href="#id216" id="id1030">Overview:</a></li>
<li><a class="reference internal" href="#id217" id="id1031">Arguments:</a></li>
<li><a class="reference internal" href="#id218" id="id1032">Semantics:</a></li>
<li><a class="reference internal" href="#id219" id="id1033">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#zext-to-instruction" id="id1034">&#8216;<code class="docutils literal"><span class="pre">zext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id220" id="id1035">Syntax:</a></li>
<li><a class="reference internal" href="#id221" id="id1036">Overview:</a></li>
<li><a class="reference internal" href="#id222" id="id1037">Arguments:</a></li>
<li><a class="reference internal" href="#id223" id="id1038">Semantics:</a></li>
<li><a class="reference internal" href="#id224" id="id1039">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sext-to-instruction" id="id1040">&#8216;<code class="docutils literal"><span class="pre">sext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id225" id="id1041">Syntax:</a></li>
<li><a class="reference internal" href="#id226" id="id1042">Overview:</a></li>
<li><a class="reference internal" href="#id227" id="id1043">Arguments:</a></li>
<li><a class="reference internal" href="#id228" id="id1044">Semantics:</a></li>
<li><a class="reference internal" href="#id229" id="id1045">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fptrunc-to-instruction" id="id1046">&#8216;<code class="docutils literal"><span class="pre">fptrunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id230" id="id1047">Syntax:</a></li>
<li><a class="reference internal" href="#id231" id="id1048">Overview:</a></li>
<li><a class="reference internal" href="#id232" id="id1049">Arguments:</a></li>
<li><a class="reference internal" href="#id233" id="id1050">Semantics:</a></li>
<li><a class="reference internal" href="#id234" id="id1051">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fpext-to-instruction" id="id1052">&#8216;<code class="docutils literal"><span class="pre">fpext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id235" id="id1053">Syntax:</a></li>
<li><a class="reference internal" href="#id236" id="id1054">Overview:</a></li>
<li><a class="reference internal" href="#id237" id="id1055">Arguments:</a></li>
<li><a class="reference internal" href="#id238" id="id1056">Semantics:</a></li>
<li><a class="reference internal" href="#id239" id="id1057">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fptoui-to-instruction" id="id1058">&#8216;<code class="docutils literal"><span class="pre">fptoui</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id240" id="id1059">Syntax:</a></li>
<li><a class="reference internal" href="#id241" id="id1060">Overview:</a></li>
<li><a class="reference internal" href="#id242" id="id1061">Arguments:</a></li>
<li><a class="reference internal" href="#id243" id="id1062">Semantics:</a></li>
<li><a class="reference internal" href="#id244" id="id1063">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fptosi-to-instruction" id="id1064">&#8216;<code class="docutils literal"><span class="pre">fptosi</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id245" id="id1065">Syntax:</a></li>
<li><a class="reference internal" href="#id246" id="id1066">Overview:</a></li>
<li><a class="reference internal" href="#id247" id="id1067">Arguments:</a></li>
<li><a class="reference internal" href="#id248" id="id1068">Semantics:</a></li>
<li><a class="reference internal" href="#id249" id="id1069">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uitofp-to-instruction" id="id1070">&#8216;<code class="docutils literal"><span class="pre">uitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id250" id="id1071">Syntax:</a></li>
<li><a class="reference internal" href="#id251" id="id1072">Overview:</a></li>
<li><a class="reference internal" href="#id252" id="id1073">Arguments:</a></li>
<li><a class="reference internal" href="#id253" id="id1074">Semantics:</a></li>
<li><a class="reference internal" href="#id254" id="id1075">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sitofp-to-instruction" id="id1076">&#8216;<code class="docutils literal"><span class="pre">sitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id255" id="id1077">Syntax:</a></li>
<li><a class="reference internal" href="#id256" id="id1078">Overview:</a></li>
<li><a class="reference internal" href="#id257" id="id1079">Arguments:</a></li>
<li><a class="reference internal" href="#id258" id="id1080">Semantics:</a></li>
<li><a class="reference internal" href="#id259" id="id1081">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ptrtoint-to-instruction" id="id1082">&#8216;<code class="docutils literal"><span class="pre">ptrtoint</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id260" id="id1083">Syntax:</a></li>
<li><a class="reference internal" href="#id261" id="id1084">Overview:</a></li>
<li><a class="reference internal" href="#id262" id="id1085">Arguments:</a></li>
<li><a class="reference internal" href="#id263" id="id1086">Semantics:</a></li>
<li><a class="reference internal" href="#id264" id="id1087">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inttoptr-to-instruction" id="id1088">&#8216;<code class="docutils literal"><span class="pre">inttoptr</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id265" id="id1089">Syntax:</a></li>
<li><a class="reference internal" href="#id266" id="id1090">Overview:</a></li>
<li><a class="reference internal" href="#id267" id="id1091">Arguments:</a></li>
<li><a class="reference internal" href="#id268" id="id1092">Semantics:</a></li>
<li><a class="reference internal" href="#id269" id="id1093">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitcast-to-instruction" id="id1094">&#8216;<code class="docutils literal"><span class="pre">bitcast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id270" id="id1095">Syntax:</a></li>
<li><a class="reference internal" href="#id271" id="id1096">Overview:</a></li>
<li><a class="reference internal" href="#id272" id="id1097">Arguments:</a></li>
<li><a class="reference internal" href="#id273" id="id1098">Semantics:</a></li>
<li><a class="reference internal" href="#id274" id="id1099">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#addrspacecast-to-instruction" id="id1100">&#8216;<code class="docutils literal"><span class="pre">addrspacecast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id275" id="id1101">Syntax:</a></li>
<li><a class="reference internal" href="#id276" id="id1102">Overview:</a></li>
<li><a class="reference internal" href="#id277" id="id1103">Arguments:</a></li>
<li><a class="reference internal" href="#id278" id="id1104">Semantics:</a></li>
<li><a class="reference internal" href="#id279" id="id1105">Example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#other-operations" id="id1106">Other Operations</a><ul>
<li><a class="reference internal" href="#icmp-instruction" id="id1107">&#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id280" id="id1108">Syntax:</a></li>
<li><a class="reference internal" href="#id281" id="id1109">Overview:</a></li>
<li><a class="reference internal" href="#id282" id="id1110">Arguments:</a></li>
<li><a class="reference internal" href="#id283" id="id1111">Semantics:</a></li>
<li><a class="reference internal" href="#id284" id="id1112">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fcmp-instruction" id="id1113">&#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id285" id="id1114">Syntax:</a></li>
<li><a class="reference internal" href="#id286" id="id1115">Overview:</a></li>
<li><a class="reference internal" href="#id287" id="id1116">Arguments:</a></li>
<li><a class="reference internal" href="#id288" id="id1117">Semantics:</a></li>
<li><a class="reference internal" href="#id289" id="id1118">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phi-instruction" id="id1119">&#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id290" id="id1120">Syntax:</a></li>
<li><a class="reference internal" href="#id291" id="id1121">Overview:</a></li>
<li><a class="reference internal" href="#id292" id="id1122">Arguments:</a></li>
<li><a class="reference internal" href="#id293" id="id1123">Semantics:</a></li>
<li><a class="reference internal" href="#id294" id="id1124">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#select-instruction" id="id1125">&#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id295" id="id1126">Syntax:</a></li>
<li><a class="reference internal" href="#id296" id="id1127">Overview:</a></li>
<li><a class="reference internal" href="#id297" id="id1128">Arguments:</a></li>
<li><a class="reference internal" href="#id298" id="id1129">Semantics:</a></li>
<li><a class="reference internal" href="#id299" id="id1130">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#call-instruction" id="id1131">&#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id300" id="id1132">Syntax:</a></li>
<li><a class="reference internal" href="#id301" id="id1133">Overview:</a></li>
<li><a class="reference internal" href="#id302" id="id1134">Arguments:</a></li>
<li><a class="reference internal" href="#id303" id="id1135">Semantics:</a></li>
<li><a class="reference internal" href="#id304" id="id1136">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#va-arg-instruction" id="id1137">&#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id305" id="id1138">Syntax:</a></li>
<li><a class="reference internal" href="#id306" id="id1139">Overview:</a></li>
<li><a class="reference internal" href="#id307" id="id1140">Arguments:</a></li>
<li><a class="reference internal" href="#id308" id="id1141">Semantics:</a></li>
<li><a class="reference internal" href="#id309" id="id1142">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#landingpad-instruction" id="id1143">&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id310" id="id1144">Syntax:</a></li>
<li><a class="reference internal" href="#id311" id="id1145">Overview:</a></li>
<li><a class="reference internal" href="#id313" id="id1146">Arguments:</a></li>
<li><a class="reference internal" href="#id314" id="id1147">Semantics:</a></li>
<li><a class="reference internal" href="#id315" id="id1148">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#catchpad-instruction" id="id1149">&#8216;<code class="docutils literal"><span class="pre">catchpad</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id316" id="id1150">Syntax:</a></li>
<li><a class="reference internal" href="#id317" id="id1151">Overview:</a></li>
<li><a class="reference internal" href="#id319" id="id1152">Arguments:</a></li>
<li><a class="reference internal" href="#id320" id="id1153">Semantics:</a></li>
<li><a class="reference internal" href="#id322" id="id1154">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cleanuppad-instruction" id="id1155">&#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; Instruction</a><ul>
<li><a class="reference internal" href="#id323" id="id1156">Syntax:</a></li>
<li><a class="reference internal" href="#id324" id="id1157">Overview:</a></li>
<li><a class="reference internal" href="#id326" id="id1158">Arguments:</a></li>
<li><a class="reference internal" href="#id327" id="id1159">Semantics:</a></li>
<li><a class="reference internal" href="#id329" id="id1160">Example:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#intrinsic-functions" id="id1161">Intrinsic Functions</a><ul>
<li><a class="reference internal" href="#variable-argument-handling-intrinsics" id="id1162">Variable Argument Handling Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-va-start-intrinsic" id="id1163">&#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id330" id="id1164">Syntax:</a></li>
<li><a class="reference internal" href="#id331" id="id1165">Overview:</a></li>
<li><a class="reference internal" href="#id332" id="id1166">Arguments:</a></li>
<li><a class="reference internal" href="#id333" id="id1167">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-va-end-intrinsic" id="id1168">&#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id334" id="id1169">Syntax:</a></li>
<li><a class="reference internal" href="#id335" id="id1170">Overview:</a></li>
<li><a class="reference internal" href="#id336" id="id1171">Arguments:</a></li>
<li><a class="reference internal" href="#id337" id="id1172">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-va-copy-intrinsic" id="id1173">&#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id338" id="id1174">Syntax:</a></li>
<li><a class="reference internal" href="#id339" id="id1175">Overview:</a></li>
<li><a class="reference internal" href="#id340" id="id1176">Arguments:</a></li>
<li><a class="reference internal" href="#id341" id="id1177">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#accurate-garbage-collection-intrinsics" id="id1178">Accurate Garbage Collection Intrinsics</a><ul>
<li><a class="reference internal" href="#experimental-statepoint-intrinsics" id="id1179">Experimental Statepoint Intrinsics</a></li>
<li><a class="reference internal" href="#llvm-gcroot-intrinsic" id="id1180">&#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id343" id="id1181">Syntax:</a></li>
<li><a class="reference internal" href="#id344" id="id1182">Overview:</a></li>
<li><a class="reference internal" href="#id345" id="id1183">Arguments:</a></li>
<li><a class="reference internal" href="#id346" id="id1184">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-gcread-intrinsic" id="id1185">&#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id347" id="id1186">Syntax:</a></li>
<li><a class="reference internal" href="#id348" id="id1187">Overview:</a></li>
<li><a class="reference internal" href="#id349" id="id1188">Arguments:</a></li>
<li><a class="reference internal" href="#id350" id="id1189">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-gcwrite-intrinsic" id="id1190">&#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id351" id="id1191">Syntax:</a></li>
<li><a class="reference internal" href="#id352" id="id1192">Overview:</a></li>
<li><a class="reference internal" href="#id353" id="id1193">Arguments:</a></li>
<li><a class="reference internal" href="#id354" id="id1194">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#code-generator-intrinsics" id="id1195">Code Generator Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-returnaddress-intrinsic" id="id1196">&#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id355" id="id1197">Syntax:</a></li>
<li><a class="reference internal" href="#id356" id="id1198">Overview:</a></li>
<li><a class="reference internal" href="#id357" id="id1199">Arguments:</a></li>
<li><a class="reference internal" href="#id358" id="id1200">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-frameaddress-intrinsic" id="id1201">&#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id359" id="id1202">Syntax:</a></li>
<li><a class="reference internal" href="#id360" id="id1203">Overview:</a></li>
<li><a class="reference internal" href="#id361" id="id1204">Arguments:</a></li>
<li><a class="reference internal" href="#id362" id="id1205">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-localescape-and-llvm-localrecover-intrinsics" id="id1206">&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id363" id="id1207">Syntax:</a></li>
<li><a class="reference internal" href="#id364" id="id1208">Overview:</a></li>
<li><a class="reference internal" href="#id365" id="id1209">Arguments:</a></li>
<li><a class="reference internal" href="#id366" id="id1210">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-read-register-and-llvm-write-register-intrinsics" id="id1211">&#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id367" id="id1212">Syntax:</a></li>
<li><a class="reference internal" href="#id368" id="id1213">Overview:</a></li>
<li><a class="reference internal" href="#id369" id="id1214">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stacksave-intrinsic" id="id1215">&#8216;<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id370" id="id1216">Syntax:</a></li>
<li><a class="reference internal" href="#id371" id="id1217">Overview:</a></li>
<li><a class="reference internal" href="#id372" id="id1218">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stackrestore-intrinsic" id="id1219">&#8216;<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id373" id="id1220">Syntax:</a></li>
<li><a class="reference internal" href="#id374" id="id1221">Overview:</a></li>
<li><a class="reference internal" href="#id375" id="id1222">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-get-dynamic-area-offset-intrinsic" id="id1223">&#8216;<code class="docutils literal"><span class="pre">llvm.get.dynamic.area.offset</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id376" id="id1224">Syntax:</a></li>
<li><a class="reference internal" href="#id377" id="id1225">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-prefetch-intrinsic" id="id1226">&#8216;<code class="docutils literal"><span class="pre">llvm.prefetch</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id378" id="id1227">Syntax:</a></li>
<li><a class="reference internal" href="#id379" id="id1228">Overview:</a></li>
<li><a class="reference internal" href="#id380" id="id1229">Arguments:</a></li>
<li><a class="reference internal" href="#id381" id="id1230">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-pcmarker-intrinsic" id="id1231">&#8216;<code class="docutils literal"><span class="pre">llvm.pcmarker</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id382" id="id1232">Syntax:</a></li>
<li><a class="reference internal" href="#id383" id="id1233">Overview:</a></li>
<li><a class="reference internal" href="#id384" id="id1234">Arguments:</a></li>
<li><a class="reference internal" href="#id385" id="id1235">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-readcyclecounter-intrinsic" id="id1236">&#8216;<code class="docutils literal"><span class="pre">llvm.readcyclecounter</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id386" id="id1237">Syntax:</a></li>
<li><a class="reference internal" href="#id387" id="id1238">Overview:</a></li>
<li><a class="reference internal" href="#id388" id="id1239">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-clear-cache-intrinsic" id="id1240">&#8216;<code class="docutils literal"><span class="pre">llvm.clear_cache</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id389" id="id1241">Syntax:</a></li>
<li><a class="reference internal" href="#id390" id="id1242">Overview:</a></li>
<li><a class="reference internal" href="#id391" id="id1243">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-instrprof-increment-intrinsic" id="id1244">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_increment</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id392" id="id1245">Syntax:</a></li>
<li><a class="reference internal" href="#id393" id="id1246">Overview:</a></li>
<li><a class="reference internal" href="#id394" id="id1247">Arguments:</a></li>
<li><a class="reference internal" href="#id395" id="id1248">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-instrprof-value-profile-intrinsic" id="id1249">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id396" id="id1250">Syntax:</a></li>
<li><a class="reference internal" href="#id397" id="id1251">Overview:</a></li>
<li><a class="reference internal" href="#id398" id="id1252">Arguments:</a></li>
<li><a class="reference internal" href="#id399" id="id1253">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#standard-c-library-intrinsics" id="id1254">Standard C Library Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-memcpy-intrinsic" id="id1255">&#8216;<code class="docutils literal"><span class="pre">llvm.memcpy</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id400" id="id1256">Syntax:</a></li>
<li><a class="reference internal" href="#id401" id="id1257">Overview:</a></li>
<li><a class="reference internal" href="#id402" id="id1258">Arguments:</a></li>
<li><a class="reference internal" href="#id403" id="id1259">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-memmove-intrinsic" id="id1260">&#8216;<code class="docutils literal"><span class="pre">llvm.memmove</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id404" id="id1261">Syntax:</a></li>
<li><a class="reference internal" href="#id405" id="id1262">Overview:</a></li>
<li><a class="reference internal" href="#id406" id="id1263">Arguments:</a></li>
<li><a class="reference internal" href="#id407" id="id1264">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-memset-intrinsics" id="id1265">&#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id408" id="id1266">Syntax:</a></li>
<li><a class="reference internal" href="#id409" id="id1267">Overview:</a></li>
<li><a class="reference internal" href="#id410" id="id1268">Arguments:</a></li>
<li><a class="reference internal" href="#id411" id="id1269">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-sqrt-intrinsic" id="id1270">&#8216;<code class="docutils literal"><span class="pre">llvm.sqrt.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id412" id="id1271">Syntax:</a></li>
<li><a class="reference internal" href="#id413" id="id1272">Overview:</a></li>
<li><a class="reference internal" href="#id414" id="id1273">Arguments:</a></li>
<li><a class="reference internal" href="#id415" id="id1274">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-powi-intrinsic" id="id1275">&#8216;<code class="docutils literal"><span class="pre">llvm.powi.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id416" id="id1276">Syntax:</a></li>
<li><a class="reference internal" href="#id417" id="id1277">Overview:</a></li>
<li><a class="reference internal" href="#id418" id="id1278">Arguments:</a></li>
<li><a class="reference internal" href="#id419" id="id1279">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-sin-intrinsic" id="id1280">&#8216;<code class="docutils literal"><span class="pre">llvm.sin.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id420" id="id1281">Syntax:</a></li>
<li><a class="reference internal" href="#id421" id="id1282">Overview:</a></li>
<li><a class="reference internal" href="#id422" id="id1283">Arguments:</a></li>
<li><a class="reference internal" href="#id423" id="id1284">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-cos-intrinsic" id="id1285">&#8216;<code class="docutils literal"><span class="pre">llvm.cos.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id424" id="id1286">Syntax:</a></li>
<li><a class="reference internal" href="#id425" id="id1287">Overview:</a></li>
<li><a class="reference internal" href="#id426" id="id1288">Arguments:</a></li>
<li><a class="reference internal" href="#id427" id="id1289">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-pow-intrinsic" id="id1290">&#8216;<code class="docutils literal"><span class="pre">llvm.pow.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id428" id="id1291">Syntax:</a></li>
<li><a class="reference internal" href="#id429" id="id1292">Overview:</a></li>
<li><a class="reference internal" href="#id430" id="id1293">Arguments:</a></li>
<li><a class="reference internal" href="#id431" id="id1294">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-exp-intrinsic" id="id1295">&#8216;<code class="docutils literal"><span class="pre">llvm.exp.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id432" id="id1296">Syntax:</a></li>
<li><a class="reference internal" href="#id433" id="id1297">Overview:</a></li>
<li><a class="reference internal" href="#id434" id="id1298">Arguments:</a></li>
<li><a class="reference internal" href="#id435" id="id1299">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-exp2-intrinsic" id="id1300">&#8216;<code class="docutils literal"><span class="pre">llvm.exp2.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id436" id="id1301">Syntax:</a></li>
<li><a class="reference internal" href="#id437" id="id1302">Overview:</a></li>
<li><a class="reference internal" href="#id438" id="id1303">Arguments:</a></li>
<li><a class="reference internal" href="#id439" id="id1304">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-log-intrinsic" id="id1305">&#8216;<code class="docutils literal"><span class="pre">llvm.log.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id440" id="id1306">Syntax:</a></li>
<li><a class="reference internal" href="#id441" id="id1307">Overview:</a></li>
<li><a class="reference internal" href="#id442" id="id1308">Arguments:</a></li>
<li><a class="reference internal" href="#id443" id="id1309">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-log10-intrinsic" id="id1310">&#8216;<code class="docutils literal"><span class="pre">llvm.log10.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id444" id="id1311">Syntax:</a></li>
<li><a class="reference internal" href="#id445" id="id1312">Overview:</a></li>
<li><a class="reference internal" href="#id446" id="id1313">Arguments:</a></li>
<li><a class="reference internal" href="#id447" id="id1314">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-log2-intrinsic" id="id1315">&#8216;<code class="docutils literal"><span class="pre">llvm.log2.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id448" id="id1316">Syntax:</a></li>
<li><a class="reference internal" href="#id449" id="id1317">Overview:</a></li>
<li><a class="reference internal" href="#id450" id="id1318">Arguments:</a></li>
<li><a class="reference internal" href="#id451" id="id1319">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-fma-intrinsic" id="id1320">&#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id452" id="id1321">Syntax:</a></li>
<li><a class="reference internal" href="#id453" id="id1322">Overview:</a></li>
<li><a class="reference internal" href="#id454" id="id1323">Arguments:</a></li>
<li><a class="reference internal" href="#id455" id="id1324">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-fabs-intrinsic" id="id1325">&#8216;<code class="docutils literal"><span class="pre">llvm.fabs.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id456" id="id1326">Syntax:</a></li>
<li><a class="reference internal" href="#id457" id="id1327">Overview:</a></li>
<li><a class="reference internal" href="#id458" id="id1328">Arguments:</a></li>
<li><a class="reference internal" href="#id459" id="id1329">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-minnum-intrinsic" id="id1330">&#8216;<code class="docutils literal"><span class="pre">llvm.minnum.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id460" id="id1331">Syntax:</a></li>
<li><a class="reference internal" href="#id461" id="id1332">Overview:</a></li>
<li><a class="reference internal" href="#id462" id="id1333">Arguments:</a></li>
<li><a class="reference internal" href="#id463" id="id1334">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-maxnum-intrinsic" id="id1335">&#8216;<code class="docutils literal"><span class="pre">llvm.maxnum.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id464" id="id1336">Syntax:</a></li>
<li><a class="reference internal" href="#id465" id="id1337">Overview:</a></li>
<li><a class="reference internal" href="#id466" id="id1338">Arguments:</a></li>
<li><a class="reference internal" href="#id467" id="id1339">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-copysign-intrinsic" id="id1340">&#8216;<code class="docutils literal"><span class="pre">llvm.copysign.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id468" id="id1341">Syntax:</a></li>
<li><a class="reference internal" href="#id469" id="id1342">Overview:</a></li>
<li><a class="reference internal" href="#id470" id="id1343">Arguments:</a></li>
<li><a class="reference internal" href="#id471" id="id1344">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-floor-intrinsic" id="id1345">&#8216;<code class="docutils literal"><span class="pre">llvm.floor.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id472" id="id1346">Syntax:</a></li>
<li><a class="reference internal" href="#id473" id="id1347">Overview:</a></li>
<li><a class="reference internal" href="#id474" id="id1348">Arguments:</a></li>
<li><a class="reference internal" href="#id475" id="id1349">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ceil-intrinsic" id="id1350">&#8216;<code class="docutils literal"><span class="pre">llvm.ceil.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id476" id="id1351">Syntax:</a></li>
<li><a class="reference internal" href="#id477" id="id1352">Overview:</a></li>
<li><a class="reference internal" href="#id478" id="id1353">Arguments:</a></li>
<li><a class="reference internal" href="#id479" id="id1354">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-trunc-intrinsic" id="id1355">&#8216;<code class="docutils literal"><span class="pre">llvm.trunc.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id480" id="id1356">Syntax:</a></li>
<li><a class="reference internal" href="#id481" id="id1357">Overview:</a></li>
<li><a class="reference internal" href="#id482" id="id1358">Arguments:</a></li>
<li><a class="reference internal" href="#id483" id="id1359">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-rint-intrinsic" id="id1360">&#8216;<code class="docutils literal"><span class="pre">llvm.rint.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id484" id="id1361">Syntax:</a></li>
<li><a class="reference internal" href="#id485" id="id1362">Overview:</a></li>
<li><a class="reference internal" href="#id486" id="id1363">Arguments:</a></li>
<li><a class="reference internal" href="#id487" id="id1364">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-nearbyint-intrinsic" id="id1365">&#8216;<code class="docutils literal"><span class="pre">llvm.nearbyint.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id488" id="id1366">Syntax:</a></li>
<li><a class="reference internal" href="#id489" id="id1367">Overview:</a></li>
<li><a class="reference internal" href="#id490" id="id1368">Arguments:</a></li>
<li><a class="reference internal" href="#id491" id="id1369">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-round-intrinsic" id="id1370">&#8216;<code class="docutils literal"><span class="pre">llvm.round.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id492" id="id1371">Syntax:</a></li>
<li><a class="reference internal" href="#id493" id="id1372">Overview:</a></li>
<li><a class="reference internal" href="#id494" id="id1373">Arguments:</a></li>
<li><a class="reference internal" href="#id495" id="id1374">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bit-manipulation-intrinsics" id="id1375">Bit Manipulation Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-bitreverse-intrinsics" id="id1376">&#8216;<code class="docutils literal"><span class="pre">llvm.bitreverse.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id496" id="id1377">Syntax:</a></li>
<li><a class="reference internal" href="#id497" id="id1378">Overview:</a></li>
<li><a class="reference internal" href="#id498" id="id1379">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-bswap-intrinsics" id="id1380">&#8216;<code class="docutils literal"><span class="pre">llvm.bswap.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id499" id="id1381">Syntax:</a></li>
<li><a class="reference internal" href="#id500" id="id1382">Overview:</a></li>
<li><a class="reference internal" href="#id501" id="id1383">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ctpop-intrinsic" id="id1384">&#8216;<code class="docutils literal"><span class="pre">llvm.ctpop.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id502" id="id1385">Syntax:</a></li>
<li><a class="reference internal" href="#id503" id="id1386">Overview:</a></li>
<li><a class="reference internal" href="#id504" id="id1387">Arguments:</a></li>
<li><a class="reference internal" href="#id505" id="id1388">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ctlz-intrinsic" id="id1389">&#8216;<code class="docutils literal"><span class="pre">llvm.ctlz.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id506" id="id1390">Syntax:</a></li>
<li><a class="reference internal" href="#id507" id="id1391">Overview:</a></li>
<li><a class="reference internal" href="#id508" id="id1392">Arguments:</a></li>
<li><a class="reference internal" href="#id509" id="id1393">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-cttz-intrinsic" id="id1394">&#8216;<code class="docutils literal"><span class="pre">llvm.cttz.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id510" id="id1395">Syntax:</a></li>
<li><a class="reference internal" href="#id511" id="id1396">Overview:</a></li>
<li><a class="reference internal" href="#id512" id="id1397">Arguments:</a></li>
<li><a class="reference internal" href="#id513" id="id1398">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-with-overflow-intrinsics" id="id1399">Arithmetic with Overflow Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-sadd-with-overflow-intrinsics" id="id1400">&#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id514" id="id1401">Syntax:</a></li>
<li><a class="reference internal" href="#id515" id="id1402">Overview:</a></li>
<li><a class="reference internal" href="#id516" id="id1403">Arguments:</a></li>
<li><a class="reference internal" href="#id517" id="id1404">Semantics:</a></li>
<li><a class="reference internal" href="#id518" id="id1405">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-uadd-with-overflow-intrinsics" id="id1406">&#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id519" id="id1407">Syntax:</a></li>
<li><a class="reference internal" href="#id520" id="id1408">Overview:</a></li>
<li><a class="reference internal" href="#id521" id="id1409">Arguments:</a></li>
<li><a class="reference internal" href="#id522" id="id1410">Semantics:</a></li>
<li><a class="reference internal" href="#id523" id="id1411">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ssub-with-overflow-intrinsics" id="id1412">&#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id524" id="id1413">Syntax:</a></li>
<li><a class="reference internal" href="#id525" id="id1414">Overview:</a></li>
<li><a class="reference internal" href="#id526" id="id1415">Arguments:</a></li>
<li><a class="reference internal" href="#id527" id="id1416">Semantics:</a></li>
<li><a class="reference internal" href="#id528" id="id1417">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-usub-with-overflow-intrinsics" id="id1418">&#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id529" id="id1419">Syntax:</a></li>
<li><a class="reference internal" href="#id530" id="id1420">Overview:</a></li>
<li><a class="reference internal" href="#id531" id="id1421">Arguments:</a></li>
<li><a class="reference internal" href="#id532" id="id1422">Semantics:</a></li>
<li><a class="reference internal" href="#id533" id="id1423">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-smul-with-overflow-intrinsics" id="id1424">&#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id534" id="id1425">Syntax:</a></li>
<li><a class="reference internal" href="#id535" id="id1426">Overview:</a></li>
<li><a class="reference internal" href="#id536" id="id1427">Arguments:</a></li>
<li><a class="reference internal" href="#id537" id="id1428">Semantics:</a></li>
<li><a class="reference internal" href="#id538" id="id1429">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-umul-with-overflow-intrinsics" id="id1430">&#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id539" id="id1431">Syntax:</a></li>
<li><a class="reference internal" href="#id540" id="id1432">Overview:</a></li>
<li><a class="reference internal" href="#id541" id="id1433">Arguments:</a></li>
<li><a class="reference internal" href="#id542" id="id1434">Semantics:</a></li>
<li><a class="reference internal" href="#id543" id="id1435">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#specialised-arithmetic-intrinsics" id="id1436">Specialised Arithmetic Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-canonicalize-intrinsic" id="id1437">&#8216;<code class="docutils literal"><span class="pre">llvm.canonicalize.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id544" id="id1438">Syntax:</a></li>
<li><a class="reference internal" href="#id545" id="id1439">Overview:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-fmuladd-intrinsic" id="id1440">&#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id546" id="id1441">Syntax:</a></li>
<li><a class="reference internal" href="#id547" id="id1442">Overview:</a></li>
<li><a class="reference internal" href="#id548" id="id1443">Arguments:</a></li>
<li><a class="reference internal" href="#id549" id="id1444">Semantics:</a></li>
<li><a class="reference internal" href="#id550" id="id1445">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#half-precision-floating-point-intrinsics" id="id1446">Half Precision Floating Point Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-convert-to-fp16-intrinsic" id="id1447">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id551" id="id1448">Syntax:</a></li>
<li><a class="reference internal" href="#id552" id="id1449">Overview:</a></li>
<li><a class="reference internal" href="#id553" id="id1450">Arguments:</a></li>
<li><a class="reference internal" href="#id554" id="id1451">Semantics:</a></li>
<li><a class="reference internal" href="#id555" id="id1452">Examples:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-convert-from-fp16-intrinsic" id="id1453">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id556" id="id1454">Syntax:</a></li>
<li><a class="reference internal" href="#id557" id="id1455">Overview:</a></li>
<li><a class="reference internal" href="#id558" id="id1456">Arguments:</a></li>
<li><a class="reference internal" href="#id559" id="id1457">Semantics:</a></li>
<li><a class="reference internal" href="#id560" id="id1458">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#debugger-intrinsics" id="id1459">Debugger Intrinsics</a></li>
<li><a class="reference internal" href="#exception-handling-intrinsics" id="id1460">Exception Handling Intrinsics</a></li>
<li><a class="reference internal" href="#trampoline-intrinsics" id="id1461">Trampoline Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-init-trampoline-intrinsic" id="id1462">&#8216;<code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id561" id="id1463">Syntax:</a></li>
<li><a class="reference internal" href="#id562" id="id1464">Overview:</a></li>
<li><a class="reference internal" href="#id563" id="id1465">Arguments:</a></li>
<li><a class="reference internal" href="#id564" id="id1466">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-adjust-trampoline-intrinsic" id="id1467">&#8216;<code class="docutils literal"><span class="pre">llvm.adjust.trampoline</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id565" id="id1468">Syntax:</a></li>
<li><a class="reference internal" href="#id566" id="id1469">Overview:</a></li>
<li><a class="reference internal" href="#id567" id="id1470">Arguments:</a></li>
<li><a class="reference internal" href="#id568" id="id1471">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#masked-vector-load-and-store-intrinsics" id="id1472">Masked Vector Load and Store Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-masked-load-intrinsics" id="id1473">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.load.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id569" id="id1474">Syntax:</a></li>
<li><a class="reference internal" href="#id570" id="id1475">Overview:</a></li>
<li><a class="reference internal" href="#id571" id="id1476">Arguments:</a></li>
<li><a class="reference internal" href="#id572" id="id1477">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-masked-store-intrinsics" id="id1478">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.store.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id573" id="id1479">Syntax:</a></li>
<li><a class="reference internal" href="#id574" id="id1480">Overview:</a></li>
<li><a class="reference internal" href="#id575" id="id1481">Arguments:</a></li>
<li><a class="reference internal" href="#id576" id="id1482">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#masked-vector-gather-and-scatter-intrinsics" id="id1483">Masked Vector Gather and Scatter Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-masked-gather-intrinsics" id="id1484">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.gather.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id577" id="id1485">Syntax:</a></li>
<li><a class="reference internal" href="#id578" id="id1486">Overview:</a></li>
<li><a class="reference internal" href="#id579" id="id1487">Arguments:</a></li>
<li><a class="reference internal" href="#id580" id="id1488">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-masked-scatter-intrinsics" id="id1489">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.scatter.*</span></code>&#8216; Intrinsics</a><ul>
<li><a class="reference internal" href="#id581" id="id1490">Syntax:</a></li>
<li><a class="reference internal" href="#id582" id="id1491">Overview:</a></li>
<li><a class="reference internal" href="#id583" id="id1492">Arguments:</a></li>
<li><a class="reference internal" href="#id584" id="id1493">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#memory-use-markers" id="id1494">Memory Use Markers</a><ul>
<li><a class="reference internal" href="#llvm-lifetime-start-intrinsic" id="id1495">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.start</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id585" id="id1496">Syntax:</a></li>
<li><a class="reference internal" href="#id586" id="id1497">Overview:</a></li>
<li><a class="reference internal" href="#id587" id="id1498">Arguments:</a></li>
<li><a class="reference internal" href="#id588" id="id1499">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-lifetime-end-intrinsic" id="id1500">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.end</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id589" id="id1501">Syntax:</a></li>
<li><a class="reference internal" href="#id590" id="id1502">Overview:</a></li>
<li><a class="reference internal" href="#id591" id="id1503">Arguments:</a></li>
<li><a class="reference internal" href="#id592" id="id1504">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-invariant-start-intrinsic" id="id1505">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.start</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id593" id="id1506">Syntax:</a></li>
<li><a class="reference internal" href="#id594" id="id1507">Overview:</a></li>
<li><a class="reference internal" href="#id595" id="id1508">Arguments:</a></li>
<li><a class="reference internal" href="#id596" id="id1509">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-invariant-end-intrinsic" id="id1510">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.end</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id597" id="id1511">Syntax:</a></li>
<li><a class="reference internal" href="#id598" id="id1512">Overview:</a></li>
<li><a class="reference internal" href="#id599" id="id1513">Arguments:</a></li>
<li><a class="reference internal" href="#id600" id="id1514">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-invariant-group-barrier-intrinsic" id="id1515">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id601" id="id1516">Syntax:</a></li>
<li><a class="reference internal" href="#id602" id="id1517">Overview:</a></li>
<li><a class="reference internal" href="#id603" id="id1518">Arguments:</a></li>
<li><a class="reference internal" href="#id604" id="id1519">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#general-intrinsics" id="id1520">General Intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-var-annotation-intrinsic" id="id1521">&#8216;<code class="docutils literal"><span class="pre">llvm.var.annotation</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id605" id="id1522">Syntax:</a></li>
<li><a class="reference internal" href="#id606" id="id1523">Overview:</a></li>
<li><a class="reference internal" href="#id607" id="id1524">Arguments:</a></li>
<li><a class="reference internal" href="#id608" id="id1525">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ptr-annotation-intrinsic" id="id1526">&#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id609" id="id1527">Syntax:</a></li>
<li><a class="reference internal" href="#id610" id="id1528">Overview:</a></li>
<li><a class="reference internal" href="#id611" id="id1529">Arguments:</a></li>
<li><a class="reference internal" href="#id612" id="id1530">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-annotation-intrinsic" id="id1531">&#8216;<code class="docutils literal"><span class="pre">llvm.annotation.*</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id613" id="id1532">Syntax:</a></li>
<li><a class="reference internal" href="#id614" id="id1533">Overview:</a></li>
<li><a class="reference internal" href="#id615" id="id1534">Arguments:</a></li>
<li><a class="reference internal" href="#id616" id="id1535">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-trap-intrinsic" id="id1536">&#8216;<code class="docutils literal"><span class="pre">llvm.trap</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id617" id="id1537">Syntax:</a></li>
<li><a class="reference internal" href="#id618" id="id1538">Overview:</a></li>
<li><a class="reference internal" href="#id619" id="id1539">Arguments:</a></li>
<li><a class="reference internal" href="#id620" id="id1540">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-debugtrap-intrinsic" id="id1541">&#8216;<code class="docutils literal"><span class="pre">llvm.debugtrap</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id621" id="id1542">Syntax:</a></li>
<li><a class="reference internal" href="#id622" id="id1543">Overview:</a></li>
<li><a class="reference internal" href="#id623" id="id1544">Arguments:</a></li>
<li><a class="reference internal" href="#id624" id="id1545">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stackprotector-intrinsic" id="id1546">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotector</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id625" id="id1547">Syntax:</a></li>
<li><a class="reference internal" href="#id626" id="id1548">Overview:</a></li>
<li><a class="reference internal" href="#id627" id="id1549">Arguments:</a></li>
<li><a class="reference internal" href="#id628" id="id1550">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-stackprotectorcheck-intrinsic" id="id1551">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id629" id="id1552">Syntax:</a></li>
<li><a class="reference internal" href="#id630" id="id1553">Overview:</a></li>
<li><a class="reference internal" href="#id631" id="id1554">Arguments:</a></li>
<li><a class="reference internal" href="#id632" id="id1555">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-objectsize-intrinsic" id="id1556">&#8216;<code class="docutils literal"><span class="pre">llvm.objectsize</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id633" id="id1557">Syntax:</a></li>
<li><a class="reference internal" href="#id634" id="id1558">Overview:</a></li>
<li><a class="reference internal" href="#id635" id="id1559">Arguments:</a></li>
<li><a class="reference internal" href="#id636" id="id1560">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-expect-intrinsic" id="id1561">&#8216;<code class="docutils literal"><span class="pre">llvm.expect</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id637" id="id1562">Syntax:</a></li>
<li><a class="reference internal" href="#id638" id="id1563">Overview:</a></li>
<li><a class="reference internal" href="#id639" id="id1564">Arguments:</a></li>
<li><a class="reference internal" href="#id640" id="id1565">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-assume-intrinsic" id="id1566">&#8216;<code class="docutils literal"><span class="pre">llvm.assume</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id641" id="id1567">Syntax:</a></li>
<li><a class="reference internal" href="#id642" id="id1568">Overview:</a></li>
<li><a class="reference internal" href="#id643" id="id1569">Arguments:</a></li>
<li><a class="reference internal" href="#id644" id="id1570">Semantics:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-bitset-test-intrinsic" id="id1571">&#8216;<code class="docutils literal"><span class="pre">llvm.bitset.test</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id645" id="id1572">Syntax:</a></li>
<li><a class="reference internal" href="#id646" id="id1573">Arguments:</a></li>
<li><a class="reference internal" href="#id647" id="id1574">Overview:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-donothing-intrinsic" id="id1575">&#8216;<code class="docutils literal"><span class="pre">llvm.donothing</span></code>&#8216; Intrinsic</a><ul>
<li><a class="reference internal" href="#id648" id="id1576">Syntax:</a></li>
<li><a class="reference internal" href="#id649" id="id1577">Overview:</a></li>
<li><a class="reference internal" href="#id650" id="id1578">Arguments:</a></li>
<li><a class="reference internal" href="#id651" id="id1579">Semantics:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#stack-map-intrinsics" id="id1580">Stack Map Intrinsics</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id652">摘要</a><a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>这份文档是LLVM汇编语言的语法参考手册，LLVM汇编语言是一种 <a href="#id1581"><span class="problematic" id="id1582">`静态单赋值（SSA）&lt;https://www.wikiwand.com/zh/静态单赋值形式&gt;`_</span></a> 的中间表示，提供了类型安全检查，低层次的操作符，灵活和清晰表达‘几乎所有’高级语言的能力。同时，它也是LLVM编译算法中各个阶段的一种通用代码表达形式。</p>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id653">简介</a><a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>LLVM的中间代码表示被设计成用在以下三种不同的形式下：作为一种编译器的内存中的中间代码（IR），作为一种保存在磁盘中的字节码形式（适合被JIT编译器快速装载），作为人类可读的汇编语言表示。这使得LLVM为编译器的高效转换和分析提供了一种强有力的中间表达形式，同时也提供了一种很自然的方法来调试和可视化编译后的代码。这三种不同的LLVM中间代码的形式是完全等价的，这份文档就在描述人类可读的形式和其所用到的符号。</p>
<p>LLVM中间字节码表示的目标是，成为一种轻量级和低层次的，同时有表现力的、类型化的并且可扩展的中间语言，更要成为一种 “通用中间表示（IR）”，并且是足够低层次的，这样才能让高层次的语言设计能够清晰地映射到这种中间表示上（就像微处理器指令——机器码，也可以看做是一种中间表示，允许源代码映射到它们上）通过提供类型信息，LLVM可以被用在优化目标上。例如：通过指针分析，可以证明C自动变量是从没存取过函数外的外部变量的，允许提升一个简单的SSA变量，替代一个内存地址等。</p>
<div class="section" id="well-formedness">
<span id="wellformed"></span><h3><a class="toc-backref" href="#id654">结构良好性</a><a class="headerlink" href="#well-formedness" title="永久链接至标题">¶</a></h3>
<p>It is important to note that this document describes &#8216;well formed&#8217; LLVM
assembly language. There is a difference between what the parser accepts
and what is considered &#8216;well formed&#8217;. For example, the following
instruction is syntactically okay, but not well formed:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%x</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="nv">%x</span>
</pre></div>
</div>
<p>because the definition of <code class="docutils literal"><span class="pre">%x</span></code> does not dominate all of its uses. The
LLVM infrastructure provides a verification pass that may be used to
verify that an LLVM module is well formed. This pass is automatically
run by the parser after parsing input assembly and by the optimizer
before it outputs bitcode. The violations pointed out by the verifier
pass indicate bugs in transformation passes or input to the parser.</p>
</div>
</div>
<div class="section" id="identifiers">
<span id="id1"></span><h2><a class="toc-backref" href="#id655">标识符</a><a class="headerlink" href="#identifiers" title="永久链接至标题">¶</a></h2>
<p>LLVM identifiers come in two basic types: global and local. Global
identifiers (functions, global variables) begin with the <code class="docutils literal"><span class="pre">'&#64;'</span></code>
character. Local identifiers (register names, types) begin with the
<code class="docutils literal"><span class="pre">'%'</span></code> character. Additionally, there are three different formats for
identifiers, for different purposes:</p>
<ol class="arabic simple">
<li>Named values are represented as a string of characters with their
prefix. For example, <code class="docutils literal"><span class="pre">%foo</span></code>, <code class="docutils literal"><span class="pre">&#64;DivisionByZero</span></code>,
<code class="docutils literal"><span class="pre">%a.really.long.identifier</span></code>. The actual regular expression used is
&#8216;<code class="docutils literal"><span class="pre">[%&#64;][-a-zA-Z$._][-a-zA-Z$._0-9]*</span></code>&#8216;. Identifiers that require other
characters in their names can be surrounded with quotes. Special
characters may be escaped using <code class="docutils literal"><span class="pre">&quot;\xx&quot;</span></code> where <code class="docutils literal"><span class="pre">xx</span></code> is the ASCII
code for the character in hexadecimal. In this way, any character can
be used in a name value, even quotes themselves. The <code class="docutils literal"><span class="pre">&quot;\01&quot;</span></code> prefix
can be used on global variables to suppress mangling.</li>
<li>Unnamed values are represented as an unsigned numeric value with
their prefix. For example, <code class="docutils literal"><span class="pre">%12</span></code>, <code class="docutils literal"><span class="pre">&#64;2</span></code>, <code class="docutils literal"><span class="pre">%44</span></code>.</li>
<li>Constants, which are described in the section <a class="reference internal" href="#constants">Constants</a> below.</li>
</ol>
<p>LLVM requires that values start with a prefix for two reasons: Compilers
don&#8217;t need to worry about name clashes with reserved words, and the set
of reserved words may be expanded in the future without penalty.
Additionally, unnamed identifiers allow a compiler to quickly come up
with a temporary variable without having to avoid symbol table
conflicts.</p>
<p>Reserved words in LLVM are very similar to reserved words in other
languages. There are keywords for different opcodes (&#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216;,
&#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216;, etc...), for primitive type names (&#8216;<code class="docutils literal"><span class="pre">void</span></code>&#8216;,
&#8216;<code class="docutils literal"><span class="pre">i32</span></code>&#8216;, etc...), and others. These reserved words cannot conflict
with variable names, because none of them start with a prefix character
(<code class="docutils literal"><span class="pre">'%'</span></code> or <code class="docutils literal"><span class="pre">'&#64;'</span></code>).</p>
<p>Here is an example of LLVM code to multiply the integer variable
&#8216;<code class="docutils literal"><span class="pre">%X</span></code>&#8216; by 8:</p>
<p>The easy way:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="m">8</span>
</pre></div>
</div>
<p>After strength reduction:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="m">3</span>
</pre></div>
</div>
<p>And the hard way:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%X</span>           <span class="c">; yields i32:%0</span>
<span class="nv nv-Anonymous">%1</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="nv nv-Anonymous">%0</span>           <span class="c">; yields i32:%1</span>
<span class="nv">%result</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%1</span><span class="p">,</span> <span class="nv nv-Anonymous">%1</span>
</pre></div>
</div>
<p>This last way of multiplying <code class="docutils literal"><span class="pre">%X</span></code> by 8 illustrates several important
lexical features of LLVM:</p>
<ol class="arabic simple">
<li>Comments are delimited with a &#8216;<code class="docutils literal"><span class="pre">;</span></code>&#8216; and go until the end of line.</li>
<li>Unnamed temporaries are created when the result of a computation is
not assigned to a named value.</li>
<li>Unnamed temporaries are numbered sequentially (using a per-function
incrementing counter, starting with 0). Note that basic blocks and unnamed
function parameters are included in this numbering. For example, if the
entry basic block is not given a label name and all function parameters are
named, then it will get number 0.</li>
</ol>
<p>It also shows a convention that we follow in this document. When
demonstrating instructions, we will follow an instruction with a comment
that defines the type and name of value produced.</p>
</div>
<div class="section" id="high-level-structure">
<h2><a class="toc-backref" href="#id656">High Level Structure</a><a class="headerlink" href="#high-level-structure" title="永久链接至标题">¶</a></h2>
<div class="section" id="module-structure">
<h3><a class="toc-backref" href="#id657">Module Structure</a><a class="headerlink" href="#module-structure" title="永久链接至标题">¶</a></h3>
<p>LLVM programs are composed of <code class="docutils literal"><span class="pre">Module</span></code>&#8216;s, each of which is a
translation unit of the input programs. Each module consists of
functions, global variables, and symbol table entries. Modules may be
combined together with the LLVM linker, which merges function (and
global variable) definitions, resolves forward declarations, and merges
symbol table entries. Here is an example of the &#8220;hello world&#8221; module:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Declare the string constant as a global constant.</span>
<span class="vg">@.str</span> <span class="p">=</span> <span class="k">private</span> <span class="k">unnamed_addr</span> <span class="k">constant</span> <span class="p">[</span><span class="m">13</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;hello world\0A\00&quot;</span>

<span class="c">; External declaration of the puts function</span>
<span class="k">declare</span> <span class="k">i32</span> <span class="vg">@puts</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nocapture</span><span class="p">)</span> <span class="k">nounwind</span>

<span class="c">; Definition of main function</span>
<span class="k">define</span> <span class="k">i32</span> <span class="vg">@main</span><span class="p">()</span> <span class="p">{</span>   <span class="c">; i32()*</span>
  <span class="c">; Convert [13 x i8]* to i8  *...</span>
  <span class="nv">%cast210</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">13</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">13</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@.str</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span>

  <span class="c">; Call puts function to write out the string to stdout.</span>
  <span class="k">call</span> <span class="k">i32</span> <span class="vg">@puts</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%cast210</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
<span class="p">}</span>

<span class="c">; Named metadata</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="k">i32</span> <span class="m">42</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="nv">!&quot;string&quot;</span><span class="p">}</span>
<span class="nv">!foo</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
</pre></div>
</div>
<p>This example is made up of a <a class="reference internal" href="#globalvars"><span class="std std-ref">global variable</span></a> named
&#8220;<code class="docutils literal"><span class="pre">.str</span></code>&#8221;, an external declaration of the &#8220;<code class="docutils literal"><span class="pre">puts</span></code>&#8221; function, a
<a class="reference internal" href="#functionstructure"><span class="std std-ref">function definition</span></a> for &#8220;<code class="docutils literal"><span class="pre">main</span></code>&#8221; and
<a class="reference internal" href="#namedmetadatastructure"><span class="std std-ref">named metadata</span></a> &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221;.</p>
<p>In general, a module is made up of a list of global values (where both
functions and global variables are global values). Global values are
represented by a pointer to a memory location (in this case, a pointer
to an array of char, and a pointer to a function), and have one of the
following <a class="reference internal" href="#linkage"><span class="std std-ref">linkage types</span></a>.</p>
</div>
<div class="section" id="linkage-types">
<span id="linkage"></span><h3><a class="toc-backref" href="#id658">Linkage Types</a><a class="headerlink" href="#linkage-types" title="永久链接至标题">¶</a></h3>
<p>All Global Variables and Functions have one of the following types of
linkage:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>Global values with &#8220;<code class="docutils literal"><span class="pre">private</span></code>&#8221; linkage are only directly
accessible by objects in the current module. In particular, linking
code into a module with an private global value may cause the
private to be renamed as necessary to avoid collisions. Because the
symbol is private to the module, all references can be updated. This
doesn&#8217;t show up in any symbol table in the object file.</dd>
<dt><code class="docutils literal"><span class="pre">internal</span></code></dt>
<dd>Similar to private, but the value shows as a local symbol
(<code class="docutils literal"><span class="pre">STB_LOCAL</span></code> in the case of ELF) in the object file. This
corresponds to the notion of the &#8216;<code class="docutils literal"><span class="pre">static</span></code>&#8216; keyword in C.</dd>
<dt><code class="docutils literal"><span class="pre">available_externally</span></code></dt>
<dd>Globals with &#8220;<code class="docutils literal"><span class="pre">available_externally</span></code>&#8221; linkage are never emitted into
the object file corresponding to the LLVM module. From the linker&#8217;s
perspective, an <code class="docutils literal"><span class="pre">available_externally</span></code> global is equivalent to
an external declaration. They exist to allow inlining and other
optimizations to take place given knowledge of the definition of the
global, which is known to be somewhere outside the module. Globals
with <code class="docutils literal"><span class="pre">available_externally</span></code> linkage are allowed to be discarded at
will, and allow inlining and other optimizations. This linkage type is
only allowed on definitions, not declarations.</dd>
<dt><code class="docutils literal"><span class="pre">linkonce</span></code></dt>
<dd>Globals with &#8220;<code class="docutils literal"><span class="pre">linkonce</span></code>&#8221; linkage are merged with other globals of
the same name when linkage occurs. This can be used to implement
some forms of inline functions, templates, or other code which must
be generated in each translation unit that uses it, but where the
body may be overridden with a more definitive definition later.
Unreferenced <code class="docutils literal"><span class="pre">linkonce</span></code> globals are allowed to be discarded. Note
that <code class="docutils literal"><span class="pre">linkonce</span></code> linkage does not actually allow the optimizer to
inline the body of this function into callers because it doesn&#8217;t
know if this definition of the function is the definitive definition
within the program or whether it will be overridden by a stronger
definition. To enable inlining and other optimizations, use
&#8220;<code class="docutils literal"><span class="pre">linkonce_odr</span></code>&#8221; linkage.</dd>
<dt><code class="docutils literal"><span class="pre">weak</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">weak</span></code>&#8221; linkage has the same merging semantics as <code class="docutils literal"><span class="pre">linkonce</span></code>
linkage, except that unreferenced globals with <code class="docutils literal"><span class="pre">weak</span></code> linkage may
not be discarded. This is used for globals that are declared &#8220;weak&#8221;
in C source code.</dd>
<dt><code class="docutils literal"><span class="pre">common</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">common</span></code>&#8221; linkage is most similar to &#8220;<code class="docutils literal"><span class="pre">weak</span></code>&#8221; linkage, but they
are used for tentative definitions in C, such as &#8220;<code class="docutils literal"><span class="pre">int</span> <span class="pre">X;</span></code>&#8221; at
global scope. Symbols with &#8220;<code class="docutils literal"><span class="pre">common</span></code>&#8221; linkage are merged in the
same way as <code class="docutils literal"><span class="pre">weak</span> <span class="pre">symbols</span></code>, and they may not be deleted if
unreferenced. <code class="docutils literal"><span class="pre">common</span></code> symbols may not have an explicit section,
must have a zero initializer, and may not be marked
&#8216;<a class="reference internal" href="#globalvars"><span class="std std-ref">constant</span></a>&#8216;. Functions and aliases may not have
common linkage.</dd>
</dl>
<dl class="docutils" id="linkage-appending">
<dt><code class="docutils literal"><span class="pre">appending</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">appending</span></code>&#8221; linkage may only be applied to global variables of
pointer to array type. When two global variables with appending
linkage are linked together, the two global arrays are appended
together. This is the LLVM, typesafe, equivalent of having the
system linker append together &#8220;sections&#8221; with identical names when
.o files are linked.</dd>
<dt><code class="docutils literal"><span class="pre">extern_weak</span></code></dt>
<dd>The semantics of this linkage follow the ELF object file model: the
symbol is weak until linked, if not linked, the symbol becomes null
instead of being an undefined reference.</dd>
<dt><code class="docutils literal"><span class="pre">linkonce_odr</span></code>, <code class="docutils literal"><span class="pre">weak_odr</span></code></dt>
<dd>Some languages allow differing globals to be merged, such as two
functions with different semantics. Other languages, such as
<code class="docutils literal"><span class="pre">C++</span></code>, ensure that only equivalent globals are ever merged (the
&#8220;one definition rule&#8221; &#8212; &#8220;ODR&#8221;). Such languages can use the
<code class="docutils literal"><span class="pre">linkonce_odr</span></code> and <code class="docutils literal"><span class="pre">weak_odr</span></code> linkage types to indicate that the
global will only be merged with equivalent globals. These linkage
types are otherwise the same as their non-<code class="docutils literal"><span class="pre">odr</span></code> versions.</dd>
<dt><code class="docutils literal"><span class="pre">external</span></code></dt>
<dd>If none of the above identifiers are used, the global is externally
visible, meaning that it participates in linkage and can be used to
resolve external symbol references.</dd>
</dl>
<p>It is illegal for a function <em>declaration</em> to have any linkage type
other than <code class="docutils literal"><span class="pre">external</span></code> or <code class="docutils literal"><span class="pre">extern_weak</span></code>.</p>
</div>
<div class="section" id="calling-conventions">
<span id="callingconv"></span><h3><a class="toc-backref" href="#id659">Calling Conventions</a><a class="headerlink" href="#calling-conventions" title="永久链接至标题">¶</a></h3>
<p>LLVM <a class="reference internal" href="#functionstructure"><span class="std std-ref">functions</span></a>, <a class="reference internal" href="#i-call"><span class="std std-ref">calls</span></a> and
<a class="reference internal" href="#i-invoke"><span class="std std-ref">invokes</span></a> can all have an optional calling convention
specified for the call. The calling convention of any pair of dynamic
caller/callee must match, or the behavior of the program is undefined.
The following calling conventions are supported by LLVM, and more may be
added in the future:</p>
<dl class="docutils">
<dt>&#8220;<code class="docutils literal"><span class="pre">ccc</span></code>&#8221; - The C calling convention</dt>
<dd>This calling convention (the default if no other calling convention
is specified) matches the target C calling conventions. This calling
convention supports varargs function calls and tolerates some
mismatch in the declared prototype and implemented declaration of
the function (as does normal C).</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">fastcc</span></code>&#8221; - The fast calling convention</dt>
<dd>This calling convention attempts to make calls as fast as possible
(e.g. by passing things in registers). This calling convention
allows the target to use whatever tricks it wants to produce fast
code for the target, without having to conform to an externally
specified ABI (Application Binary Interface). <a class="reference external" href="CodeGenerator.html#id80">Tail calls can only
be optimized when this, the GHC or the HiPE convention is
used.</a> This calling convention does not
support varargs and requires the prototype of all callees to exactly
match the prototype of the function definition.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">coldcc</span></code>&#8221; - The cold calling convention</dt>
<dd>This calling convention attempts to make code in the caller as
efficient as possible under the assumption that the call is not
commonly executed. As such, these calls often preserve all registers
so that the call does not break any live ranges in the caller side.
This calling convention does not support varargs and requires the
prototype of all callees to exactly match the prototype of the
function definition. Furthermore the inliner doesn&#8217;t consider such function
calls for inlining.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cc</span> <span class="pre">10</span></code>&#8221; - GHC convention</dt>
<dd><p class="first">This calling convention has been implemented specifically for use by
the <a class="reference external" href="http://www.haskell.org/ghc">Glasgow Haskell Compiler (GHC)</a>.
It passes everything in registers, going to extremes to achieve this
by disabling callee save registers. This calling convention should
not be used lightly but only for specific situations such as an
alternative to the <em>register pinning</em> performance technique often
used when implementing functional programming languages. At the
moment only X86 supports this convention and it has the following
limitations:</p>
<ul class="simple">
<li>On <em>X86-32</em> only supports up to 4 bit type parameters. No
floating point types are supported.</li>
<li>On <em>X86-64</em> only supports up to 10 bit type parameters and 6
floating point parameters.</li>
</ul>
<p class="last">This calling convention supports <a class="reference external" href="CodeGenerator.html#id80">tail call
optimization</a> but requires both the
caller and callee are using it.</p>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cc</span> <span class="pre">11</span></code>&#8221; - The HiPE calling convention</dt>
<dd>This calling convention has been implemented specifically for use by
the <a class="reference external" href="http://www.it.uu.se/research/group/hipe/">High-Performance Erlang
(HiPE)</a> compiler, <em>the</em>
native code compiler of the <a class="reference external" href="http://www.erlang.org/download.shtml">Ericsson&#8217;s Open Source Erlang/OTP
system</a>. It uses more
registers for argument passing than the ordinary C calling
convention and defines no callee-saved registers. The calling
convention properly supports <a class="reference external" href="CodeGenerator.html#id80">tail call
optimization</a> but requires that both the
caller and the callee use it. It uses a <em>register pinning</em>
mechanism, similar to GHC&#8217;s convention, for keeping frequently
accessed runtime components pinned to specific hardware registers.
At the moment only X86 supports this convention (both 32 and 64
bit).</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">webkit_jscc</span></code>&#8221; - WebKit&#8217;s JavaScript calling convention</dt>
<dd>This calling convention has been implemented for <a class="reference external" href="https://trac.webkit.org/wiki/FTLJIT">WebKit FTL JIT</a>. It passes arguments on the
stack right to left (as cdecl does), and returns a value in the
platform&#8217;s customary return register.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">anyregcc</span></code>&#8221; - Dynamic calling convention for code patching</dt>
<dd>This is a special convention that supports patching an arbitrary code
sequence in place of a call site. This convention forces the call
arguments into registers but allows them to be dynamically
allocated. This can currently only be used with calls to
llvm.experimental.patchpoint because only this intrinsic records
the location of its arguments in a side table. See <a class="reference internal" href="StackMaps.html"><span class="doc">Stack maps and patch points in LLVM</span></a>.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">preserve_mostcc</span></code>&#8221; - The <cite>PreserveMost</cite> calling convention</dt>
<dd><p class="first">This calling convention attempts to make the code in the caller as
unintrusive as possible. This convention behaves identically to the <cite>C</cite>
calling convention on how arguments and return values are passed, but it
uses a different set of caller/callee-saved registers. This alleviates the
burden of saving and recovering a large register set before and after the
call in the caller. If the arguments are passed in callee-saved registers,
then they will be preserved by the callee across the call. This doesn&#8217;t
apply for values returned in callee-saved registers.</p>
<ul class="simple">
<li>On X86-64 the callee preserves all general purpose registers, except for
R11. R11 can be used as a scratch register. Floating-point registers
(XMMs/YMMs) are not preserved and need to be saved by the caller.</li>
</ul>
<p>The idea behind this convention is to support calls to runtime functions
that have a hot path and a cold path. The hot path is usually a small piece
of code that doesn&#8217;t use many registers. The cold path might need to call out to
another function and therefore only needs to preserve the caller-saved
registers, which haven&#8217;t already been saved by the caller. The
<cite>PreserveMost</cite> calling convention is very similar to the <cite>cold</cite> calling
convention in terms of caller/callee-saved registers, but they are used for
different types of function calls. <cite>coldcc</cite> is for function calls that are
rarely executed, whereas <cite>preserve_mostcc</cite> function calls are intended to be
on the hot path and definitely executed a lot. Furthermore <cite>preserve_mostcc</cite>
doesn&#8217;t prevent the inliner from inlining the function call.</p>
<p class="last">This calling convention will be used by a future version of the ObjectiveC
runtime and should therefore still be considered experimental at this time.
Although this convention was created to optimize certain runtime calls to
the ObjectiveC runtime, it is not limited to this runtime and might be used
by other runtimes in the future too. The current implementation only
supports X86-64, but the intention is to support more architectures in the
future.</p>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">preserve_allcc</span></code>&#8221; - The <cite>PreserveAll</cite> calling convention</dt>
<dd><p class="first">This calling convention attempts to make the code in the caller even less
intrusive than the <cite>PreserveMost</cite> calling convention. This calling
convention also behaves identical to the <cite>C</cite> calling convention on how
arguments and return values are passed, but it uses a different set of
caller/callee-saved registers. This removes the burden of saving and
recovering a large register set before and after the call in the caller. If
the arguments are passed in callee-saved registers, then they will be
preserved by the callee across the call. This doesn&#8217;t apply for values
returned in callee-saved registers.</p>
<ul class="simple">
<li>On X86-64 the callee preserves all general purpose registers, except for
R11. R11 can be used as a scratch register. Furthermore it also preserves
all floating-point registers (XMMs/YMMs).</li>
</ul>
<p>The idea behind this convention is to support calls to runtime functions
that don&#8217;t need to call out to any other functions.</p>
<p class="last">This calling convention, like the <cite>PreserveMost</cite> calling convention, will be
used by a future version of the ObjectiveC runtime and should be considered
experimental at this time.</p>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cxx_fast_tlscc</span></code>&#8221; - The <cite>CXX_FAST_TLS</cite> calling convention for access functions</dt>
<dd><p class="first">Clang generates an access function to access C++-style TLS. The access
function generally has an entry block, an exit block and an initialization
block that is run at the first time. The entry and exit blocks can access
a few TLS IR variables, each access will be lowered to a platform-specific
sequence.</p>
<p>This calling convention aims to minimize overhead in the caller by
preserving as many registers as possible (all the registers that are
perserved on the fast path, composed of the entry and exit blocks).</p>
<p>This calling convention behaves identical to the <cite>C</cite> calling convention on
how arguments and return values are passed, but it uses a different set of
caller/callee-saved registers.</p>
<p>Given that each platform has its own lowering sequence, hence its own set
of preserved registers, we can&#8217;t use the existing <cite>PreserveMost</cite>.</p>
<ul class="last simple">
<li>On X86-64 the callee preserves all general purpose registers, except for
RDI and RAX.</li>
</ul>
</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">cc</span> <span class="pre">&lt;n&gt;</span></code>&#8221; - Numbered convention</dt>
<dd>Any calling convention may be specified by number, allowing
target-specific calling conventions to be used. Target specific
calling conventions start at 64.</dd>
</dl>
<p>More calling conventions can be added/defined on an as-needed basis, to
support Pascal conventions or any other well-known target-independent
convention.</p>
</div>
<div class="section" id="visibility-styles">
<span id="visibilitystyles"></span><h3><a class="toc-backref" href="#id660">Visibility Styles</a><a class="headerlink" href="#visibility-styles" title="永久链接至标题">¶</a></h3>
<p>All Global Variables and Functions have one of the following visibility
styles:</p>
<dl class="docutils">
<dt>&#8220;<code class="docutils literal"><span class="pre">default</span></code>&#8221; - Default style</dt>
<dd>On targets that use the ELF object file format, default visibility
means that the declaration is visible to other modules and, in
shared libraries, means that the declared entity may be overridden.
On Darwin, default visibility means that the declaration is visible
to other modules. Default visibility corresponds to &#8220;external
linkage&#8221; in the language.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">hidden</span></code>&#8221; - Hidden style</dt>
<dd>Two declarations of an object with hidden visibility refer to the
same object if they are in the same shared object. Usually, hidden
visibility indicates that the symbol will not be placed into the
dynamic symbol table, so no other module (executable or shared
library) can reference it directly.</dd>
<dt>&#8220;<code class="docutils literal"><span class="pre">protected</span></code>&#8221; - Protected style</dt>
<dd>On ELF, protected visibility indicates that the symbol will be
placed in the dynamic symbol table, but that references within the
defining module will bind to the local symbol. That is, the symbol
cannot be overridden by another module.</dd>
</dl>
<p>A symbol with <code class="docutils literal"><span class="pre">internal</span></code> or <code class="docutils literal"><span class="pre">private</span></code> linkage must have <code class="docutils literal"><span class="pre">default</span></code>
visibility.</p>
</div>
<div class="section" id="dll-storage-classes">
<span id="dllstorageclass"></span><h3><a class="toc-backref" href="#id661">DLL Storage Classes</a><a class="headerlink" href="#dll-storage-classes" title="永久链接至标题">¶</a></h3>
<p>All Global Variables, Functions and Aliases can have one of the following
DLL storage class:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dllimport</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">dllimport</span></code>&#8221; causes the compiler to reference a function or variable via
a global pointer to a pointer that is set up by the DLL exporting the
symbol. On Microsoft Windows targets, the pointer name is formed by
combining <code class="docutils literal"><span class="pre">__imp_</span></code> and the function or variable name.</dd>
<dt><code class="docutils literal"><span class="pre">dllexport</span></code></dt>
<dd>&#8220;<code class="docutils literal"><span class="pre">dllexport</span></code>&#8221; causes the compiler to provide a global pointer to a pointer
in a DLL, so that it can be referenced with the <code class="docutils literal"><span class="pre">dllimport</span></code> attribute. On
Microsoft Windows targets, the pointer name is formed by combining
<code class="docutils literal"><span class="pre">__imp_</span></code> and the function or variable name. Since this storage class
exists for defining a dll interface, the compiler, assembler and linker know
it is externally referenced and must refrain from deleting the symbol.</dd>
</dl>
</div>
<div class="section" id="thread-local-storage-models">
<span id="tls-model"></span><h3><a class="toc-backref" href="#id662">Thread Local Storage Models</a><a class="headerlink" href="#thread-local-storage-models" title="永久链接至标题">¶</a></h3>
<p>A variable may be defined as <code class="docutils literal"><span class="pre">thread_local</span></code>, which means that it will
not be shared by threads (each thread will have a separated copy of the
variable). Not all targets support thread-local variables. Optionally, a
TLS model may be specified:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">localdynamic</span></code></dt>
<dd>For variables that are only used within the current shared library.</dd>
<dt><code class="docutils literal"><span class="pre">initialexec</span></code></dt>
<dd>For variables in modules that will not be loaded dynamically.</dd>
<dt><code class="docutils literal"><span class="pre">localexec</span></code></dt>
<dd>For variables defined in the executable and only used within it.</dd>
</dl>
<p>If no explicit model is given, the &#8220;general dynamic&#8221; model is used.</p>
<p>The models correspond to the ELF TLS models; see <a class="reference external" href="http://people.redhat.com/drepper/tls.pdf">ELF Handling For
Thread-Local Storage</a> for
more information on under which circumstances the different models may
be used. The target may choose a different TLS model if the specified
model is not supported, or if a better choice of model can be made.</p>
<p>A model can also be specified in an alias, but then it only governs how
the alias is accessed. It will not have any effect in the aliasee.</p>
<p>For platforms without linker support of ELF TLS model, the -femulated-tls
flag can be used to generate GCC compatible emulated TLS code.</p>
</div>
<div class="section" id="structure-types">
<span id="namedtypes"></span><h3><a class="toc-backref" href="#id663">Structure Types</a><a class="headerlink" href="#structure-types" title="永久链接至标题">¶</a></h3>
<p>LLVM IR allows you to specify both &#8220;identified&#8221; and &#8220;literal&#8221; <a class="reference internal" href="#t-struct"><span class="std std-ref">structure
types</span></a>. Literal types are uniqued structurally, but identified types
are never uniqued. An <a class="reference internal" href="#t-opaque"><span class="std std-ref">opaque structural type</span></a> can also be used
to forward declare a type that is not yet available.</p>
<p>An example of an identified structure specification is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%mytype</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="nv">%mytype</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
</pre></div>
</div>
<p>Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only
literal types are uniqued in recent versions of LLVM.</p>
</div>
<div class="section" id="global-variables">
<span id="globalvars"></span><h3><a class="toc-backref" href="#id664">Global Variables</a><a class="headerlink" href="#global-variables" title="永久链接至标题">¶</a></h3>
<p>Global variables define regions of memory allocated at compilation time
instead of run-time.</p>
<p>Global variable definitions must be initialized.</p>
<p>Global variables in other translation units can also be declared, in which
case they don&#8217;t have an initializer.</p>
<p>Either global variable definitions or declarations may have an explicit section
to be placed in and may have an optional explicit alignment specified.</p>
<p>A variable may be defined as a global <code class="docutils literal"><span class="pre">constant</span></code>, which indicates that
the contents of the variable will <strong>never</strong> be modified (enabling better
optimization, allowing the global data to be placed in the read-only
section of an executable, etc). Note that variables that need runtime
initialization cannot be marked <code class="docutils literal"><span class="pre">constant</span></code> as there is a store to the
variable.</p>
<p>LLVM explicitly allows <em>declarations</em> of global variables to be marked
constant, even if the final definition of the global is not. This
capability can be used to enable slightly better optimization of the
program, but requires the language definition to guarantee that
optimizations based on the &#8216;constantness&#8217; are valid for the translation
units that do not include the definition.</p>
<p>As SSA values, global variables define pointer values that are in scope
(i.e. they dominate) all basic blocks in the program. Global variables
always define a pointer to their &#8220;content&#8221; type because they describe a
region of memory, and all memory objects in LLVM are accessed through
pointers.</p>
<p>Global variables can be marked with <code class="docutils literal"><span class="pre">unnamed_addr</span></code> which indicates
that the address is not significant, only the content. Constants marked
like this can be merged with other constants if they have the same
initializer. Note that a constant with significant address <em>can</em> be
merged with a <code class="docutils literal"><span class="pre">unnamed_addr</span></code> constant, the result being a constant
whose address is significant.</p>
<p>A global variable may be declared to reside in a target-specific
numbered address space. For targets that support them, address spaces
may affect how optimizations are performed and/or what target
instructions are used to access the variable. The default address space
is zero. The address space qualifier must precede any other attributes.</p>
<p>LLVM allows an explicit section to be specified for globals. If the
target supports it, it will emit globals to the section specified.
Additionally, the global can placed in a comdat if the target has the necessary
support.</p>
<p>By default, global initializers are optimized by assuming that global
variables defined within the module are not modified from their
initial values before the start of the global initializer. This is
true even for variables potentially accessible from outside the
module, including those with external linkage or appearing in
<code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> or dllexported variables. This assumption may be suppressed
by marking the variable with <code class="docutils literal"><span class="pre">externally_initialized</span></code>.</p>
<p>An explicit alignment may be specified for a global, which must be a
power of 2. If not present, or if the alignment is set to zero, the
alignment of the global is set by the target to whatever it feels
convenient. If an explicit alignment is specified, the global is forced
to have exactly that alignment. Targets and optimizers are not allowed
to over-align the global if the global has an assigned section. In this
case, the extra alignment could be observable: for example, code could
assume that the globals are densely packed in their section and try to
iterate over them as an array, alignment padding would break this
iteration. The maximum alignment is <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>.</p>
<p>Globals can also have a <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a>.</p>
<p>Variables and aliases can have a
<a class="reference internal" href="#tls-model"><span class="std std-ref">Thread Local Storage Model</span></a>.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>[@&lt;GlobalVarName&gt; =] [Linkage] [Visibility] [DLLStorageClass] [ThreadLocal]
                     [unnamed_addr] [AddrSpace] [ExternallyInitialized]
                     &lt;global | constant&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]
                     [, section &quot;name&quot;] [, comdat [($name)]]
                     [, align &lt;Alignment&gt;]
</pre></div>
</div>
<p>For example, the following defines a global in a numbered address space
with an initializer, section, and alignment:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="k">constant</span> <span class="kt">float</span> <span class="m">1.0</span><span class="p">,</span> <span class="k">section</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
</pre></div>
</div>
<p>The following example just declares a global variable</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i32</span>
</pre></div>
</div>
<p>The following example defines a thread-local global with the
<code class="docutils literal"><span class="pre">initialexec</span></code> TLS model:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">thread_local</span><span class="p">(</span><span class="k">initialexec</span><span class="p">)</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<span id="functionstructure"></span><h3><a class="toc-backref" href="#id665">Functions</a><a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h3>
<p>LLVM function definitions consist of the &#8220;<code class="docutils literal"><span class="pre">define</span></code>&#8221; keyword, an
optional <a class="reference internal" href="#linkage"><span class="std std-ref">linkage type</span></a>, an optional <a class="reference internal" href="BitCodeFormat.html#visibility"><span class="std std-ref">visibility
style</span></a>, an optional <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a>,
an optional <a class="reference internal" href="#callingconv"><span class="std std-ref">calling convention</span></a>,
an optional <code class="docutils literal"><span class="pre">unnamed_addr</span></code> attribute, a return type, an optional
<a class="reference internal" href="#paramattrs"><span class="std std-ref">parameter attribute</span></a> for the return type, a function
name, a (possibly empty) argument list (each with optional <a class="reference internal" href="#paramattrs"><span class="std std-ref">parameter
attributes</span></a>), optional <a class="reference internal" href="#fnattrs"><span class="std std-ref">function attributes</span></a>,
an optional section, an optional alignment,
an optional <a class="reference internal" href="#langref-comdats"><span class="std std-ref">comdat</span></a>,
an optional <a class="reference internal" href="#gc"><span class="std std-ref">garbage collector name</span></a>, an optional <a class="reference internal" href="#prefixdata"><span class="std std-ref">prefix</span></a>,
an optional <a class="reference internal" href="#prologuedata"><span class="std std-ref">prologue</span></a>,
an optional <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality</span></a>,
an optional list of attached <a class="reference internal" href="#metadata"><span class="std std-ref">metadata</span></a>,
an opening curly brace, a list of basic blocks, and a closing curly brace.</p>
<p>LLVM function declarations consist of the &#8220;<code class="docutils literal"><span class="pre">declare</span></code>&#8221; keyword, an
optional <a class="reference internal" href="#linkage"><span class="std std-ref">linkage type</span></a>, an optional <a class="reference internal" href="BitCodeFormat.html#visibility"><span class="std std-ref">visibility
style</span></a>, an optional <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a>,
an optional <a class="reference internal" href="#callingconv"><span class="std std-ref">calling convention</span></a>,
an optional <code class="docutils literal"><span class="pre">unnamed_addr</span></code> attribute, a return type, an optional
<a class="reference internal" href="#paramattrs"><span class="std std-ref">parameter attribute</span></a> for the return type, a function
name, a possibly empty list of arguments, an optional alignment, an optional
<a class="reference internal" href="#gc"><span class="std std-ref">garbage collector name</span></a>, an optional <a class="reference internal" href="#prefixdata"><span class="std std-ref">prefix</span></a>,
and an optional <a class="reference internal" href="#prologuedata"><span class="std std-ref">prologue</span></a>.</p>
<p>A function definition contains a list of basic blocks, forming the CFG (Control
Flow Graph) for the function. Each basic block may optionally start with a label
(giving the basic block a symbol table entry), contains a list of instructions,
and ends with a <a class="reference internal" href="#terminators"><span class="std std-ref">terminator</span></a> instruction (such as a branch or
function return). If an explicit label is not provided, a block is assigned an
implicit numbered label, using the next value from the same counter as used for
unnamed temporaries (<a class="reference internal" href="#identifiers"><span class="std std-ref">see above</span></a>). For example, if a function
entry block does not have an explicit label, it will be assigned label &#8220;%0&#8221;,
then the first unnamed temporary in that block will be &#8220;%1&#8221;, etc.</p>
<p>The first basic block in a function is special in two ways: it is
immediately executed on entrance to the function, and it is not allowed
to have predecessor basic blocks (i.e. there can not be any branches to
the entry block of a function). Because the block can have no
predecessors, it also cannot have any <a class="reference internal" href="#i-phi"><span class="std std-ref">PHI nodes</span></a>.</p>
<p>LLVM allows an explicit section to be specified for functions. If the
target supports it, it will emit functions to the section specified.
Additionally, the function can be placed in a COMDAT.</p>
<p>An explicit alignment may be specified for a function. If not present,
or if the alignment is set to zero, the alignment of the function is set
by the target to whatever it feels convenient. If an explicit alignment
is specified, the function is forced to have at least that much
alignment. All alignments must be a power of 2.</p>
<p>If the <code class="docutils literal"><span class="pre">unnamed_addr</span></code> attribute is given, the address is known to not
be significant and two identical functions can be merged.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>define [linkage] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])
       [unnamed_addr] [fn Attrs] [section &quot;name&quot;] [comdat [($name)]]
       [align N] [gc] [prefix Constant] [prologue Constant]
       [personality Constant] (!name !N)* { ... }
</pre></div>
</div>
<p>The argument list is a comma separated sequence of arguments where each
argument is of the following form:</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">parameter</span> <span class="n">Attrs</span><span class="p">]</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="aliases">
<span id="langref-aliases"></span><h3><a class="toc-backref" href="#id666">Aliases</a><a class="headerlink" href="#aliases" title="永久链接至标题">¶</a></h3>
<p>Aliases, unlike function or variables, don&#8217;t create any new data. They
are just a new symbol and metadata for an existing position.</p>
<p>Aliases have a name and an aliasee that is either a global value or a
constant expression.</p>
<p>Aliases may have an optional <a class="reference internal" href="#linkage"><span class="std std-ref">linkage type</span></a>, an optional
<a class="reference internal" href="BitCodeFormat.html#visibility"><span class="std std-ref">visibility style</span></a>, an optional <a class="reference internal" href="#dllstorageclass"><span class="std std-ref">DLL storage class</span></a> and an optional <a class="reference internal" href="#tls-model"><span class="std std-ref">tls model</span></a>.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">@&lt;</span><span class="n">Name</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="n">Linkage</span><span class="p">]</span> <span class="p">[</span><span class="n">Visibility</span><span class="p">]</span> <span class="p">[</span><span class="n">DLLStorageClass</span><span class="p">]</span> <span class="p">[</span><span class="n">ThreadLocal</span><span class="p">]</span> <span class="p">[</span><span class="n">unnamed_addr</span><span class="p">]</span> <span class="n">alias</span> <span class="o">&lt;</span><span class="n">AliaseeTy</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">AliaseeTy</span><span class="o">&gt;*</span> <span class="o">@&lt;</span><span class="n">Aliasee</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The linkage must be one of <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">internal</span></code>, <code class="docutils literal"><span class="pre">linkonce</span></code>, <code class="docutils literal"><span class="pre">weak</span></code>,
<code class="docutils literal"><span class="pre">linkonce_odr</span></code>, <code class="docutils literal"><span class="pre">weak_odr</span></code>, <code class="docutils literal"><span class="pre">external</span></code>. Note that some system linkers
might not correctly handle dropping a weak symbol that is aliased.</p>
<p>Aliases that are not <code class="docutils literal"><span class="pre">unnamed_addr</span></code> are guaranteed to have the same address as
the aliasee expression. <code class="docutils literal"><span class="pre">unnamed_addr</span></code> ones are only guaranteed to point
to the same content.</p>
<p>Since aliases are only a second name, some restrictions apply, of which
some can only be checked when producing an object file:</p>
<ul class="simple">
<li>The expression defining the aliasee must be computable at assembly
time. Since it is just a name, no relocations can be used.</li>
<li>No alias in the expression can be weak as the possibility of the
intermediate alias being overridden cannot be represented in an
object file.</li>
<li>No global value in the expression can be a declaration, since that
would require a relocation, which is not possible.</li>
</ul>
</div>
<div class="section" id="comdats">
<span id="langref-comdats"></span><h3><a class="toc-backref" href="#id667">Comdats</a><a class="headerlink" href="#comdats" title="永久链接至标题">¶</a></h3>
<p>Comdat IR provides access to COFF and ELF object file COMDAT functionality.</p>
<p>Comdats have a name which represents the COMDAT key. All global objects that
specify this key will only end up in the final object file if the linker chooses
that key over some other key. Aliases are placed in the same COMDAT that their
aliasee computes to, if any.</p>
<p>Comdats have a selection kind to provide input on how the linker should
choose between keys in two different object files.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$&lt;Name&gt; = comdat SelectionKind
</pre></div>
</div>
<p>The selection kind must be one of the following:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">any</span></code></dt>
<dd>The linker may choose any COMDAT key, the choice is arbitrary.</dd>
<dt><code class="docutils literal"><span class="pre">exactmatch</span></code></dt>
<dd>The linker may choose any COMDAT key but the sections must contain the
same data.</dd>
<dt><code class="docutils literal"><span class="pre">largest</span></code></dt>
<dd>The linker will choose the section containing the largest COMDAT key.</dd>
<dt><code class="docutils literal"><span class="pre">noduplicates</span></code></dt>
<dd>The linker requires that only section with this COMDAT key exist.</dd>
<dt><code class="docutils literal"><span class="pre">samesize</span></code></dt>
<dd>The linker may choose any COMDAT key but the sections must contain the
same amount of data.</dd>
</dl>
<p>Note that the Mach-O platform doesn&#8217;t support COMDATs and ELF only supports
<code class="docutils literal"><span class="pre">any</span></code> as a selection kind.</p>
<p>Here is an example of a COMDAT group where a function will only be selected if
the COMDAT key&#8217;s section is the largest:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>$foo = comdat largest
@foo = global i32 2, comdat($foo)

define void @bar() comdat($foo) {
  ret void
}
</pre></div>
</div>
<p>As a syntactic sugar the <code class="docutils literal"><span class="pre">$name</span></code> can be omitted if the name is the same as
the global name:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>$foo = comdat any
@foo = global i32 2, comdat
</pre></div>
</div>
<p>In a COFF object file, this will create a COMDAT section with selection kind
<code class="docutils literal"><span class="pre">IMAGE_COMDAT_SELECT_LARGEST</span></code> containing the contents of the <code class="docutils literal"><span class="pre">&#64;foo</span></code> symbol
and another COMDAT section with selection kind
<code class="docutils literal"><span class="pre">IMAGE_COMDAT_SELECT_ASSOCIATIVE</span></code> which is associated with the first COMDAT
section and contains the contents of the <code class="docutils literal"><span class="pre">&#64;bar</span></code> symbol.</p>
<p>There are some restrictions on the properties of the global object.
It, or an alias to it, must have the same name as the COMDAT group when
targeting COFF.
The contents and size of this object may be used during link-time to determine
which COMDAT groups get selected depending on the selection kind.
Because the name of the object must match the name of the COMDAT group, the
linkage of the global object must not be local; local symbols can get renamed
if a collision occurs in the symbol table.</p>
<p>The combined use of COMDATS and section attributes may yield surprising results.
For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>$foo = comdat any
$bar = comdat any
@g1 = global i32 42, section &quot;sec&quot;, comdat($foo)
@g2 = global i32 42, section &quot;sec&quot;, comdat($bar)
</pre></div>
</div>
<p>From the object file perspective, this requires the creation of two sections
with the same name. This is necessary because both globals belong to different
COMDAT groups and COMDATs, at the object file level, are represented by
sections.</p>
<p>Note that certain IR constructs like global variables and functions may
create COMDATs in the object file in addition to any which are specified using
COMDAT IR. This arises when the code generator is configured to emit globals
in individual sections (e.g. when <cite>-data-sections</cite> or <cite>-function-sections</cite>
is supplied to <cite>llc</cite>).</p>
</div>
<div class="section" id="named-metadata">
<span id="namedmetadatastructure"></span><h3><a class="toc-backref" href="#id668">Named Metadata</a><a class="headerlink" href="#named-metadata" title="永久链接至标题">¶</a></h3>
<p>Named metadata is a collection of metadata. <a class="reference internal" href="#metadata"><span class="std std-ref">Metadata
nodes</span></a> (but not metadata strings) are the only valid
operands for a named metadata.</p>
<ol class="arabic simple">
<li>Named metadata are represented as a string of characters with the
metadata prefix. The rules for metadata names are the same as for
identifiers, but quoted names are not allowed. <code class="docutils literal"><span class="pre">&quot;\xx&quot;</span></code> type escapes
are still valid, which allows any character to be part of a name.</li>
</ol>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!&quot;zero&quot;}
!1 = !{!&quot;one&quot;}
!2 = !{!&quot;two&quot;}
; A named metadata.
!name = !{!0, !1, !2}
</pre></div>
</div>
</div>
<div class="section" id="parameter-attributes">
<span id="paramattrs"></span><h3><a class="toc-backref" href="#id669">Parameter Attributes</a><a class="headerlink" href="#parameter-attributes" title="永久链接至标题">¶</a></h3>
<p>The return type and each parameter of a function type may have a set of
<em>parameter attributes</em> associated with them. Parameter attributes are
used to communicate additional information about the result or
parameters of a function. Parameter attributes are considered to be part
of the function, not of the function type, so functions with different
parameter attributes can have the same function type.</p>
<p>Parameter attributes are simple keywords that follow the type specified.
If multiple parameter attributes are needed, they are space separated.
For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">declare</span> <span class="k">i32</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">noalias</span> <span class="k">nocapture</span><span class="p">,</span> <span class="p">...)</span>
<span class="k">declare</span> <span class="k">i32</span> <span class="vg">@atoi</span><span class="p">(</span><span class="k">i8</span> <span class="k">zeroext</span><span class="p">)</span>
<span class="k">declare</span> <span class="k">signext</span> <span class="k">i8</span> <span class="vg">@returns_signed_char</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that any attributes for the function result (<code class="docutils literal"><span class="pre">nounwind</span></code>,
<code class="docutils literal"><span class="pre">readonly</span></code>) come immediately after the argument list.</p>
<p>Currently, only the following parameter attributes are defined:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">zeroext</span></code></dt>
<dd>This indicates to the code generator that the parameter or return
value should be zero-extended to the extent required by the target&#8217;s
ABI (which is usually 32-bits, but is 8-bits for a i1 on x86-64) by
the caller (for a parameter) or the callee (for a return value).</dd>
<dt><code class="docutils literal"><span class="pre">signext</span></code></dt>
<dd>This indicates to the code generator that the parameter or return
value should be sign-extended to the extent required by the target&#8217;s
ABI (which is usually 32-bits) by the caller (for a parameter) or
the callee (for a return value).</dd>
<dt><code class="docutils literal"><span class="pre">inreg</span></code></dt>
<dd>This indicates that this parameter or return value should be treated
in a special target-dependent fashion while emitting code for
a function call or return (usually, by putting it in a register as
opposed to memory, though some targets use it to distinguish between
two different kinds of registers). Use of this attribute is
target-specific.</dd>
<dt><code class="docutils literal"><span class="pre">byval</span></code></dt>
<dd><p class="first">This indicates that the pointer parameter should really be passed by
value to the function. The attribute implies that a hidden copy of
the pointee is made between the caller and the callee, so the callee
is unable to modify the value in the caller. This attribute is only
valid on LLVM pointer arguments. It is generally used to pass
structs and arrays by value, but is also valid on pointers to
scalars. The copy is considered to belong to the caller not the
callee (for example, <code class="docutils literal"><span class="pre">readonly</span></code> functions should not write to
<code class="docutils literal"><span class="pre">byval</span></code> parameters). This is not a valid attribute for return
values.</p>
<p class="last">The byval attribute also supports specifying an alignment with the
align attribute. It indicates the alignment of the stack slot to
form and the known alignment of the pointer specified to the call
site. If the alignment is not specified, then the code generator
makes a target-specific assumption.</p>
</dd>
</dl>
<p id="attr-inalloca"><code class="docutils literal"><span class="pre">inalloca</span></code></p>
<blockquote>
<div><p>The <code class="docutils literal"><span class="pre">inalloca</span></code> argument attribute allows the caller to take the
address of outgoing stack arguments. An <code class="docutils literal"><span class="pre">inalloca</span></code> argument must
be a pointer to stack memory produced by an <code class="docutils literal"><span class="pre">alloca</span></code> instruction.
The alloca, or argument allocation, must also be tagged with the
inalloca keyword. Only the last argument may have the <code class="docutils literal"><span class="pre">inalloca</span></code>
attribute, and that argument is guaranteed to be passed in memory.</p>
<p>An argument allocation may be used by a call at most once because
the call may deallocate it. The <code class="docutils literal"><span class="pre">inalloca</span></code> attribute cannot be
used in conjunction with other attributes that affect argument
storage, like <code class="docutils literal"><span class="pre">inreg</span></code>, <code class="docutils literal"><span class="pre">nest</span></code>, <code class="docutils literal"><span class="pre">sret</span></code>, or <code class="docutils literal"><span class="pre">byval</span></code>. The
<code class="docutils literal"><span class="pre">inalloca</span></code> attribute also disables LLVM&#8217;s implicit lowering of
large aggregate return values, which means that frontend authors
must lower them with <code class="docutils literal"><span class="pre">sret</span></code> pointers.</p>
<p>When the call site is reached, the argument allocation must have
been the most recent stack allocation that is still live, or the
results are undefined. It is possible to allocate additional stack
space after an argument allocation and before its call site, but it
must be cleared off with <a class="reference internal" href="#int-stackrestore"><span class="std std-ref">llvm.stackrestore</span></a>.</p>
<p>See <a class="reference internal" href="InAlloca.html"><span class="doc">Design and Usage of the InAlloca Attribute</span></a> for more information on how to use this
attribute.</p>
</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sret</span></code></dt>
<dd>This indicates that the pointer parameter specifies the address of a
structure that is the return value of the function in the source
program. This pointer must be guaranteed by the caller to be valid:
loads and stores to the structure may be assumed by the callee
not to trap and to be properly aligned. This may only be applied to
the first parameter. This is not a valid attribute for return
values.</dd>
<dt><code class="docutils literal"><span class="pre">align</span> <span class="pre">&lt;n&gt;</span></code></dt>
<dd><p class="first">This indicates that the pointer value may be assumed by the optimizer to
have the specified alignment.</p>
<p class="last">Note that this attribute has additional semantics when combined with the
<code class="docutils literal"><span class="pre">byval</span></code> attribute.</p>
</dd>
</dl>
<dl class="docutils" id="noalias">
<dt><code class="docutils literal"><span class="pre">noalias</span></code></dt>
<dd><p class="first">This indicates that objects accessed via pointer values
<a class="reference internal" href="#pointeraliasing"><span class="std std-ref">based</span></a> on the argument or return value are not also
accessed, during the execution of the function, via pointer values not
<em>based</em> on the argument or return value. The attribute on a return value
also has additional semantics described below. The caller shares the
responsibility with the callee for ensuring that these requirements are met.
For further details, please see the discussion of the NoAlias response in
<a class="reference internal" href="AliasAnalysis.html#must-may-or-no"><span class="std std-ref">alias analysis</span></a>.</p>
<p>Note that this definition of <code class="docutils literal"><span class="pre">noalias</span></code> is intentionally similar
to the definition of <code class="docutils literal"><span class="pre">restrict</span></code> in C99 for function arguments.</p>
<p class="last">For function return values, C99&#8217;s <code class="docutils literal"><span class="pre">restrict</span></code> is not meaningful,
while LLVM&#8217;s <code class="docutils literal"><span class="pre">noalias</span></code> is. Furthermore, the semantics of the <code class="docutils literal"><span class="pre">noalias</span></code>
attribute on return values are stronger than the semantics of the attribute
when used on function arguments. On function return values, the <code class="docutils literal"><span class="pre">noalias</span></code>
attribute indicates that the function acts like a system memory allocation
function, returning a pointer to allocated storage disjoint from the
storage for any other object accessible to the caller.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">nocapture</span></code></dt>
<dd>This indicates that the callee does not make any copies of the
pointer that outlive the callee itself. This is not a valid
attribute for return values.</dd>
</dl>
<dl class="docutils" id="nest">
<dt><code class="docutils literal"><span class="pre">nest</span></code></dt>
<dd>This indicates that the pointer parameter can be excised using the
<a class="reference internal" href="#int-trampoline"><span class="std std-ref">trampoline intrinsics</span></a>. This is not a valid
attribute for return values and can only be applied to one parameter.</dd>
<dt><code class="docutils literal"><span class="pre">returned</span></code></dt>
<dd>This indicates that the function always returns the argument as its return
value. This is an optimization hint to the code generator when generating
the caller, allowing tail call optimization and omission of register saves
and restores in some cases; it is not checked or enforced when generating
the callee. The parameter and the function return type must be valid
operands for the <a class="reference internal" href="#i-bitcast"><span class="std std-ref">bitcast instruction</span></a>. This is not a
valid attribute for return values and can only be applied to one parameter.</dd>
<dt><code class="docutils literal"><span class="pre">nonnull</span></code></dt>
<dd>This indicates that the parameter or return pointer is not null. This
attribute may only be applied to pointer typed parameters. This is not
checked or enforced by LLVM, the caller must ensure that the pointer
passed in is non-null, or the callee must ensure that the returned pointer
is non-null.</dd>
<dt><code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code></dt>
<dd>This indicates that the parameter or return pointer is dereferenceable. This
attribute may only be applied to pointer typed parameters. A pointer that
is dereferenceable can be loaded from speculatively without a risk of
trapping. The number of bytes known to be dereferenceable must be provided
in parentheses. It is legal for the number of bytes to be less than the
size of the pointee type. The <code class="docutils literal"><span class="pre">nonnull</span></code> attribute does not imply
dereferenceability (consider a pointer to one element past the end of an
array), however <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code> does imply <code class="docutils literal"><span class="pre">nonnull</span></code> in
<code class="docutils literal"><span class="pre">addrspace(0)</span></code> (which is the default address space).</dd>
<dt><code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code></dt>
<dd>This indicates that the parameter or return value isn&#8217;t both
non-null and non-dereferenceable (up to <code class="docutils literal"><span class="pre">&lt;n&gt;</span></code> bytes) at the same
time. All non-null pointers tagged with
<code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code> are <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code>.
For address space 0 <code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code> implies that
a pointer is exactly one of <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code> or <code class="docutils literal"><span class="pre">null</span></code>,
and in other address spaces <code class="docutils literal"><span class="pre">dereferenceable_or_null(&lt;n&gt;)</span></code>
implies that a pointer is at least one of <code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code>
or <code class="docutils literal"><span class="pre">null</span></code> (i.e. it may be both <code class="docutils literal"><span class="pre">null</span></code> and
<code class="docutils literal"><span class="pre">dereferenceable(&lt;n&gt;)</span></code>). This attribute may only be applied to
pointer typed parameters.</dd>
</dl>
</div>
<div class="section" id="garbage-collector-strategy-names">
<span id="gc"></span><h3><a class="toc-backref" href="#id670">Garbage Collector Strategy Names</a><a class="headerlink" href="#garbage-collector-strategy-names" title="永久链接至标题">¶</a></h3>
<p>Each function may specify a garbage collector strategy name, which is simply a
string:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">gc</span> <span class="s">&quot;name&quot;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>The supported values of <em>name</em> includes those <a class="reference internal" href="GarbageCollection.html#builtin-gc-strategies"><span class="std std-ref">built in to LLVM</span></a> and any provided by loaded plugins. Specifying a GC
strategy will cause the compiler to alter its output in order to support the
named garbage collection algorithm. Note that LLVM itself does not contain a
garbage collector, this functionality is restricted to generating machine code
which can interoperate with a collector provided externally.</p>
</div>
<div class="section" id="prefix-data">
<span id="prefixdata"></span><h3><a class="toc-backref" href="#id671">Prefix Data</a><a class="headerlink" href="#prefix-data" title="永久链接至标题">¶</a></h3>
<p>Prefix data is data associated with a function which the code
generator will emit immediately before the function&#8217;s entrypoint.
The purpose of this feature is to allow frontends to associate
language-specific runtime metadata with specific functions and make it
available through the function pointer while still allowing the
function pointer to be called.</p>
<p>To access the data for a given function, a program may bitcast the
function pointer to a pointer to the constant&#8217;s type and dereference
index -1. This implies that the IR symbol points just past the end of
the prefix data. For instance, take the example of a function annotated
with a single <code class="docutils literal"><span class="pre">i32</span></code>,</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">prefix</span> <span class="k">i32</span> <span class="m">123</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>The prefix data can be referenced as,</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">void</span><span class="p">*</span> <span class="p">()</span> <span class="vg">@f</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>
<span class="nv">%a</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">-1</span>
<span class="nv">%b</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%a</span>
</pre></div>
</div>
<p>Prefix data is laid out as if it were an initializer for a global variable
of the prefix data&#8217;s type. The function will be placed such that the
beginning of the prefix data is aligned. This means that if the size
of the prefix data is not a multiple of the alignment size, the
function&#8217;s entrypoint will not be aligned. If alignment of the
function&#8217;s entrypoint is desired, padding must be added to the prefix
data.</p>
<p>A function may have prefix data but no body. This has similar semantics
to the <code class="docutils literal"><span class="pre">available_externally</span></code> linkage in that the data may be used by the
optimizers but will not be emitted in the object file.</p>
</div>
<div class="section" id="prologue-data">
<span id="prologuedata"></span><h3><a class="toc-backref" href="#id672">Prologue Data</a><a class="headerlink" href="#prologue-data" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">prologue</span></code> attribute allows arbitrary code (encoded as bytes) to
be inserted prior to the function body. This can be used for enabling
function hot-patching and instrumentation.</p>
<p>To maintain the semantics of ordinary function calls, the prologue data must
have a particular format. Specifically, it must begin with a sequence of
bytes which decode to a sequence of machine instructions, valid for the
module&#8217;s target, which transfer control to the point immediately succeeding
the prologue data, without performing any other visible action. This allows
the inliner and other passes to reason about the semantics of the function
definition without needing to reason about the prologue data. Obviously this
makes the format of the prologue data highly target dependent.</p>
<p>A trivial example of valid prologue data for the x86 architecture is <code class="docutils literal"><span class="pre">i8</span> <span class="pre">144</span></code>,
which encodes the <code class="docutils literal"><span class="pre">nop</span></code> instruction:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>define void @f() prologue i8 144 { ... }
</pre></div>
</div>
<p>Generally prologue data can be formed by encoding a relative branch instruction
which skips the metadata, as in this example of valid prologue data for the
x86_64 architecture, where the first two bytes encode <code class="docutils literal"><span class="pre">jmp</span> <span class="pre">.+10</span></code>:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>%0 = type &lt;{ i8, i8, i8* }&gt;

define void @f() prologue %0 &lt;{ i8 235, i8 8, i8* @md}&gt; { ... }
</pre></div>
</div>
<p>A function may have prologue data but no body. This has similar semantics
to the <code class="docutils literal"><span class="pre">available_externally</span></code> linkage in that the data may be used by the
optimizers but will not be emitted in the object file.</p>
</div>
<div class="section" id="personality-function">
<span id="personalityfn"></span><h3><a class="toc-backref" href="#id673">Personality Function</a><a class="headerlink" href="#personality-function" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">personality</span></code> attribute permits functions to specify what function
to use for exception handling.</p>
</div>
<div class="section" id="attribute-groups">
<span id="attrgrp"></span><h3><a class="toc-backref" href="#id674">Attribute Groups</a><a class="headerlink" href="#attribute-groups" title="永久链接至标题">¶</a></h3>
<p>Attribute groups are groups of attributes that are referenced by objects within
the IR. They are important for keeping <code class="docutils literal"><span class="pre">.ll</span></code> files readable, because a lot of
functions will use the same set of attributes. In the degenerative case of a
<code class="docutils literal"><span class="pre">.ll</span></code> file that corresponds to a single <code class="docutils literal"><span class="pre">.c</span></code> file, the single attribute
group will capture the important command line flags used to build that file.</p>
<p>An attribute group is a module-level object. To use an attribute group, an
object references the attribute group&#8217;s ID (e.g. <code class="docutils literal"><span class="pre">#37</span></code>). An object may refer
to more than one attribute group. In that situation, the attributes from the
different groups are merged.</p>
<p>Here is an example of attribute groups for a function that should always be
inlined, has a stack alignment of 4, and which shouldn&#8217;t use SSE instructions:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Target-independent attributes:</span>
<span class="k">attributes</span> <span class="vg">#0</span> <span class="p">=</span> <span class="p">{</span> <span class="k">alwaysinline</span> <span class="k">alignstack</span><span class="p">=</span><span class="m">4</span> <span class="p">}</span>

<span class="c">; Target-dependent attributes:</span>
<span class="k">attributes</span> <span class="vg">#1</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;no-sse&quot;</span> <span class="p">}</span>

<span class="c">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="vg">#0</span> <span class="vg">#1</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-attributes">
<span id="fnattrs"></span><h3><a class="toc-backref" href="#id675">Function Attributes</a><a class="headerlink" href="#function-attributes" title="永久链接至标题">¶</a></h3>
<p>Function attributes are set to communicate additional information about
a function. Function attributes are considered to be part of the
function, not of the function type, so functions with different function
attributes can have the same function type.</p>
<p>Function attributes are simple keywords that follow the type specified.
If multiple attributes are needed, they are space separated. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">noinline</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">alwaysinline</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">alwaysinline</span> <span class="k">optsize</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="k">optsize</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">alignstack(&lt;n&gt;)</span></code></dt>
<dd>This attribute indicates that, when emitting the prologue and
epilogue, the backend should forcibly align the stack pointer.
Specify the desired alignment, which must be a power of two, in
parentheses.</dd>
<dt><code class="docutils literal"><span class="pre">alwaysinline</span></code></dt>
<dd>This attribute indicates that the inliner should attempt to inline
this function into callers whenever possible, ignoring any active
inlining size threshold for this caller.</dd>
<dt><code class="docutils literal"><span class="pre">builtin</span></code></dt>
<dd>This indicates that the callee function at a call site should be
recognized as a built-in function, even though the function&#8217;s declaration
uses the <code class="docutils literal"><span class="pre">nobuiltin</span></code> attribute. This is only valid at call sites for
direct calls to functions that are declared with the <code class="docutils literal"><span class="pre">nobuiltin</span></code>
attribute.</dd>
<dt><code class="docutils literal"><span class="pre">cold</span></code></dt>
<dd>This attribute indicates that this function is rarely called. When
computing edge weights, basic blocks post-dominated by a cold
function call are also considered to be cold; and, thus, given low
weight.</dd>
<dt><code class="docutils literal"><span class="pre">convergent</span></code></dt>
<dd>This attribute indicates that the callee is dependent on a convergent
thread execution pattern under certain parallel execution models.
Transformations that are execution model agnostic may not make the execution
of a convergent operation control dependent on any additional values.</dd>
<dt><code class="docutils literal"><span class="pre">inaccessiblememonly</span></code></dt>
<dd>This attribute indicates that the function may only access memory that
is not accessible by the module being compiled. This is a weaker form
of <code class="docutils literal"><span class="pre">readnone</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">inaccessiblemem_or_argmemonly</span></code></dt>
<dd>This attribute indicates that the function may only access memory that is
either not accessible by the module being compiled, or is pointed to
by its pointer arguments. This is a weaker form of  <code class="docutils literal"><span class="pre">argmemonly</span></code></dd>
<dt><code class="docutils literal"><span class="pre">inlinehint</span></code></dt>
<dd>This attribute indicates that the source code contained a hint that
inlining this function is desirable (such as the &#8220;inline&#8221; keyword in
C/C++). It is just a hint; it imposes no requirements on the
inliner.</dd>
<dt><code class="docutils literal"><span class="pre">jumptable</span></code></dt>
<dd>This attribute indicates that the function should be added to a
jump-instruction table at code-generation time, and that all address-taken
references to this function should be replaced with a reference to the
appropriate jump-instruction-table function pointer. Note that this creates
a new pointer for the original function, which means that code that depends
on function-pointer identity can break. So, any function annotated with
<code class="docutils literal"><span class="pre">jumptable</span></code> must also be <code class="docutils literal"><span class="pre">unnamed_addr</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">minsize</span></code></dt>
<dd>This attribute suggests that optimization passes and code generator
passes make choices that keep the code size of this function as small
as possible and perform optimizations that may sacrifice runtime
performance in order to minimize the size of the generated code.</dd>
<dt><code class="docutils literal"><span class="pre">naked</span></code></dt>
<dd>This attribute disables prologue / epilogue emission for the
function. This can have very system-specific consequences.</dd>
<dt><code class="docutils literal"><span class="pre">nobuiltin</span></code></dt>
<dd>This indicates that the callee function at a call site is not recognized as
a built-in function. LLVM will retain the original call and not replace it
with equivalent code based on the semantics of the built-in function, unless
the call site uses the <code class="docutils literal"><span class="pre">builtin</span></code> attribute. This is valid at call sites
and on function declarations and definitions.</dd>
<dt><code class="docutils literal"><span class="pre">noduplicate</span></code></dt>
<dd><p class="first">This attribute indicates that calls to the function cannot be
duplicated. A call to a <code class="docutils literal"><span class="pre">noduplicate</span></code> function may be moved
within its parent function, but may not be duplicated within
its parent function.</p>
<p class="last">A function containing a <code class="docutils literal"><span class="pre">noduplicate</span></code> call may still
be an inlining candidate, provided that the call is not
duplicated by inlining. That implies that the function has
internal linkage and only has one call site, so the original
call is dead after inlining.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">noimplicitfloat</span></code></dt>
<dd>This attributes disables implicit floating point instructions.</dd>
<dt><code class="docutils literal"><span class="pre">noinline</span></code></dt>
<dd>This attribute indicates that the inliner should never inline this
function in any situation. This attribute may not be used together
with the <code class="docutils literal"><span class="pre">alwaysinline</span></code> attribute.</dd>
<dt><code class="docutils literal"><span class="pre">nonlazybind</span></code></dt>
<dd>This attribute suppresses lazy symbol binding for the function. This
may make calls to the function faster, at the cost of extra program
startup time if the function is not called during program startup.</dd>
<dt><code class="docutils literal"><span class="pre">noredzone</span></code></dt>
<dd>This attribute indicates that the code generator should not use a
red zone, even if the target-specific ABI normally permits it.</dd>
<dt><code class="docutils literal"><span class="pre">noreturn</span></code></dt>
<dd>This function attribute indicates that the function never returns
normally. This produces undefined behavior at runtime if the
function ever does dynamically return.</dd>
<dt><code class="docutils literal"><span class="pre">norecurse</span></code></dt>
<dd>This function attribute indicates that the function does not call itself
either directly or indirectly down any possible call path. This produces
undefined behavior at runtime if the function ever does recurse.</dd>
<dt><code class="docutils literal"><span class="pre">nounwind</span></code></dt>
<dd>This function attribute indicates that the function never raises an
exception. If the function does raise an exception, its runtime
behavior is undefined. However, functions marked nounwind may still
trap or generate asynchronous exceptions. Exception handling schemes
that are recognized by LLVM to handle asynchronous exceptions, such
as SEH, will still provide their implementation defined semantics.</dd>
<dt><code class="docutils literal"><span class="pre">optnone</span></code></dt>
<dd><p class="first">This function attribute indicates that most optimization passes will skip
this function, with the exception of interprocedural optimization passes.
Code generation defaults to the &#8220;fast&#8221; instruction selector.
This attribute cannot be used together with the <code class="docutils literal"><span class="pre">alwaysinline</span></code>
attribute; this attribute is also incompatible
with the <code class="docutils literal"><span class="pre">minsize</span></code> attribute and the <code class="docutils literal"><span class="pre">optsize</span></code> attribute.</p>
<p class="last">This attribute requires the <code class="docutils literal"><span class="pre">noinline</span></code> attribute to be specified on
the function as well, so the function is never inlined into any caller.
Only functions with the <code class="docutils literal"><span class="pre">alwaysinline</span></code> attribute are valid
candidates for inlining into the body of this function.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">optsize</span></code></dt>
<dd>This attribute suggests that optimization passes and code generator
passes make choices that keep the code size of this function low,
and otherwise do optimizations specifically to reduce code size as
long as they do not significantly impact runtime performance.</dd>
<dt><code class="docutils literal"><span class="pre">readnone</span></code></dt>
<dd><p class="first">On a function, this attribute indicates that the function computes its
result (or decides to unwind an exception) based strictly on its arguments,
without dereferencing any pointer arguments or otherwise accessing
any mutable state (e.g. memory, control registers, etc) visible to
caller functions. It does not write through any pointer arguments
(including <code class="docutils literal"><span class="pre">byval</span></code> arguments) and never changes any state visible
to callers. This means that it cannot unwind exceptions by calling
the <code class="docutils literal"><span class="pre">C++</span></code> exception throwing methods.</p>
<p class="last">On an argument, this attribute indicates that the function does not
dereference that pointer argument, even though it may read or write the
memory that the pointer points to if accessed through other pointers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">readonly</span></code></dt>
<dd><p class="first">On a function, this attribute indicates that the function does not write
through any pointer arguments (including <code class="docutils literal"><span class="pre">byval</span></code> arguments) or otherwise
modify any state (e.g. memory, control registers, etc) visible to
caller functions. It may dereference pointer arguments and read
state that may be set in the caller. A readonly function always
returns the same value (or unwinds an exception identically) when
called with the same set of arguments and global state. It cannot
unwind an exception by calling the <code class="docutils literal"><span class="pre">C++</span></code> exception throwing
methods.</p>
<p class="last">On an argument, this attribute indicates that the function does not write
through this pointer argument, even though it may write to the memory that
the pointer points to.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">argmemonly</span></code></dt>
<dd>This attribute indicates that the only memory accesses inside function are
loads and stores from objects pointed to by its pointer-typed arguments,
with arbitrary offsets. Or in other words, all memory operations in the
function can refer to memory only using pointers based on its function
arguments.
Note that <code class="docutils literal"><span class="pre">argmemonly</span></code> can be used together with <code class="docutils literal"><span class="pre">readonly</span></code> attribute
in order to specify that function reads only from its arguments.</dd>
<dt><code class="docutils literal"><span class="pre">returns_twice</span></code></dt>
<dd>This attribute indicates that this function can return twice. The C
<code class="docutils literal"><span class="pre">setjmp</span></code> is an example of such a function. The compiler disables
some optimizations (like tail calls) in the caller of these
functions.</dd>
<dt><code class="docutils literal"><span class="pre">safestack</span></code></dt>
<dd><p class="first">This attribute indicates that
<a class="reference external" href="http://clang.llvm.org/docs/SafeStack.html">SafeStack</a>
protection is enabled for this function.</p>
<p class="last">If a function that has a <code class="docutils literal"><span class="pre">safestack</span></code> attribute is inlined into a
function that doesn&#8217;t have a <code class="docutils literal"><span class="pre">safestack</span></code> attribute or which has an
<code class="docutils literal"><span class="pre">ssp</span></code>, <code class="docutils literal"><span class="pre">sspstrong</span></code> or <code class="docutils literal"><span class="pre">sspreq</span></code> attribute, then the resulting
function will have a <code class="docutils literal"><span class="pre">safestack</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">sanitize_address</span></code></dt>
<dd>This attribute indicates that AddressSanitizer checks
(dynamic address safety analysis) are enabled for this function.</dd>
<dt><code class="docutils literal"><span class="pre">sanitize_memory</span></code></dt>
<dd>This attribute indicates that MemorySanitizer checks (dynamic detection
of accesses to uninitialized memory) are enabled for this function.</dd>
<dt><code class="docutils literal"><span class="pre">sanitize_thread</span></code></dt>
<dd>This attribute indicates that ThreadSanitizer checks
(dynamic thread safety analysis) are enabled for this function.</dd>
<dt><code class="docutils literal"><span class="pre">ssp</span></code></dt>
<dd><p class="first">This attribute indicates that the function should emit a stack
smashing protector. It is in the form of a &#8220;canary&#8221; &#8212; a random value
placed on the stack before the local variables that&#8217;s checked upon
return from the function to see if it has been overwritten. A
heuristic is used to determine if a function needs stack protectors
or not. The heuristic used will enable protectors for functions with:</p>
<ul class="simple">
<li>Character arrays larger than <code class="docutils literal"><span class="pre">ssp-buffer-size</span></code> (default 8).</li>
<li>Aggregates containing character arrays larger than <code class="docutils literal"><span class="pre">ssp-buffer-size</span></code>.</li>
<li>Calls to alloca() with variable sizes or constant sizes greater than
<code class="docutils literal"><span class="pre">ssp-buffer-size</span></code>.</li>
</ul>
<p>Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.</p>
<p class="last">If a function that has an <code class="docutils literal"><span class="pre">ssp</span></code> attribute is inlined into a
function that doesn&#8217;t have an <code class="docutils literal"><span class="pre">ssp</span></code> attribute, then the resulting
function will have an <code class="docutils literal"><span class="pre">ssp</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">sspreq</span></code></dt>
<dd><p class="first">This attribute indicates that the function should <em>always</em> emit a
stack smashing protector. This overrides the <code class="docutils literal"><span class="pre">ssp</span></code> function
attribute.</p>
<p>Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
The specific layout rules are:</p>
<ol class="arabic simple">
<li>Large arrays and structures containing large arrays
(<code class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">ssp-buffer-size</span></code>) are closest to the stack protector.</li>
<li>Small arrays and structures containing small arrays
(<code class="docutils literal"><span class="pre">&lt;</span> <span class="pre">ssp-buffer-size</span></code>) are 2nd closest to the protector.</li>
<li>Variables that have had their address taken are 3rd closest to the
protector.</li>
</ol>
<p class="last">If a function that has an <code class="docutils literal"><span class="pre">sspreq</span></code> attribute is inlined into a
function that doesn&#8217;t have an <code class="docutils literal"><span class="pre">sspreq</span></code> attribute or which has an
<code class="docutils literal"><span class="pre">ssp</span></code> or <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute, then the resulting function will have
an <code class="docutils literal"><span class="pre">sspreq</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">sspstrong</span></code></dt>
<dd><p class="first">This attribute indicates that the function should emit a stack smashing
protector. This attribute causes a strong heuristic to be used when
determining if a function needs stack protectors. The strong heuristic
will enable protectors for functions with:</p>
<ul class="simple">
<li>Arrays of any size and type</li>
<li>Aggregates containing an array of any size and type.</li>
<li>Calls to alloca().</li>
<li>Local variables that have had their address taken.</li>
</ul>
<p>Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
The specific layout rules are:</p>
<ol class="arabic simple">
<li>Large arrays and structures containing large arrays
(<code class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">ssp-buffer-size</span></code>) are closest to the stack protector.</li>
<li>Small arrays and structures containing small arrays
(<code class="docutils literal"><span class="pre">&lt;</span> <span class="pre">ssp-buffer-size</span></code>) are 2nd closest to the protector.</li>
<li>Variables that have had their address taken are 3rd closest to the
protector.</li>
</ol>
<p>This overrides the <code class="docutils literal"><span class="pre">ssp</span></code> function attribute.</p>
<p class="last">If a function that has an <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute is inlined into a
function that doesn&#8217;t have an <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute, then the
resulting function will have an <code class="docutils literal"><span class="pre">sspstrong</span></code> attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">&quot;thunk&quot;</span></code></dt>
<dd>This attribute indicates that the function will delegate to some other
function with a tail call. The prototype of a thunk should not be used for
optimization purposes. The caller is expected to cast the thunk prototype to
match the thunk target prototype.</dd>
<dt><code class="docutils literal"><span class="pre">uwtable</span></code></dt>
<dd>This attribute indicates that the ABI being targeted requires that
an unwind table entry be produced for this function even if we can
show that no exceptions passes by it. This is normally the case for
the ELF x86-64 abi, but it can be disabled for some compilation
units.</dd>
</dl>
</div>
<div class="section" id="operand-bundles">
<span id="opbundles"></span><h3><a class="toc-backref" href="#id676">Operand Bundles</a><a class="headerlink" href="#operand-bundles" title="永久链接至标题">¶</a></h3>
<p>Note: operand bundles are a work in progress, and they should be
considered experimental at this time.</p>
<p>Operand bundles are tagged sets of SSA values that can be associated
with certain LLVM instructions (currently only <code class="docutils literal"><span class="pre">call</span></code> s and
<code class="docutils literal"><span class="pre">invoke</span></code> s).  In a way they are like metadata, but dropping them is
incorrect and will change program semantics.</p>
<p>Syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">operand</span> <span class="n">bundle</span> <span class="nb">set</span> <span class="p">::</span><span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="n">operand</span> <span class="n">bundle</span> <span class="p">(,</span> <span class="n">operand</span> <span class="n">bundle</span> <span class="p">)</span><span class="o">*</span> <span class="s1">&#39;]&#39;</span>
<span class="n">operand</span> <span class="n">bundle</span> <span class="p">::</span><span class="o">=</span> <span class="n">tag</span> <span class="s1">&#39;(&#39;</span> <span class="p">[</span> <span class="n">bundle</span> <span class="n">operand</span> <span class="p">]</span> <span class="p">(,</span> <span class="n">bundle</span> <span class="n">operand</span> <span class="p">)</span><span class="o">*</span> <span class="s1">&#39;)&#39;</span>
<span class="n">bundle</span> <span class="n">operand</span> <span class="p">::</span><span class="o">=</span> <span class="n">SSA</span> <span class="n">value</span>
<span class="n">tag</span> <span class="p">::</span><span class="o">=</span> <span class="n">string</span> <span class="n">constant</span>
</pre></div>
</div>
<p>Operand bundles are <strong>not</strong> part of a function&#8217;s signature, and a
given function may be called from multiple places with different kinds
of operand bundles.  This reflects the fact that the operand bundles
are conceptually a part of the <code class="docutils literal"><span class="pre">call</span></code> (or <code class="docutils literal"><span class="pre">invoke</span></code>), not the
callee being dispatched to.</p>
<p>Operand bundles are a generic mechanism intended to support
runtime-introspection-like functionality for managed languages.  While
the exact semantics of an operand bundle depend on the bundle tag,
there are certain limitations to how much the presence of an operand
bundle can influence the semantics of a program.  These restrictions
are described as the semantics of an &#8220;unknown&#8221; operand bundle.  As
long as the behavior of an operand bundle is describable within these
restrictions, LLVM does not need to have special knowledge of the
operand bundle to not miscompile programs containing it.</p>
<ul class="simple">
<li>The bundle operands for an unknown operand bundle escape in unknown
ways before control is transferred to the callee or invokee.</li>
<li>Calls and invokes with operand bundles have unknown read / write
effect on the heap on entry and exit (even if the call target is
<code class="docutils literal"><span class="pre">readnone</span></code> or <code class="docutils literal"><span class="pre">readonly</span></code>), unless they&#8217;re overriden with
callsite specific attributes.</li>
<li>An operand bundle at a call site cannot change the implementation
of the called function.  Inter-procedural optimizations work as
usual as long as they take into account the first two properties.</li>
</ul>
<p>More specific types of operand bundles are described below.</p>
<div class="section" id="deoptimization-operand-bundles">
<h4><a class="toc-backref" href="#id677">Deoptimization Operand Bundles</a><a class="headerlink" href="#deoptimization-operand-bundles" title="永久链接至标题">¶</a></h4>
<p>Deoptimization operand bundles are characterized by the <code class="docutils literal"><span class="pre">&quot;deopt&quot;</span></code>
operand bundle tag.  These operand bundles represent an alternate
&#8220;safe&#8221; continuation for the call site they&#8217;re attached to, and can be
used by a suitable runtime to deoptimize the compiled frame at the
specified call site.  There can be at most one <code class="docutils literal"><span class="pre">&quot;deopt&quot;</span></code> operand
bundle attached to a call site.  Exact details of deoptimization is
out of scope for the language reference, but it usually involves
rewriting a compiled frame into a set of interpreted frames.</p>
<p>From the compiler&#8217;s perspective, deoptimization operand bundles make
the call sites they&#8217;re attached to at least <code class="docutils literal"><span class="pre">readonly</span></code>.  They read
through all of their pointer typed operands (even if they&#8217;re not
otherwise escaped) and the entire visible heap.  Deoptimization
operand bundles do not capture their operands except during
deoptimization, in which case control will not be returned to the
compiled frame.</p>
<p>The inliner knows how to inline through calls that have deoptimization
operand bundles.  Just like inlining through a normal call site
involves composing the normal and exceptional continuations, inlining
through a call site with a deoptimization operand bundle needs to
appropriately compose the &#8220;safe&#8221; deoptimization continuation.  The
inliner does this by prepending the parent&#8217;s deoptimization
continuation to every deoptimization continuation in the inlined body.
E.g. inlining <code class="docutils literal"><span class="pre">&#64;f</span></code> into <code class="docutils literal"><span class="pre">&#64;g</span></code> in the following example</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@x</span><span class="p">()</span>  <span class="c">;; no deopt state</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">),</span> <span class="s">&quot;unknown&quot;</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@f</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">20</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will result in</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@x</span><span class="p">()</span>  <span class="c">;; still no deopt state</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">20</span><span class="p">,</span> <span class="k">i32</span> <span class="m">10</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@y</span><span class="p">()</span> <span class="p">[</span> <span class="s">&quot;deopt&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="m">20</span><span class="p">,</span> <span class="k">i32</span> <span class="m">10</span><span class="p">),</span> <span class="s">&quot;unknown&quot;</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is the frontend&#8217;s responsibility to structure or encode the
deoptimization state in a way that syntactically prepending the
caller&#8217;s deoptimization state to the callee&#8217;s deoptimization state is
semantically equivalent to composing the caller&#8217;s deoptimization
continuation after the callee&#8217;s deoptimization continuation.</p>
</div>
<div class="section" id="funclet-operand-bundles">
<span id="ob-funclet"></span><h4><a class="toc-backref" href="#id678">Funclet Operand Bundles</a><a class="headerlink" href="#funclet-operand-bundles" title="永久链接至标题">¶</a></h4>
<p>Funclet operand bundles are characterized by the <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code>
operand bundle tag.  These operand bundles indicate that a call site
is within a particular funclet.  There can be at most one
<code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> operand bundle attached to a call site and it must have
exactly one bundle operand.</p>
<p>If any funclet EH pads have been &#8220;entered&#8221; but not &#8220;exited&#8221; (per the
<a class="reference external" href="ExceptionHandling.html#wineh-constraints">description in the EH doc</a>),
it is undefined behavior to execute a <code class="docutils literal"><span class="pre">call</span></code> or <code class="docutils literal"><span class="pre">invoke</span></code> which:</p>
<ul class="simple">
<li>does not have a <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> bundle and is not a <code class="docutils literal"><span class="pre">call</span></code> to a nounwind
intrinsic, or</li>
<li>has a <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> bundle whose operand is not the most-recently-entered
not-yet-exited funclet EH pad.</li>
</ul>
<p>Similarly, if no funclet EH pads have been entered-but-not-yet-exited,
executing a <code class="docutils literal"><span class="pre">call</span></code> or <code class="docutils literal"><span class="pre">invoke</span></code> with a <code class="docutils literal"><span class="pre">&quot;funclet&quot;</span></code> bundle is undefined behavior.</p>
</div>
</div>
<div class="section" id="module-level-inline-assembly">
<span id="moduleasm"></span><h3><a class="toc-backref" href="#id679">Module-Level Inline Assembly</a><a class="headerlink" href="#module-level-inline-assembly" title="永久链接至标题">¶</a></h3>
<p>Modules may contain &#8220;module-level inline asm&#8221; blocks, which corresponds
to the GCC &#8220;file scope inline asm&#8221; blocks. These blocks are internally
concatenated by LLVM and treated as a single unit, but may be separated
in the <code class="docutils literal"><span class="pre">.ll</span></code> file if desired. The syntax is very simple:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="k">asm</span> <span class="s">&quot;inline asm code goes here&quot;</span>
<span class="k">module</span> <span class="k">asm</span> <span class="s">&quot;more can go here&quot;</span>
</pre></div>
</div>
<p>The strings can contain any character by escaping non-printable
characters. The escape sequence used is simply &#8220;\xx&#8221; where &#8220;xx&#8221; is the
two digit hex code for the number.</p>
<p>Note that the assembly string <em>must</em> be parseable by LLVM&#8217;s integrated assembler
(unless it is disabled), even when emitting a <code class="docutils literal"><span class="pre">.s</span></code> file.</p>
</div>
<div class="section" id="data-layout">
<span id="langref-datalayout"></span><h3><a class="toc-backref" href="#id680">Data Layout</a><a class="headerlink" href="#data-layout" title="永久链接至标题">¶</a></h3>
<p>A module may specify a target specific data layout string that specifies
how data is to be laid out in memory. The syntax for the data layout is
simply:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">target</span> <span class="k">datalayout</span> <span class="p">=</span> <span class="s">&quot;layout specification&quot;</span>
</pre></div>
</div>
<p>The <em>layout specification</em> consists of a list of specifications
separated by the minus sign character (&#8216;-&#8216;). Each specification starts
with a letter and may include other information after the letter to
define some aspect of the data layout. The specifications accepted are
as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">E</span></code></dt>
<dd>Specifies that the target lays out data in big-endian form. That is,
the bits with the most significance have the lowest address
location.</dd>
<dt><code class="docutils literal"><span class="pre">e</span></code></dt>
<dd>Specifies that the target lays out data in little-endian form. That
is, the bits with the least significance have the lowest address
location.</dd>
<dt><code class="docutils literal"><span class="pre">S&lt;size&gt;</span></code></dt>
<dd>Specifies the natural alignment of the stack in bits. Alignment
promotion of stack variables is limited to the natural stack
alignment to avoid dynamic stack realignment. The stack alignment
must be a multiple of 8-bits. If omitted, the natural stack
alignment defaults to &#8220;unspecified&#8221;, which does not prevent any
alignment promotions.</dd>
<dt><code class="docutils literal"><span class="pre">p[n]:&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the <em>size</em> of a pointer and its <code class="docutils literal"><span class="pre">&lt;abi&gt;</span></code> and
<code class="docutils literal"><span class="pre">&lt;pref&gt;</span></code>erred alignments for address space <code class="docutils literal"><span class="pre">n</span></code>. All sizes are in
bits. The address space, <code class="docutils literal"><span class="pre">n</span></code>, is optional, and if not specified,
denotes the default address space 0. The value of <code class="docutils literal"><span class="pre">n</span></code> must be
in the range [1,2^23).</dd>
<dt><code class="docutils literal"><span class="pre">i&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for an integer type of a given bit
<code class="docutils literal"><span class="pre">&lt;size&gt;</span></code>. The value of <code class="docutils literal"><span class="pre">&lt;size&gt;</span></code> must be in the range [1,2^23).</dd>
<dt><code class="docutils literal"><span class="pre">v&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for a vector type of a given bit
<code class="docutils literal"><span class="pre">&lt;size&gt;</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">f&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for a floating point type of a given bit
<code class="docutils literal"><span class="pre">&lt;size&gt;</span></code>. Only values of <code class="docutils literal"><span class="pre">&lt;size&gt;</span></code> that are supported by the target
will work. 32 (float) and 64 (double) are supported on all targets; 80
or 128 (different flavors of long double) are also supported on some
targets.</dd>
<dt><code class="docutils literal"><span class="pre">a:&lt;abi&gt;:&lt;pref&gt;</span></code></dt>
<dd>This specifies the alignment for an object of aggregate type.</dd>
<dt><code class="docutils literal"><span class="pre">m:&lt;mangling&gt;</span></code></dt>
<dd><p class="first">If present, specifies that llvm names are mangled in the output. The
options are</p>
<ul class="last simple">
<li><code class="docutils literal"><span class="pre">e</span></code>: ELF mangling: Private symbols get a <code class="docutils literal"><span class="pre">.L</span></code> prefix.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: Mips mangling: Private symbols get a <code class="docutils literal"><span class="pre">$</span></code> prefix.</li>
<li><code class="docutils literal"><span class="pre">o</span></code>: Mach-O mangling: Private symbols get <code class="docutils literal"><span class="pre">L</span></code> prefix. Other
symbols get a <code class="docutils literal"><span class="pre">_</span></code> prefix.</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: Windows COFF prefix:  Similar to Mach-O, but stdcall and fastcall
functions also get a suffix based on the frame size.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Windows x86 COFF prefix:  Similar to Windows COFF, but use a <code class="docutils literal"><span class="pre">_</span></code>
prefix for <code class="docutils literal"><span class="pre">__cdecl</span></code> functions.</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</span></code></dt>
<dd>This specifies a set of native integer widths for the target CPU in
bits. For example, it might contain <code class="docutils literal"><span class="pre">n32</span></code> for 32-bit PowerPC,
<code class="docutils literal"><span class="pre">n32:64</span></code> for PowerPC 64, or <code class="docutils literal"><span class="pre">n8:16:32:64</span></code> for X86-64. Elements of
this set are considered to support most general arithmetic operations
efficiently.</dd>
</dl>
<p>On every specification that takes a <code class="docutils literal"><span class="pre">&lt;abi&gt;:&lt;pref&gt;</span></code>, specifying the
<code class="docutils literal"><span class="pre">&lt;pref&gt;</span></code> alignment is optional. If omitted, the preceding <code class="docutils literal"><span class="pre">:</span></code>
should be omitted too and <code class="docutils literal"><span class="pre">&lt;pref&gt;</span></code> will be equal to <code class="docutils literal"><span class="pre">&lt;abi&gt;</span></code>.</p>
<p>When constructing the data layout for a given target, LLVM starts with a
default set of specifications which are then (possibly) overridden by
the specifications in the <code class="docutils literal"><span class="pre">datalayout</span></code> keyword. The default
specifications are given in this list:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">E</span></code> - big endian</li>
<li><code class="docutils literal"><span class="pre">p:64:64:64</span></code> - 64-bit pointers with 64-bit alignment.</li>
<li><code class="docutils literal"><span class="pre">p[n]:64:64:64</span></code> - Other address spaces are assumed to be the
same as the default address space.</li>
<li><code class="docutils literal"><span class="pre">S0</span></code> - natural stack alignment is unspecified</li>
<li><code class="docutils literal"><span class="pre">i1:8:8</span></code> - i1 is 8-bit (byte) aligned</li>
<li><code class="docutils literal"><span class="pre">i8:8:8</span></code> - i8 is 8-bit (byte) aligned</li>
<li><code class="docutils literal"><span class="pre">i16:16:16</span></code> - i16 is 16-bit aligned</li>
<li><code class="docutils literal"><span class="pre">i32:32:32</span></code> - i32 is 32-bit aligned</li>
<li><code class="docutils literal"><span class="pre">i64:32:64</span></code> - i64 has ABI alignment of 32-bits but preferred
alignment of 64-bits</li>
<li><code class="docutils literal"><span class="pre">f16:16:16</span></code> - half is 16-bit aligned</li>
<li><code class="docutils literal"><span class="pre">f32:32:32</span></code> - float is 32-bit aligned</li>
<li><code class="docutils literal"><span class="pre">f64:64:64</span></code> - double is 64-bit aligned</li>
<li><code class="docutils literal"><span class="pre">f128:128:128</span></code> - quad is 128-bit aligned</li>
<li><code class="docutils literal"><span class="pre">v64:64:64</span></code> - 64-bit vector is 64-bit aligned</li>
<li><code class="docutils literal"><span class="pre">v128:128:128</span></code> - 128-bit vector is 128-bit aligned</li>
<li><code class="docutils literal"><span class="pre">a:0:64</span></code> - aggregates are 64-bit aligned</li>
</ul>
<p>When LLVM is determining the alignment for a given type, it uses the
following rules:</p>
<ol class="arabic simple">
<li>If the type sought is an exact match for one of the specifications,
that specification is used.</li>
<li>If no match is found, and the type sought is an integer type, then
the smallest integer type that is larger than the bitwidth of the
sought type is used. If none of the specifications are larger than
the bitwidth then the largest integer type is used. For example,
given the default specifications above, the i7 type will use the
alignment of i8 (next largest) while both i65 and i256 will use the
alignment of i64 (largest specified).</li>
<li>If no match is found, and the type sought is a vector type, then the
largest vector type that is smaller than the sought vector type will
be used as a fall back. This happens because &lt;128 x double&gt; can be
implemented in terms of 64 &lt;2 x double&gt;, for example.</li>
</ol>
<p>The function of the data layout string may not be what you expect.
Notably, this is not a specification from the frontend of what alignment
the code generator should use.</p>
<p>Instead, if specified, the target data layout is required to match what
the ultimate <em>code generator</em> expects. This string is used by the
mid-level optimizers to improve code, and this only works if it matches
what the ultimate code generator uses. There is no way to generate IR
that does not embed this target-specific detail into the IR. If you
don&#8217;t specify the string, the default specifications will be used to
generate a Data Layout and the optimization phases will operate
accordingly and introduce target specificity into the IR with respect to
these default specifications.</p>
</div>
<div class="section" id="target-triple">
<span id="langref-triple"></span><h3><a class="toc-backref" href="#id681">Target Triple</a><a class="headerlink" href="#target-triple" title="永久链接至标题">¶</a></h3>
<p>A module may specify a target triple string that describes the target
host. The syntax for the target triple is simply:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">target</span> <span class="k">triple</span> <span class="p">=</span> <span class="s">&quot;x86_64-apple-macosx10.7.0&quot;</span>
</pre></div>
</div>
<p>The <em>target triple</em> string consists of a series of identifiers delimited
by the minus sign character (&#8216;-&#8216;). The canonical forms are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ARCHITECTURE</span><span class="o">-</span><span class="n">VENDOR</span><span class="o">-</span><span class="n">OPERATING_SYSTEM</span>
<span class="n">ARCHITECTURE</span><span class="o">-</span><span class="n">VENDOR</span><span class="o">-</span><span class="n">OPERATING_SYSTEM</span><span class="o">-</span><span class="n">ENVIRONMENT</span>
</pre></div>
</div>
<p>This information is passed along to the backend so that it generates
code for the proper architecture. It&#8217;s possible to override this on the
command line with the <code class="docutils literal"><span class="pre">-mtriple</span></code> command line option.</p>
</div>
<div class="section" id="pointer-aliasing-rules">
<span id="pointeraliasing"></span><h3><a class="toc-backref" href="#id682">Pointer Aliasing Rules</a><a class="headerlink" href="#pointer-aliasing-rules" title="永久链接至标题">¶</a></h3>
<p>Any memory access must be done through a pointer value associated with
an address range of the memory access, otherwise the behavior is
undefined. Pointer values are associated with address ranges according
to the following rules:</p>
<ul class="simple">
<li>A pointer value is associated with the addresses associated with any
value it is <em>based</em> on.</li>
<li>An address of a global variable is associated with the address range
of the variable&#8217;s storage.</li>
<li>The result value of an allocation instruction is associated with the
address range of the allocated storage.</li>
<li>A null pointer in the default address-space is associated with no
address.</li>
<li>An integer constant other than zero or a pointer value returned from
a function not defined within LLVM may be associated with address
ranges allocated through mechanisms other than those provided by
LLVM. Such ranges shall not overlap with any ranges of addresses
allocated by mechanisms provided by LLVM.</li>
</ul>
<p>A pointer value is <em>based</em> on another pointer value according to the
following rules:</p>
<ul class="simple">
<li>A pointer value formed from a <code class="docutils literal"><span class="pre">getelementptr</span></code> operation is <em>based</em>
on the first value operand of the <code class="docutils literal"><span class="pre">getelementptr</span></code>.</li>
<li>The result value of a <code class="docutils literal"><span class="pre">bitcast</span></code> is <em>based</em> on the operand of the
<code class="docutils literal"><span class="pre">bitcast</span></code>.</li>
<li>A pointer value formed by an <code class="docutils literal"><span class="pre">inttoptr</span></code> is <em>based</em> on all pointer
values that contribute (directly or indirectly) to the computation of
the pointer&#8217;s value.</li>
<li>The &#8220;<em>based</em> on&#8221; relationship is transitive.</li>
</ul>
<p>Note that this definition of <em>&#8220;based&#8221;</em> is intentionally similar to the
definition of <em>&#8220;based&#8221;</em> in C99, though it is slightly weaker.</p>
<p>LLVM IR does not associate types with memory. The result type of a
<code class="docutils literal"><span class="pre">load</span></code> merely indicates the size and alignment of the memory from
which to load, as well as the interpretation of the value. The first
operand type of a <code class="docutils literal"><span class="pre">store</span></code> similarly only indicates the size and
alignment of the store.</p>
<p>Consequently, type-based alias analysis, aka TBAA, aka
<code class="docutils literal"><span class="pre">-fstrict-aliasing</span></code>, is not applicable to general unadorned LLVM IR.
<a class="reference internal" href="#metadata"><span class="std std-ref">Metadata</span></a> may be used to encode additional information
which specialized optimization passes may use to implement type-based
alias analysis.</p>
</div>
<div class="section" id="volatile-memory-accesses">
<span id="volatile"></span><h3><a class="toc-backref" href="#id683">Volatile Memory Accesses</a><a class="headerlink" href="#volatile-memory-accesses" title="永久链接至标题">¶</a></h3>
<p>Certain memory accesses, such as <a class="reference internal" href="#i-load"><span class="std std-ref">load</span></a>&#8216;s,
<a class="reference internal" href="#i-store"><span class="std std-ref">store</span></a>&#8216;s, and <a class="reference internal" href="#int-memcpy"><span class="std std-ref">llvm.memcpy</span></a>&#8216;s may be
marked <code class="docutils literal"><span class="pre">volatile</span></code>. The optimizers must not change the number of
volatile operations or change their order of execution relative to other
volatile operations. The optimizers <em>may</em> change the order of volatile
operations relative to non-volatile operations. This is not Java&#8217;s
&#8220;volatile&#8221; and has no cross-thread synchronization behavior.</p>
<p>IR-level volatile loads and stores cannot safely be optimized into
llvm.memcpy or llvm.memmove intrinsics even when those intrinsics are
flagged volatile. Likewise, the backend should never split or merge
target-legal volatile load/store instructions.</p>
<div class="admonition-rationale admonition">
<p class="first admonition-title">Rationale</p>
<p class="last">Platforms may rely on volatile loads and stores of natively supported
data width to be executed as single instruction. For example, in C
this holds for an l-value of volatile primitive type with native
hardware support, but not necessarily for aggregate types. The
frontend upholds these expectations, which are intentionally
unspecified in the IR. The rules above ensure that IR transformations
do not violate the frontend&#8217;s contract with the language.</p>
</div>
</div>
<div class="section" id="memory-model-for-concurrent-operations">
<span id="memmodel"></span><h3><a class="toc-backref" href="#id684">Memory Model for Concurrent Operations</a><a class="headerlink" href="#memory-model-for-concurrent-operations" title="永久链接至标题">¶</a></h3>
<p>The LLVM IR does not define any way to start parallel threads of
execution or to register signal handlers. Nonetheless, there are
platform-specific ways to create them, and we define LLVM IR&#8217;s behavior
in their presence. This model is inspired by the C++0x memory model.</p>
<p>For a more informal introduction to this model, see the <a class="reference internal" href="Atomics.html"><span class="doc">LLVM Atomic Instructions and Concurrency Guide</span></a>.</p>
<p>We define a <em>happens-before</em> partial order as the least partial order
that</p>
<ul class="simple">
<li>Is a superset of single-thread program order, and</li>
<li>When a <em>synchronizes-with</em> <code class="docutils literal"><span class="pre">b</span></code>, includes an edge from <code class="docutils literal"><span class="pre">a</span></code> to
<code class="docutils literal"><span class="pre">b</span></code>. <em>Synchronizes-with</em> pairs are introduced by platform-specific
techniques, like pthread locks, thread creation, thread joining,
etc., and by atomic instructions. (See also <a class="reference internal" href="#ordering"><span class="std std-ref">Atomic Memory Ordering
Constraints</span></a>).</li>
</ul>
<p>Note that program order does not introduce <em>happens-before</em> edges
between a thread and signals executing inside that thread.</p>
<p>Every (defined) read operation (load instructions, memcpy, atomic
loads/read-modify-writes, etc.) R reads a series of bytes written by
(defined) write operations (store instructions, atomic
stores/read-modify-writes, memcpy, etc.). For the purposes of this
section, initialized globals are considered to have a write of the
initializer which is atomic and happens before any other read or write
of the memory in question. For each byte of a read R, R<sub>byte</sub>
may see any write to the same byte, except:</p>
<ul class="simple">
<li>If write<sub>1</sub>  happens before write<sub>2</sub>, and
write<sub>2</sub> happens before R<sub>byte</sub>, then
R<sub>byte</sub> does not see write<sub>1</sub>.</li>
<li>If R<sub>byte</sub> happens before write<sub>3</sub>, then
R<sub>byte</sub> does not see write<sub>3</sub>.</li>
</ul>
<p>Given that definition, R<sub>byte</sub> is defined as follows:</p>
<ul class="simple">
<li>If R is volatile, the result is target-dependent. (Volatile is
supposed to give guarantees which can support <code class="docutils literal"><span class="pre">sig_atomic_t</span></code> in
C/C++, and may be used for accesses to addresses that do not behave
like normal memory. It does not generally provide cross-thread
synchronization.)</li>
<li>Otherwise, if there is no write to the same byte that happens before
R<sub>byte</sub>, R<sub>byte</sub> returns <code class="docutils literal"><span class="pre">undef</span></code> for that byte.</li>
<li>Otherwise, if R<sub>byte</sub> may see exactly one write,
R<sub>byte</sub> returns the value written by that write.</li>
<li>Otherwise, if R is atomic, and all the writes R<sub>byte</sub> may
see are atomic, it chooses one of the values written. See the <a class="reference internal" href="#ordering"><span class="std std-ref">Atomic
Memory Ordering Constraints</span></a> section for additional
constraints on how the choice is made.</li>
<li>Otherwise R<sub>byte</sub> returns <code class="docutils literal"><span class="pre">undef</span></code>.</li>
</ul>
<p>R returns the value composed of the series of bytes it read. This
implies that some bytes within the value may be <code class="docutils literal"><span class="pre">undef</span></code> <strong>without</strong>
the entire value being <code class="docutils literal"><span class="pre">undef</span></code>. Note that this only defines the
semantics of the operation; it doesn&#8217;t mean that targets will emit more
than one instruction to read the series of bytes.</p>
<p>Note that in cases where none of the atomic intrinsics are used, this
model places only one restriction on IR transformations on top of what
is required for single-threaded execution: introducing a store to a byte
which might not otherwise be stored is not allowed in general.
(Specifically, in the case where another thread might write to and read
from an address, introducing a store can change a load that may see
exactly one write into a load that may see multiple writes.)</p>
</div>
<div class="section" id="atomic-memory-ordering-constraints">
<span id="ordering"></span><h3><a class="toc-backref" href="#id685">Atomic Memory Ordering Constraints</a><a class="headerlink" href="#atomic-memory-ordering-constraints" title="永久链接至标题">¶</a></h3>
<p>Atomic instructions (<a class="reference internal" href="#i-cmpxchg"><span class="std std-ref">cmpxchg</span></a>,
<a class="reference internal" href="#i-atomicrmw"><span class="std std-ref">atomicrmw</span></a>, <a class="reference internal" href="#i-fence"><span class="std std-ref">fence</span></a>,
<a class="reference internal" href="#i-load"><span class="std std-ref">atomic load</span></a>, and <a class="reference internal" href="#i-store"><span class="std std-ref">atomic store</span></a>) take
ordering parameters that determine which other atomic instructions on
the same address they <em>synchronize with</em>. These semantics are borrowed
from Java and C++0x, but are somewhat more colloquial. If these
descriptions aren&#8217;t precise enough, check those specs (see spec
references in the <a class="reference internal" href="Atomics.html"><span class="doc">atomics guide</span></a>).
<a class="reference internal" href="#i-fence"><span class="std std-ref">fence</span></a> instructions treat these orderings somewhat
differently since they don&#8217;t take an address. See that instruction&#8217;s
documentation for details.</p>
<p>For a simpler introduction to the ordering constraints, see the
<a class="reference internal" href="Atomics.html"><span class="doc">LLVM Atomic Instructions and Concurrency Guide</span></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unordered</span></code></dt>
<dd>The set of values that can be read is governed by the happens-before
partial order. A value cannot be read unless some operation wrote
it. This is intended to provide a guarantee strong enough to model
Java&#8217;s non-volatile shared variables. This ordering cannot be
specified for read-modify-write operations; it is not strong enough
to make them atomic in any interesting way.</dd>
<dt><code class="docutils literal"><span class="pre">monotonic</span></code></dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">unordered</span></code>, there is a single
total order for modifications by <code class="docutils literal"><span class="pre">monotonic</span></code> operations on each
address. All modification orders must be compatible with the
happens-before order. There is no guarantee that the modification
orders can be combined to a global total order for the whole program
(and this often will not be possible). The read in an atomic
read-modify-write operation (<a class="reference internal" href="#i-cmpxchg"><span class="std std-ref">cmpxchg</span></a> and
<a class="reference internal" href="#i-atomicrmw"><span class="std std-ref">atomicrmw</span></a>) reads the value in the modification
order immediately before the value it writes. If one atomic read
happens before another atomic read of the same address, the later
read must see the same value or a later value in the address&#8217;s
modification order. This disallows reordering of <code class="docutils literal"><span class="pre">monotonic</span></code> (or
stronger) operations on the same address. If an address is written
<code class="docutils literal"><span class="pre">monotonic</span></code>-ally by one thread, and other threads <code class="docutils literal"><span class="pre">monotonic</span></code>-ally
read that address repeatedly, the other threads must eventually see
the write. This corresponds to the C++0x/C1x
<code class="docutils literal"><span class="pre">memory_order_relaxed</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">acquire</span></code></dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">monotonic</span></code>, a
<em>synchronizes-with</em> edge may be formed with a <code class="docutils literal"><span class="pre">release</span></code> operation.
This is intended to model C++&#8217;s <code class="docutils literal"><span class="pre">memory_order_acquire</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">monotonic</span></code>, if this operation
writes a value which is subsequently read by an <code class="docutils literal"><span class="pre">acquire</span></code>
operation, it <em>synchronizes-with</em> that operation. (This isn&#8217;t a
complete description; see the C++0x definition of a release
sequence.) This corresponds to the C++0x/C1x
<code class="docutils literal"><span class="pre">memory_order_release</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">acq_rel</span></code> (acquire+release)</dt>
<dd>Acts as both an <code class="docutils literal"><span class="pre">acquire</span></code> and <code class="docutils literal"><span class="pre">release</span></code> operation on its
address. This corresponds to the C++0x/C1x <code class="docutils literal"><span class="pre">memory_order_acq_rel</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">seq_cst</span></code> (sequentially consistent)</dt>
<dd>In addition to the guarantees of <code class="docutils literal"><span class="pre">acq_rel</span></code> (<code class="docutils literal"><span class="pre">acquire</span></code> for an
operation that only reads, <code class="docutils literal"><span class="pre">release</span></code> for an operation that only
writes), there is a global total order on all
sequentially-consistent operations on all addresses, which is
consistent with the <em>happens-before</em> partial order and with the
modification orders of all the affected addresses. Each
sequentially-consistent read sees the last preceding write to the
same address in this global order. This corresponds to the C++0x/C1x
<code class="docutils literal"><span class="pre">memory_order_seq_cst</span></code> and Java volatile.</dd>
</dl>
<p id="singlethread">If an atomic operation is marked <code class="docutils literal"><span class="pre">singlethread</span></code>, it only <em>synchronizes
with</em> or participates in modification and seq_cst total orderings with
other operations running in the same thread (for example, in signal
handlers).</p>
</div>
<div class="section" id="fast-math-flags">
<span id="fastmath"></span><h3><a class="toc-backref" href="#id686">Fast-Math Flags</a><a class="headerlink" href="#fast-math-flags" title="永久链接至标题">¶</a></h3>
<p>LLVM IR floating-point binary ops (<a class="reference internal" href="#i-fadd"><span class="std std-ref">fadd</span></a>,
<a class="reference internal" href="#i-fsub"><span class="std std-ref">fsub</span></a>, <a class="reference internal" href="#i-fmul"><span class="std std-ref">fmul</span></a>, <a class="reference internal" href="#i-fdiv"><span class="std std-ref">fdiv</span></a>,
<a class="reference internal" href="#i-frem"><span class="std std-ref">frem</span></a>, <a class="reference internal" href="#i-fcmp"><span class="std std-ref">fcmp</span></a>) have the following flags that can
be set to enable otherwise unsafe floating point operations</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">nnan</span></code></dt>
<dd>No NaNs - Allow optimizations to assume the arguments and result are not
NaN. Such optimizations are required to retain defined behavior over
NaNs, but the value of the result is undefined.</dd>
<dt><code class="docutils literal"><span class="pre">ninf</span></code></dt>
<dd>No Infs - Allow optimizations to assume the arguments and result are not
+/-Inf. Such optimizations are required to retain defined behavior over
+/-Inf, but the value of the result is undefined.</dd>
<dt><code class="docutils literal"><span class="pre">nsz</span></code></dt>
<dd>No Signed Zeros - Allow optimizations to treat the sign of a zero
argument or result as insignificant.</dd>
<dt><code class="docutils literal"><span class="pre">arcp</span></code></dt>
<dd>Allow Reciprocal - Allow optimizations to use the reciprocal of an
argument rather than perform division.</dd>
<dt><code class="docutils literal"><span class="pre">fast</span></code></dt>
<dd>Fast - Allow algebraically equivalent transformations that may
dramatically change results in floating point (e.g. reassociate). This
flag implies all the others.</dd>
</dl>
</div>
<div class="section" id="use-list-order-directives">
<span id="uselistorder"></span><h3><a class="toc-backref" href="#id687">Use-list Order Directives</a><a class="headerlink" href="#use-list-order-directives" title="永久链接至标题">¶</a></h3>
<p>Use-list directives encode the in-memory order of each use-list, allowing the
order to be recreated. <code class="docutils literal"><span class="pre">&lt;order-indexes&gt;</span></code> is a comma-separated list of
indexes that are assigned to the referenced value&#8217;s uses. The referenced
value&#8217;s use-list is immediately sorted by these indexes.</p>
<p>Use-list directives may appear at function scope or global scope. They are not
instructions, and have no effect on the semantics of the IR. When they&#8217;re at
function scope, they must appear after the terminator of the final basic block.</p>
<p>If basic blocks have their address taken via <code class="docutils literal"><span class="pre">blockaddress()</span></code> expressions,
<code class="docutils literal"><span class="pre">uselistorder_bb</span></code> can be used to reorder their use-lists from outside their
function&#8217;s scope.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">uselistorder</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">order</span><span class="o">-</span><span class="n">indexes</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="n">uselistorder_bb</span> <span class="nd">@function</span><span class="p">,</span> <span class="o">%</span><span class="n">block</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">order</span><span class="o">-</span><span class="n">indexes</span><span class="o">&gt;</span> <span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">define</span> <span class="n">void</span> <span class="nd">@foo</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">arg1</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="p">;</span> <span class="o">...</span> <span class="n">instructions</span> <span class="o">...</span>
<span class="n">bb</span><span class="p">:</span>
  <span class="p">;</span> <span class="o">...</span> <span class="n">instructions</span> <span class="o">...</span>

  <span class="p">;</span> <span class="n">At</span> <span class="n">function</span> <span class="n">scope</span><span class="o">.</span>
  <span class="n">uselistorder</span> <span class="n">i32</span> <span class="o">%</span><span class="n">arg1</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span>
  <span class="n">uselistorder</span> <span class="n">label</span> <span class="o">%</span><span class="n">bb</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">;</span> <span class="n">At</span> <span class="k">global</span> <span class="n">scope</span><span class="o">.</span>
<span class="n">uselistorder</span> <span class="n">i32</span><span class="o">*</span> <span class="nd">@global</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">uselistorder</span> <span class="n">i32</span> <span class="mi">7</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">uselistorder</span> <span class="n">i32</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="nd">@bar</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">uselistorder_bb</span> <span class="nd">@foo</span><span class="p">,</span> <span class="o">%</span><span class="n">bb</span><span class="p">,</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-system">
<span id="typesystem"></span><h2><a class="toc-backref" href="#id688">Type System</a><a class="headerlink" href="#type-system" title="永久链接至标题">¶</a></h2>
<p>The LLVM type system is one of the most important features of the
intermediate representation. Being typed enables a number of
optimizations to be performed on the intermediate representation
directly, without having to do extra analyses on the side before the
transformation. A strong type system makes it easier to read the
generated code and enables novel analyses and transformations that are
not feasible to perform on normal three address code representations.</p>
<div class="section" id="void-type">
<span id="t-void"></span><h3><a class="toc-backref" href="#id689">Void Type</a><a class="headerlink" href="#void-type" title="永久链接至标题">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The void type does not represent any value and has no size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span>
</pre></div>
</div>
</div>
<div class="section" id="function-type">
<span id="t-function"></span><h3><a class="toc-backref" href="#id690">Function Type</a><a class="headerlink" href="#function-type" title="永久链接至标题">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The function type can be thought of as a function signature. It consists of a
return type and a list of formal parameter types. The return type of a function
type is a void type or first class type &#8212; except for <a class="reference internal" href="#t-label"><span class="std std-ref">label</span></a>
and <a class="reference internal" href="#t-metadata"><span class="std std-ref">metadata</span></a> types.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">returntype</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">parameter</span> <span class="nb">list</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>...where &#8216;<code class="docutils literal"><span class="pre">&lt;parameter</span> <span class="pre">list&gt;</span></code>&#8216; is a comma-separated list of type
specifiers. Optionally, the parameter list may include a type <code class="docutils literal"><span class="pre">...</span></code>, which
indicates that the function takes a variable number of arguments. Variable
argument functions can access their arguments with the <a class="reference internal" href="#int-varargs"><span class="std std-ref">variable argument
handling intrinsic</span></a> functions. &#8216;<code class="docutils literal"><span class="pre">&lt;returntype&gt;</span></code>&#8216; is any type
except <a class="reference internal" href="#t-label"><span class="std std-ref">label</span></a> and <a class="reference internal" href="#t-metadata"><span class="std std-ref">metadata</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i32)</span></code></td>
<td>function taking an <code class="docutils literal"><span class="pre">i32</span></code>, returning an <code class="docutils literal"><span class="pre">i32</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">float</span> <span class="pre">(i16,</span> <span class="pre">i32</span> <span class="pre">*)</span> <span class="pre">*</span></code></td>
<td><a class="reference internal" href="#t-pointer"><span class="std std-ref">Pointer</span></a> to a function that takes an <code class="docutils literal"><span class="pre">i16</span></code> and a <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to <code class="docutils literal"><span class="pre">i32</span></code>, returning <code class="docutils literal"><span class="pre">float</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i8*,</span> <span class="pre">...)</span></code></td>
<td>A vararg function that takes at least one <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to <code class="docutils literal"><span class="pre">i8</span></code> (char in C), which returns an integer. This is the signature for <code class="docutils literal"><span class="pre">printf</span></code> in LLVM.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">{i32,</span> <span class="pre">i32}</span> <span class="pre">(i32)</span></code></td>
<td>A function taking an <code class="docutils literal"><span class="pre">i32</span></code>, returning a <a class="reference internal" href="#t-struct"><span class="std std-ref">structure</span></a> containing two <code class="docutils literal"><span class="pre">i32</span></code> values</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="first-class-types">
<span id="t-firstclass"></span><h3><a class="toc-backref" href="#id691">First Class Types</a><a class="headerlink" href="#first-class-types" title="永久链接至标题">¶</a></h3>
<p>The <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> types are perhaps the most important.
Values of these types are the only ones which can be produced by
instructions.</p>
<div class="section" id="single-value-types">
<span id="t-single-value"></span><h4><a class="toc-backref" href="#id692">Single Value Types</a><a class="headerlink" href="#single-value-types" title="永久链接至标题">¶</a></h4>
<p>These are the types that are valid in registers from CodeGen&#8217;s perspective.</p>
<div class="section" id="integer-type">
<span id="t-integer"></span><h5><a class="toc-backref" href="#id693">Integer Type</a><a class="headerlink" href="#integer-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The integer type is a very simple type that simply specifies an
arbitrary bit width for the integer type desired. Any bit width from 1
bit to 2<sup>23</sup>-1 (about 8 million) can be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">iN</span>
</pre></div>
</div>
<p>The number of bits the integer will occupy is specified by the <code class="docutils literal"><span class="pre">N</span></code>
value.</p>
<div class="section" id="examples">
<h6>Examples:<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h6>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i1</span></code></td>
<td>a single-bit integer.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">i32</span></code></td>
<td>a 32-bit integer.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i1942652</span></code></td>
<td>a really big integer of over 1 million bits.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="floating-point-types">
<span id="t-floating"></span><h5><a class="toc-backref" href="#id694">Floating Point Types</a><a class="headerlink" href="#floating-point-types" title="永久链接至标题">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">half</span></code></td>
<td>16-bit floating point value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">float</span></code></td>
<td>32-bit floating point value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">double</span></code></td>
<td>64-bit floating point value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">fp128</span></code></td>
<td>128-bit floating point value (112-bit mantissa)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x86_fp80</span></code></td>
<td>80-bit floating point value (X87)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">ppc_fp128</span></code></td>
<td>128-bit floating point value (two 64-bits)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="x86-mmx-type">
<h5><a class="toc-backref" href="#id695">X86_mmx Type</a><a class="headerlink" href="#x86-mmx-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The x86_mmx type represents a value held in an MMX register on an x86
machine. The operations allowed on it are quite limited: parameters and
return values, load and store, and bitcast. User-specified MMX
instructions are represented as intrinsic or asm calls with arguments
and/or results of this type. There are no arrays, vectors or constants
of this type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x86_mmx</span>
</pre></div>
</div>
</div>
<div class="section" id="pointer-type">
<span id="t-pointer"></span><h5><a class="toc-backref" href="#id696">Pointer Type</a><a class="headerlink" href="#pointer-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The pointer type is used to specify memory locations. Pointers are
commonly used to reference objects in memory.</p>
<p>Pointer types may have an optional address space attribute defining the
numbered address space where the pointed-to object resides. The default
address space is number zero. The semantics of non-zero address spaces
are target-specific.</p>
<p>Note that LLVM does not permit pointers to void (<code class="docutils literal"><span class="pre">void*</span></code>) nor does it
permit pointers to labels (<code class="docutils literal"><span class="pre">label*</span></code>). Use <code class="docutils literal"><span class="pre">i8*</span></code> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i32]*</span></code></td>
<td>A <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to <a class="reference internal" href="#t-array"><span class="std std-ref">array</span></a> of four <code class="docutils literal"><span class="pre">i32</span></code> values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i32*)</span> <span class="pre">*</span></code></td>
<td>A <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to a <a class="reference internal" href="#t-function"><span class="std std-ref">function</span></a> that takes an <code class="docutils literal"><span class="pre">i32*</span></code>, returning an <code class="docutils literal"><span class="pre">i32</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">i32</span> <span class="pre">addrspace(5)*</span></code></td>
<td>A <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to an <code class="docutils literal"><span class="pre">i32</span></code> value that resides in address space #5.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vector-type">
<span id="t-vector"></span><h5><a class="toc-backref" href="#id697">Vector Type</a><a class="headerlink" href="#vector-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>A vector type is a simple derived type that represents a vector of
elements. Vector types are used when multiple primitive data are
operated in parallel using a single instruction (SIMD). A vector type
requires a size (number of elements) and an underlying primitive data
type. Vector types are considered <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span> <span class="o">&lt;</span><span class="c1"># elements&gt; x &lt;elementtype&gt; &gt;</span>
</pre></div>
</div>
<p>The number of elements is a constant integer value larger than 0;
elementtype may be any integer, floating point or pointer type. Vectors
of size zero are not allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i32&gt;</span></code></td>
<td>Vector of 4 32-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;8</span> <span class="pre">x</span> <span class="pre">float&gt;</span></code></td>
<td>Vector of 8 32-bit floating-point values.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;2</span> <span class="pre">x</span> <span class="pre">i64&gt;</span></code></td>
<td>Vector of 2 64-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i64*&gt;</span></code></td>
<td>Vector of 4 pointers to 64-bit integer values.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="label-type">
<span id="t-label"></span><h4><a class="toc-backref" href="#id698">Label Type</a><a class="headerlink" href="#label-type" title="永久链接至标题">¶</a></h4>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The label type represents code labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">label</span>
</pre></div>
</div>
</div>
<div class="section" id="token-type">
<span id="t-token"></span><h4><a class="toc-backref" href="#id699">Token Type</a><a class="headerlink" href="#token-type" title="永久链接至标题">¶</a></h4>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The token type is used when a value is associated with an instruction
but all uses of the value must not attempt to introspect or obscure it.
As such, it is not appropriate to have a <a class="reference internal" href="#i-phi"><span class="std std-ref">phi</span></a> or
<a class="reference internal" href="#i-select"><span class="std std-ref">select</span></a> of type token.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">token</span>
</pre></div>
</div>
</div>
<div class="section" id="metadata-type">
<span id="t-metadata"></span><h4><a class="toc-backref" href="#id700">Metadata Type</a><a class="headerlink" href="#metadata-type" title="永久链接至标题">¶</a></h4>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The metadata type represents embedded metadata. No derived types may be
created from metadata except for <a class="reference internal" href="#t-function"><span class="std std-ref">function</span></a> arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">metadata</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregate-types">
<span id="t-aggregate"></span><h4><a class="toc-backref" href="#id701">Aggregate Types</a><a class="headerlink" href="#aggregate-types" title="永久链接至标题">¶</a></h4>
<p>Aggregate Types are a subset of derived types that can contain multiple
member types. <a class="reference internal" href="#t-array"><span class="std std-ref">Arrays</span></a> and <a class="reference internal" href="#t-struct"><span class="std std-ref">structs</span></a> are
aggregate types. <a class="reference internal" href="#t-vector"><span class="std std-ref">Vectors</span></a> are not considered to be
aggregate types.</p>
<div class="section" id="array-type">
<span id="t-array"></span><h5><a class="toc-backref" href="#id702">Array Type</a><a class="headerlink" href="#array-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The array type is a very simple derived type that arranges elements
sequentially in memory. The array type requires a size (number of
elements) and an underlying data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">&lt;</span><span class="c1"># elements&gt; x &lt;elementtype&gt;]</span>
</pre></div>
</div>
<p>The number of elements is a constant integer value; <code class="docutils literal"><span class="pre">elementtype</span></code> may
be any type with a size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[40</span> <span class="pre">x</span> <span class="pre">i32]</span></code></td>
<td>Array of 40 32-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[41</span> <span class="pre">x</span> <span class="pre">i32]</span></code></td>
<td>Array of 41 32-bit integer values.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i8]</span></code></td>
<td>Array of 4 8-bit integer values.</td>
</tr>
</tbody>
</table>
<p>Here are some examples of multidimensional arrays:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[3</span> <span class="pre">x</span> <span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i32]]</span></code></td>
<td>3x4 array of 32-bit integer values.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[12</span> <span class="pre">x</span> <span class="pre">[10</span> <span class="pre">x</span> <span class="pre">float]]</span></code></td>
<td>12x10 array of single precision floating point values.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[2</span> <span class="pre">x</span> <span class="pre">[3</span> <span class="pre">x</span> <span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i16]]]</span></code></td>
<td>2x3x4 array of 16-bit integer values.</td>
</tr>
</tbody>
</table>
<p>There is no restriction on indexing beyond the end of the array implied
by a static type (though there are restrictions on indexing beyond the
bounds of an allocated object in some cases). This means that
single-dimension &#8216;variable sized array&#8217; addressing can be implemented in
LLVM with a zero length array type. An implementation of &#8216;pascal style
arrays&#8217; in LLVM could use the type &#8220;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i32,</span> <span class="pre">[0</span> <span class="pre">x</span> <span class="pre">float]}</span></code>&#8221;, for
example.</p>
</div>
<div class="section" id="structure-type">
<span id="t-struct"></span><h5><a class="toc-backref" href="#id703">Structure Type</a><a class="headerlink" href="#structure-type" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>The structure type is used to represent a collection of data members
together in memory. The elements of a structure may be any type that has
a size.</p>
<p>Structures in memory are accessed using &#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; by
getting a pointer to a field with the &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction.
Structures in registers are accessed using the &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; and
&#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; instructions.</p>
<p>Structures may optionally be &#8220;packed&#8221; structures, which indicate that
the alignment of the struct is one byte, and that there is no padding
between the elements. In non-packed structs, padding between field types
is inserted as defined by the DataLayout string in the module, which is
required to match what the underlying code generator expects.</p>
<p>Structures can either be &#8220;literal&#8221; or &#8220;identified&#8221;. A literal structure
is defined inline with other types (e.g. <code class="docutils literal"><span class="pre">{i32,</span> <span class="pre">i32}*</span></code>) whereas
identified types are always defined at the top level with a name.
Literal types are uniqued by their contents and can never be recursive
or opaque since there is no way to write one. Identified types can be
recursive, can be opaqued, and are never uniqued.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">T1</span> <span class="o">=</span> <span class="nb">type</span> <span class="p">{</span> <span class="o">&lt;</span><span class="nb">type</span> <span class="nb">list</span><span class="o">&gt;</span> <span class="p">}</span>     <span class="p">;</span> <span class="n">Identified</span> <span class="n">normal</span> <span class="n">struct</span> <span class="nb">type</span>
<span class="o">%</span><span class="n">T2</span> <span class="o">=</span> <span class="nb">type</span> <span class="o">&lt;</span><span class="p">{</span> <span class="o">&lt;</span><span class="nb">type</span> <span class="nb">list</span><span class="o">&gt;</span> <span class="p">}</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">Identified</span> <span class="n">packed</span> <span class="n">struct</span> <span class="nb">type</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">{</span> <span class="pre">i32,</span> <span class="pre">i32,</span> <span class="pre">i32</span> <span class="pre">}</span></code></td>
<td>A triple of three <code class="docutils literal"><span class="pre">i32</span></code> values</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">{</span> <span class="pre">float,</span> <span class="pre">i32</span> <span class="pre">(i32)</span> <span class="pre">*</span> <span class="pre">}</span></code></td>
<td>A pair, where the first element is a <code class="docutils literal"><span class="pre">float</span></code> and the second element is a <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> to a <a class="reference internal" href="#t-function"><span class="std std-ref">function</span></a> that takes an <code class="docutils literal"><span class="pre">i32</span></code>, returning an <code class="docutils literal"><span class="pre">i32</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;{</span> <span class="pre">i8,</span> <span class="pre">i32</span> <span class="pre">}&gt;</span></code></td>
<td>A packed struct known to be 5 bytes in size.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="opaque-structure-types">
<span id="t-opaque"></span><h5><a class="toc-backref" href="#id704">Opaque Structure Types</a><a class="headerlink" href="#opaque-structure-types" title="永久链接至标题">¶</a></h5>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Overview:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Opaque structure types are used to represent named structure types that
do not have a body specified. This corresponds (for example) to the C
notion of a forward declared structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Syntax:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span> <span class="n">opaque</span>
<span class="o">%</span><span class="mi">52</span> <span class="o">=</span> <span class="nb">type</span> <span class="n">opaque</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">opaque</span></code></td>
<td>An opaque type.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="section" id="constants">
<span id="id3"></span><h2><a class="toc-backref" href="#id705">Constants</a><a class="headerlink" href="#constants" title="永久链接至标题">¶</a></h2>
<p>LLVM has several different basic types of constants. This section
describes them all and their syntax.</p>
<div class="section" id="simple-constants">
<h3><a class="toc-backref" href="#id706">Simple Constants</a><a class="headerlink" href="#simple-constants" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt><strong>Boolean constants</strong></dt>
<dd>The two strings &#8216;<code class="docutils literal"><span class="pre">true</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">false</span></code>&#8216; are both valid constants
of the <code class="docutils literal"><span class="pre">i1</span></code> type.</dd>
<dt><strong>Integer constants</strong></dt>
<dd>Standard integers (such as &#8216;4&#8217;) are constants of the
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> type. Negative numbers may be used with
integer types.</dd>
<dt><strong>Floating point constants</strong></dt>
<dd>Floating point constants use standard decimal notation (e.g.
123.421), exponential notation (e.g. 1.23421e+2), or a more precise
hexadecimal notation (see below). The assembler requires the exact
decimal value of a floating-point constant. For example, the
assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating
decimal in binary. Floating point constants must have a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type.</dd>
<dt><strong>Null pointer constants</strong></dt>
<dd>The identifier &#8216;<code class="docutils literal"><span class="pre">null</span></code>&#8216; is recognized as a null pointer constant
and must be of <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer type</span></a>.</dd>
<dt><strong>Token constants</strong></dt>
<dd>The identifier &#8216;<code class="docutils literal"><span class="pre">none</span></code>&#8216; is recognized as an empty token constant
and must be of <a class="reference internal" href="#t-token"><span class="std std-ref">token type</span></a>.</dd>
</dl>
<p>The one non-intuitive notation for constants is the hexadecimal form of
floating point constants. For example, the form
&#8216;<code class="docutils literal"><span class="pre">double</span>&nbsp;&nbsp;&nbsp; <span class="pre">0x432ff973cafa8000</span></code>&#8216; is equivalent to (but harder to read
than) &#8216;<code class="docutils literal"><span class="pre">double</span> <span class="pre">4.5e+15</span></code>&#8216;. The only time hexadecimal floating point
constants are required (and the only time that they are generated by the
disassembler) is when a floating point constant must be emitted but it
cannot be represented as a decimal floating point number in a reasonable
number of digits. For example, NaN&#8217;s, infinities, and other special
values are represented in their IEEE hexadecimal format so that assembly
and disassembly do not cause any bits to change in the constants.</p>
<p>When using the hexadecimal form, constants of types half, float, and
double are represented using the 16-digit form shown above (which
matches the IEEE754 representation for double); half and float values
must, however, be exactly representable as IEEE 754 half and single
precision, respectively. Hexadecimal format is always used for long
double, and there are three forms of long double. The 80-bit format used
by x86 is represented as <code class="docutils literal"><span class="pre">0xK</span></code> followed by 20 hexadecimal digits. The
128-bit format used by PowerPC (two adjacent doubles) is represented by
<code class="docutils literal"><span class="pre">0xM</span></code> followed by 32 hexadecimal digits. The IEEE 128-bit format is
represented by <code class="docutils literal"><span class="pre">0xL</span></code> followed by 32 hexadecimal digits. Long doubles
will only work if they match the long double format on your target.
The IEEE 16-bit format (half precision) is represented by <code class="docutils literal"><span class="pre">0xH</span></code>
followed by 4 hexadecimal digits. All hexadecimal formats are big-endian
(sign bit at the left).</p>
<p>There are no constants of type x86_mmx.</p>
</div>
<div class="section" id="complex-constants">
<span id="complexconstants"></span><h3><a class="toc-backref" href="#id707">Complex Constants</a><a class="headerlink" href="#complex-constants" title="永久链接至标题">¶</a></h3>
<p>Complex constants are a (potentially recursive) combination of simple
constants and smaller complex constants.</p>
<dl class="docutils">
<dt><strong>Structure constants</strong></dt>
<dd>Structure constants are represented with notation similar to
structure type definitions (a comma separated list of elements,
surrounded by braces (<code class="docutils literal"><span class="pre">{}</span></code>)). For example:
&#8220;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i32</span> <span class="pre">4,</span> <span class="pre">float</span> <span class="pre">17.0,</span> <span class="pre">i32*</span> <span class="pre">&#64;G</span> <span class="pre">}</span></code>&#8221;, where &#8220;<code class="docutils literal"><span class="pre">&#64;G</span></code>&#8221; is declared as
&#8220;<code class="docutils literal"><span class="pre">&#64;G</span> <span class="pre">=</span> <span class="pre">external</span> <span class="pre">global</span> <span class="pre">i32</span></code>&#8221;. Structure constants must have
<a class="reference internal" href="#t-struct"><span class="std std-ref">structure type</span></a>, and the number and types of elements
must match those specified by the type.</dd>
<dt><strong>Array constants</strong></dt>
<dd>Array constants are represented with notation similar to array type
definitions (a comma separated list of elements, surrounded by
square brackets (<code class="docutils literal"><span class="pre">[]</span></code>)). For example:
&#8220;<code class="docutils literal"><span class="pre">[</span> <span class="pre">i32</span> <span class="pre">42,</span> <span class="pre">i32</span> <span class="pre">11,</span> <span class="pre">i32</span> <span class="pre">74</span> <span class="pre">]</span></code>&#8221;. Array constants must have
<a class="reference internal" href="#t-array"><span class="std std-ref">array type</span></a>, and the number and types of elements must
match those specified by the type. As a special case, character array
constants may also be represented as a double-quoted string using the <code class="docutils literal"><span class="pre">c</span></code>
prefix. For example: &#8220;<code class="docutils literal"><span class="pre">c&quot;Hello</span> <span class="pre">World\0A\00&quot;</span></code>&#8221;.</dd>
<dt><strong>Vector constants</strong></dt>
<dd>Vector constants are represented with notation similar to vector
type definitions (a comma separated list of elements, surrounded by
less-than/greater-than&#8217;s (<code class="docutils literal"><span class="pre">&lt;&gt;</span></code>)). For example:
&#8220;<code class="docutils literal"><span class="pre">&lt;</span> <span class="pre">i32</span> <span class="pre">42,</span> <span class="pre">i32</span> <span class="pre">11,</span> <span class="pre">i32</span> <span class="pre">74,</span> <span class="pre">i32</span> <span class="pre">100</span> <span class="pre">&gt;</span></code>&#8221;. Vector constants
must have <a class="reference internal" href="#t-vector"><span class="std std-ref">vector type</span></a>, and the number and types of
elements must match those specified by the type.</dd>
<dt><strong>Zero initialization</strong></dt>
<dd>The string &#8216;<code class="docutils literal"><span class="pre">zeroinitializer</span></code>&#8216; can be used to zero initialize a
value to zero of <em>any</em> type, including scalar and
<a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> types. This is often used to avoid
having to print large zero initializers (e.g. for large arrays) and
is always exactly equivalent to using explicit zero initializers.</dd>
<dt><strong>Metadata node</strong></dt>
<dd>A metadata node is a constant tuple without types. For example:
&#8220;<code class="docutils literal"><span class="pre">!{!0,</span> <span class="pre">!{!2,</span> <span class="pre">!0},</span> <span class="pre">!&quot;test&quot;}</span></code>&#8221;. Metadata can reference constant values,
for example: &#8220;<code class="docutils literal"><span class="pre">!{!0,</span> <span class="pre">i32</span> <span class="pre">0,</span> <span class="pre">i8*</span> <span class="pre">&#64;global,</span> <span class="pre">i64</span> <span class="pre">(i64)*</span> <span class="pre">&#64;function,</span> <span class="pre">!&quot;str&quot;}</span></code>&#8221;.
Unlike other typed constants that are meant to be interpreted as part of
the instruction stream, metadata is a place to attach additional
information such as debug info.</dd>
</dl>
</div>
<div class="section" id="global-variable-and-function-addresses">
<h3><a class="toc-backref" href="#id708">Global Variable and Function Addresses</a><a class="headerlink" href="#global-variable-and-function-addresses" title="永久链接至标题">¶</a></h3>
<p>The addresses of <a class="reference internal" href="#globalvars"><span class="std std-ref">global variables</span></a> and
<a class="reference internal" href="#functionstructure"><span class="std std-ref">functions</span></a> are always implicitly valid
(link-time) constants. These constants are explicitly referenced when
the <a class="reference internal" href="#identifiers"><span class="std std-ref">identifier for the global</span></a> is used and always have
<a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> type. For example, the following is a legal LLVM
file:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@X</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">17</span>
<span class="vg">@Y</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">42</span>
<span class="vg">@Z</span> <span class="p">=</span> <span class="k">global</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">*]</span> <span class="p">[</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@X</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@Y</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="undefined-values">
<span id="undefvalues"></span><h3><a class="toc-backref" href="#id709">Undefined Values</a><a class="headerlink" href="#undefined-values" title="永久链接至标题">¶</a></h3>
<p>The string &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; can be used anywhere a constant is expected, and
indicates that the user of the value may receive an unspecified
bit-pattern. Undefined values may be of any type (other than &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216;
or &#8216;<code class="docutils literal"><span class="pre">void</span></code>&#8216;) and be used anywhere a constant is permitted.</p>
<p>Undefined values are useful because they indicate to the compiler that
the program is well defined no matter what value is used. This gives the
compiler more freedom to optimize. Here are some examples of
(potentially surprising) transformations that are valid (in pseudo IR):</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">add</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">sub</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">xor</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">undef</span>
</pre></div>
</div>
<p>This is safe because all of the output bits are affected by the undef
bits. Any output bit can have a zero or one depending on the input bits.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">or</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">and</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="m">-1</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="m">0</span>
<span class="nl">Unsafe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">undef</span>
</pre></div>
</div>
<p>These logical operations have bits that are not always affected by the
input. For example, if <code class="docutils literal"><span class="pre">%X</span></code> has a zero bit, then the output of the
&#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; operation will always be a zero for that bit, no matter what
the corresponding bit from the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; is. As such, it is unsafe to
optimize or assume that the result of the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; is &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;.
However, it is safe to assume that all bits of the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; could be
0, and optimize the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; to 0. Likewise, it is safe to assume that
all the bits of the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; operand to the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; could be set,
allowing the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; to be folded to -1.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">select</span> <span class="k">undef</span><span class="p">,</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%Y</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">select</span> <span class="k">undef</span><span class="p">,</span> <span class="m">42</span><span class="p">,</span> <span class="nv">%Y</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">select</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%Y</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="nv">%X</span>     <span class="p">(</span><span class="k">or</span> <span class="nv">%Y</span><span class="p">)</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="m">42</span>     <span class="p">(</span><span class="k">or</span> <span class="nv">%Y</span><span class="p">)</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="nv">%Y</span>
<span class="nl">Unsafe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">undef</span>
  <span class="nv">%C</span> <span class="p">=</span> <span class="k">undef</span>
</pre></div>
</div>
<p>This set of examples shows that undefined &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; (and conditional
branch) conditions can go <em>either way</em>, but they have to come from one
of the two operands. In the <code class="docutils literal"><span class="pre">%A</span></code> example, if <code class="docutils literal"><span class="pre">%X</span></code> and <code class="docutils literal"><span class="pre">%Y</span></code> were
both known to have a clear low bit, then <code class="docutils literal"><span class="pre">%A</span></code> would have to have a
cleared low bit. However, in the <code class="docutils literal"><span class="pre">%C</span></code> example, the optimizer is
allowed to assume that the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; operand could be the same as
<code class="docutils literal"><span class="pre">%Y</span></code>, allowing the whole &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; to be eliminated.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  %A = xor undef, undef

  %B = undef
  %C = xor %B, %B

  %D = undef
  %E = icmp slt %D, 4
  %F = icmp gte %D, 4

Safe:
  %A = undef
  %B = undef
  %C = undef
  %D = undef
  %E = undef
  %F = undef
</pre></div>
</div>
<p>This example points out that two &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; operands are not
necessarily the same. This can be surprising to people (and also matches
C semantics) where they assume that &#8220;<code class="docutils literal"><span class="pre">X^X</span></code>&#8221; is always zero, even if
<code class="docutils literal"><span class="pre">X</span></code> is undefined. This isn&#8217;t true for a number of reasons, but the
short answer is that an &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216; &#8220;variable&#8221; can arbitrarily change
its value over its &#8220;live range&#8221;. This is true because the variable
doesn&#8217;t actually <em>have a live range</em>. Instead, the value is logically
read from arbitrary registers that happen to be around when needed, so
the value is not necessarily consistent over time. In fact, <code class="docutils literal"><span class="pre">%A</span></code> and
<code class="docutils literal"><span class="pre">%C</span></code> need to have the same semantics or the core LLVM &#8220;replace all
uses with&#8221; concept would not hold.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%A</span> <span class="p">=</span> <span class="k">fdiv</span> <span class="k">undef</span><span class="p">,</span> <span class="nv">%X</span>
  <span class="nv">%B</span> <span class="p">=</span> <span class="k">fdiv</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">undef</span>
<span class="nl">Safe:</span>
  <span class="nv">%A</span> <span class="p">=</span> <span class="k">undef</span>
<span class="nl">b:</span> <span class="k">unreachable</span>
</pre></div>
</div>
<p>These examples show the crucial difference between an <em>undefined value</em>
and <em>undefined behavior</em>. An undefined value (like &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;) is
allowed to have an arbitrary bit-pattern. This means that the <code class="docutils literal"><span class="pre">%A</span></code>
operation can be constant folded to &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;, because the &#8216;<code class="docutils literal"><span class="pre">undef</span></code>&#8216;
could be an SNaN, and <code class="docutils literal"><span class="pre">fdiv</span></code> is not (currently) defined on SNaN&#8217;s.
However, in the second example, we can make a more aggressive
assumption: because the <code class="docutils literal"><span class="pre">undef</span></code> is allowed to be an arbitrary value,
we are allowed to assume that it could be zero. Since a divide by zero
has <em>undefined behavior</em>, we are allowed to assume that the operation
does not execute at all. This allows us to delete the divide and all
code after it. Because the undefined operation &#8220;can&#8217;t happen&#8221;, the
optimizer can assume that it occurs in dead code.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>a:  store undef -&gt; %X
b:  store %X -&gt; undef
Safe:
a: &lt;deleted&gt;
b: unreachable
</pre></div>
</div>
<p>These examples reiterate the <code class="docutils literal"><span class="pre">fdiv</span></code> example: a store <em>of</em> an undefined
value can be assumed to not have any effect; we can assume that the
value is overwritten with bits that happen to match what was already
there. However, a store <em>to</em> an undefined location could clobber
arbitrary memory, therefore, it has undefined behavior.</p>
</div>
<div class="section" id="poison-values">
<span id="poisonvalues"></span><h3><a class="toc-backref" href="#id710">Poison Values</a><a class="headerlink" href="#poison-values" title="永久链接至标题">¶</a></h3>
<p>Poison values are similar to <a class="reference internal" href="#undefvalues"><span class="std std-ref">undef values</span></a>, however
they also represent the fact that an instruction or constant expression
that cannot evoke side effects has nevertheless detected a condition
that results in undefined behavior.</p>
<p>There is currently no way of representing a poison value in the IR; they
only exist when produced by operations such as <a class="reference internal" href="#i-add"><span class="std std-ref">add</span></a> with
the <code class="docutils literal"><span class="pre">nsw</span></code> flag.</p>
<p>Poison value behavior is defined in terms of value <em>dependence</em>:</p>
<ul class="simple">
<li>Values other than <a class="reference internal" href="#i-phi"><span class="std std-ref">phi</span></a> nodes depend on their operands.</li>
<li><a class="reference internal" href="#i-phi"><span class="std std-ref">Phi</span></a> nodes depend on the operand corresponding to
their dynamic predecessor basic block.</li>
<li>Function arguments depend on the corresponding actual argument values
in the dynamic callers of their functions.</li>
<li><a class="reference internal" href="#i-call"><span class="std std-ref">Call</span></a> instructions depend on the <a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a>
instructions that dynamically transfer control back to them.</li>
<li><a class="reference internal" href="#i-invoke"><span class="std std-ref">Invoke</span></a> instructions depend on the
<a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a>, <a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a>, or exception-throwing
call instructions that dynamically transfer control back to them.</li>
<li>Non-volatile loads and stores depend on the most recent stores to all
of the referenced memory addresses, following the order in the IR
(including loads and stores implied by intrinsics such as
<a class="reference internal" href="#int-memcpy"><span class="std std-ref">&#64;llvm.memcpy</span></a>.)</li>
<li>An instruction with externally visible side effects depends on the
most recent preceding instruction with externally visible side
effects, following the order in the IR. (This includes <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.)</li>
<li>An instruction <em>control-depends</em> on a <a class="reference internal" href="#terminators"><span class="std std-ref">terminator
instruction</span></a> if the terminator instruction has
multiple successors and the instruction is always executed when
control transfers to one of the successors, and may not be executed
when control is transferred to another.</li>
<li>Additionally, an instruction also <em>control-depends</em> on a terminator
instruction if the set of instructions it otherwise depends on would
be different if the terminator had transferred control to a different
successor.</li>
<li>Dependence is transitive.</li>
</ul>
<p>Poison values have the same behavior as <a class="reference internal" href="#undefvalues"><span class="std std-ref">undef values</span></a>,
with the additional effect that any instruction that has a <em>dependence</em>
on a poison value has undefined behavior.</p>
<p>Here are some examples:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
  <span class="nv">%poison</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">nuw</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>           <span class="c">; Results in a poison value.</span>
  <span class="nv">%still_poison</span> <span class="p">=</span> <span class="k">and</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="m">0</span>   <span class="c">; 0, but also poison.</span>
  <span class="nv">%poison_yet_again</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@h</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%still_poison</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%poison_yet_again</span>  <span class="c">; memory at @h[0] is poisoned</span>

  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>           <span class="c">; Poison value stored to memory.</span>
  <span class="nv">%poison2</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>         <span class="c">; Poison value loaded back from memory.</span>

  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>  <span class="c">; External observation; undefined behavior.</span>

  <span class="nv">%narrowaddr</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span> <span class="k">to</span> <span class="k">i16</span><span class="p">*</span>
  <span class="nv">%wideaddr</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span> <span class="k">to</span> <span class="k">i64</span><span class="p">*</span>
  <span class="nv">%poison3</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i16</span><span class="p">,</span> <span class="k">i16</span><span class="p">*</span> <span class="nv">%narrowaddr</span> <span class="c">; Returns a poison value.</span>
  <span class="nv">%poison4</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%wideaddr</span>  <span class="c">; Returns a poison value.</span>

  <span class="nv">%cmp</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">slt</span> <span class="k">i32</span> <span class="nv">%poison</span><span class="p">,</span> <span class="m">0</span>       <span class="c">; Returns a poison value.</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%true</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%end</span>  <span class="c">; Branch to either destination.</span>

<span class="nl">true:</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>        <span class="c">; This is control-dependent on %cmp, so</span>
                                       <span class="c">; it has undefined behavior.</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%end</span>

<span class="nl">end:</span>
  <span class="nv">%p</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%entry</span> <span class="p">],</span> <span class="p">[</span> <span class="m">1</span><span class="p">,</span> <span class="nv">%true</span> <span class="p">]</span>
                                       <span class="c">; Both edges into this PHI are</span>
                                       <span class="c">; control-dependent on %cmp, so this</span>
                                       <span class="c">; always results in a poison value.</span>

  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>        <span class="c">; This would depend on the store in %true</span>
                                       <span class="c">; if %cmp is true, or the store in %entry</span>
                                       <span class="c">; otherwise, so this is undefined behavior.</span>

  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%second_true</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%second_end</span>
                                       <span class="c">; The same branch again, but this time the</span>
                                       <span class="c">; true block doesn&#39;t have side effects.</span>

<span class="nl">second_true:</span>
  <span class="c">; No side effects!</span>
  <span class="k">ret</span> <span class="kt">void</span>

<span class="nl">second_end:</span>
  <span class="k">store</span> <span class="k">volatile</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@g</span>        <span class="c">; This time, the instruction always depends</span>
                                       <span class="c">; on the store in %end. Also, it is</span>
                                       <span class="c">; control-equivalent to %end, so this is</span>
                                       <span class="c">; well-defined (ignoring earlier undefined</span>
                                       <span class="c">; behavior in this example).</span>
</pre></div>
</div>
</div>
<div class="section" id="addresses-of-basic-blocks">
<span id="blockaddress"></span><h3><a class="toc-backref" href="#id711">Addresses of Basic Blocks</a><a class="headerlink" href="#addresses-of-basic-blocks" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">blockaddress(&#64;function,</span> <span class="pre">%block)</span></code></p>
<p>The &#8216;<code class="docutils literal"><span class="pre">blockaddress</span></code>&#8216; constant computes the address of the specified
basic block in the specified function, and always has an <code class="docutils literal"><span class="pre">i8*</span></code> type.
Taking the address of the entry block is illegal.</p>
<p>This value only has defined behavior when used as an operand to the
&#8216;<a class="reference internal" href="#i-indirectbr"><span class="std std-ref">indirectbr</span></a>&#8216; instruction, or for comparisons
against null. Pointer equality tests between labels addresses results in
undefined behavior &#8212; though, again, comparison against null is ok, and
no label is equal to the null pointer. This may be passed around as an
opaque pointer sized value as long as the bits are not inspected. This
allows <code class="docutils literal"><span class="pre">ptrtoint</span></code> and arithmetic to be performed on these values so
long as the original value is reconstituted before the <code class="docutils literal"><span class="pre">indirectbr</span></code>
instruction.</p>
<p>Finally, some targets may provide defined semantics when using the value
as the operand to an inline assembly, but that is target specific.</p>
</div>
<div class="section" id="constant-expressions">
<span id="constantexprs"></span><h3><a class="toc-backref" href="#id712">Constant Expressions</a><a class="headerlink" href="#constant-expressions" title="永久链接至标题">¶</a></h3>
<p>Constant expressions are used to allow expressions involving other
constants to be used as constants. Constant expressions may be of any
<a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type and may involve any LLVM operation
that does not have side effects (e.g. load and call are not supported).
The following is the syntax for constant expressions:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">trunc</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Truncate a constant to another type. The bit size of CST must be
larger than the bit size of TYPE. Both types must be integers.</dd>
<dt><code class="docutils literal"><span class="pre">zext</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Zero extend a constant to another type. The bit size of CST must be
smaller than the bit size of TYPE. Both types must be integers.</dd>
<dt><code class="docutils literal"><span class="pre">sext</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Sign extend a constant to another type. The bit size of CST must be
smaller than the bit size of TYPE. Both types must be integers.</dd>
<dt><code class="docutils literal"><span class="pre">fptrunc</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Truncate a floating point constant to another floating point type.
The size of CST must be larger than the size of TYPE. Both types
must be floating point.</dd>
<dt><code class="docutils literal"><span class="pre">fpext</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Floating point extend a constant to another type. The size of CST
must be smaller or equal to the size of TYPE. Both types must be
floating point.</dd>
<dt><code class="docutils literal"><span class="pre">fptoui</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a floating point constant to the corresponding unsigned
integer constant. TYPE must be a scalar or vector integer type. CST
must be of scalar or vector floating point type. Both CST and TYPE
must be scalars, or vectors of the same number of elements. If the
value won&#8217;t fit in the integer type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">fptosi</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a floating point constant to the corresponding signed
integer constant. TYPE must be a scalar or vector integer type. CST
must be of scalar or vector floating point type. Both CST and TYPE
must be scalars, or vectors of the same number of elements. If the
value won&#8217;t fit in the integer type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">uitofp</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert an unsigned integer constant to the corresponding floating
point constant. TYPE must be a scalar or vector floating point type.
CST must be of scalar or vector integer type. Both CST and TYPE must
be scalars, or vectors of the same number of elements. If the value
won&#8217;t fit in the floating point type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">sitofp</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a signed integer constant to the corresponding floating
point constant. TYPE must be a scalar or vector floating point type.
CST must be of scalar or vector integer type. Both CST and TYPE must
be scalars, or vectors of the same number of elements. If the value
won&#8217;t fit in the floating point type, the results are undefined.</dd>
<dt><code class="docutils literal"><span class="pre">ptrtoint</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a pointer typed constant to the corresponding integer
constant. <code class="docutils literal"><span class="pre">TYPE</span></code> must be an integer type. <code class="docutils literal"><span class="pre">CST</span></code> must be of
pointer type. The <code class="docutils literal"><span class="pre">CST</span></code> value is zero extended, truncated, or
unchanged to make it fit in <code class="docutils literal"><span class="pre">TYPE</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">inttoptr</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert an integer constant to a pointer constant. TYPE must be a
pointer type. CST must be of integer type. The CST value is zero
extended, truncated, or unchanged to make it fit in a pointer size.
This one is <em>really</em> dangerous!</dd>
<dt><code class="docutils literal"><span class="pre">bitcast</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a constant, CST, to another TYPE. The constraints of the
operands are the same as those for the <a class="reference internal" href="#i-bitcast"><span class="std std-ref">bitcast
instruction</span></a>.</dd>
<dt><code class="docutils literal"><span class="pre">addrspacecast</span> <span class="pre">(CST</span> <span class="pre">to</span> <span class="pre">TYPE)</span></code></dt>
<dd>Convert a constant pointer or constant vector of pointer, CST, to another
TYPE in a different address space. The constraints of the operands are the
same as those for the <a class="reference internal" href="#i-addrspacecast"><span class="std std-ref">addrspacecast instruction</span></a>.</dd>
<dt><code class="docutils literal"><span class="pre">getelementptr</span> <span class="pre">(TY,</span> <span class="pre">CSTPTR,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code>, <code class="docutils literal"><span class="pre">getelementptr</span> <span class="pre">inbounds</span> <span class="pre">(TY,</span> <span class="pre">CSTPTR,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr operation</span></a> on
constants. As with the <a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr</span></a>
instruction, the index list may have zero or more indexes, which are
required to make sense for the type of &#8220;pointer to TY&#8221;.</dd>
<dt><code class="docutils literal"><span class="pre">select</span> <span class="pre">(COND,</span> <span class="pre">VAL1,</span> <span class="pre">VAL2)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-select"><span class="std std-ref">select operation</span></a> on constants.</dd>
<dt><code class="docutils literal"><span class="pre">icmp</span> <span class="pre">COND</span> <span class="pre">(VAL1,</span> <span class="pre">VAL2)</span></code></dt>
<dd>Performs the <a class="reference internal" href="#i-icmp"><span class="std std-ref">icmp operation</span></a> on constants.</dd>
<dt><code class="docutils literal"><span class="pre">fcmp</span> <span class="pre">COND</span> <span class="pre">(VAL1,</span> <span class="pre">VAL2)</span></code></dt>
<dd>Performs the <a class="reference internal" href="#i-fcmp"><span class="std std-ref">fcmp operation</span></a> on constants.</dd>
<dt><code class="docutils literal"><span class="pre">extractelement</span> <span class="pre">(VAL,</span> <span class="pre">IDX)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-extractelement"><span class="std std-ref">extractelement operation</span></a> on
constants.</dd>
<dt><code class="docutils literal"><span class="pre">insertelement</span> <span class="pre">(VAL,</span> <span class="pre">ELT,</span> <span class="pre">IDX)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-insertelement"><span class="std std-ref">insertelement operation</span></a> on
constants.</dd>
<dt><code class="docutils literal"><span class="pre">shufflevector</span> <span class="pre">(VEC1,</span> <span class="pre">VEC2,</span> <span class="pre">IDXMASK)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-shufflevector"><span class="std std-ref">shufflevector operation</span></a> on
constants.</dd>
<dt><code class="docutils literal"><span class="pre">extractvalue</span> <span class="pre">(VAL,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-extractvalue"><span class="std std-ref">extractvalue operation</span></a> on
constants. The index list is interpreted in a similar manner as
indices in a &#8216;<a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr</span></a>&#8216; operation. At
least one index value must be specified.</dd>
<dt><code class="docutils literal"><span class="pre">insertvalue</span> <span class="pre">(VAL,</span> <span class="pre">ELT,</span> <span class="pre">IDX0,</span> <span class="pre">IDX1,</span> <span class="pre">...)</span></code></dt>
<dd>Perform the <a class="reference internal" href="#i-insertvalue"><span class="std std-ref">insertvalue operation</span></a> on constants.
The index list is interpreted in a similar manner as indices in a
&#8216;<a class="reference internal" href="#i-getelementptr"><span class="std std-ref">getelementptr</span></a>&#8216; operation. At least one index
value must be specified.</dd>
<dt><code class="docutils literal"><span class="pre">OPCODE</span> <span class="pre">(LHS,</span> <span class="pre">RHS)</span></code></dt>
<dd>Perform the specified operation of the LHS and RHS constants. OPCODE
may be any of the <a class="reference internal" href="#binaryops"><span class="std std-ref">binary</span></a> or <a class="reference internal" href="#bitwiseops"><span class="std std-ref">bitwise
binary</span></a> operations. The constraints on operands are
the same as those for the corresponding instruction (e.g. no bitwise
operations on floating point values are allowed).</dd>
</dl>
</div>
</div>
<div class="section" id="other-values">
<h2><a class="toc-backref" href="#id713">Other Values</a><a class="headerlink" href="#other-values" title="永久链接至标题">¶</a></h2>
<div class="section" id="inline-assembler-expressions">
<span id="inlineasmexprs"></span><h3><a class="toc-backref" href="#id714">Inline Assembler Expressions</a><a class="headerlink" href="#inline-assembler-expressions" title="永久链接至标题">¶</a></h3>
<p>LLVM supports inline assembler expressions (as opposed to <a class="reference internal" href="#moduleasm"><span class="std std-ref">Module-Level
Inline Assembly</span></a>) through the use of a special value. This value
represents the inline assembler as a template string (containing the
instructions to emit), a list of operand constraints (stored as a string), a
flag that indicates whether or not the inline asm expression has side effects,
and a flag indicating whether the function containing the asm needs to align its
stack conservatively.</p>
<p>The template string supports argument substitution of the operands using &#8220;<code class="docutils literal"><span class="pre">$</span></code>&#8221;
followed by a number, to indicate substitution of the given register/memory
location, as specified by the constraint string. &#8220;<code class="docutils literal"><span class="pre">${NUM:MODIFIER}</span></code>&#8221; may also
be used, where <code class="docutils literal"><span class="pre">MODIFIER</span></code> is a target-specific annotation for how to print the
operand (See <a class="reference internal" href="#inline-asm-modifiers"><span class="std std-ref">Asm template argument modifiers</span></a>).</p>
<p>A literal &#8220;<code class="docutils literal"><span class="pre">$</span></code>&#8221; may be included by using &#8220;<code class="docutils literal"><span class="pre">$$</span></code>&#8221; in the template. To include
other special characters into the output, the usual &#8220;<code class="docutils literal"><span class="pre">\XX</span></code>&#8221; escapes may be
used, just as in other strings. Note that after template substitution, the
resulting assembly string is parsed by LLVM&#8217;s integrated assembler unless it is
disabled &#8211; even when emitting a <code class="docutils literal"><span class="pre">.s</span></code> file &#8211; and thus must contain assembly
syntax known to LLVM.</p>
<p>LLVM&#8217;s support for inline asm is modeled closely on the requirements of Clang&#8217;s
GCC-compatible inline-asm support. Thus, the feature-set and the constraint and
modifier codes listed here are similar or identical to those in GCC&#8217;s inline asm
support. However, to be clear, the syntax of the template and constraint strings
described here is <em>not</em> the same as the syntax accepted by GCC and Clang, and,
while most constraint letters are passed through as-is by Clang, some get
translated to other codes when converting from the C source to the LLVM
assembly.</p>
<p>An example inline assembler expression is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">i32</span> <span class="p">(</span><span class="k">i32</span><span class="p">)</span> <span class="k">asm</span> <span class="s">&quot;bswap $0&quot;</span><span class="p">,</span> <span class="s">&quot;=r,r&quot;</span>
</pre></div>
</div>
<p>Inline assembler expressions may <strong>only</strong> be used as the callee operand
of a <a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a> or an <a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a> instruction.
Thus, typically we have:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i32</span> <span class="k">asm</span> <span class="s">&quot;bswap $0&quot;</span><span class="p">,</span> <span class="s">&quot;=r,r&quot;</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Inline asms with side effects not visible in the constraint list must be
marked as having side effects. This is done through the use of the
&#8216;<code class="docutils literal"><span class="pre">sideeffect</span></code>&#8216; keyword, like so:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">sideeffect</span> <span class="s">&quot;eieio&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">()</span>
</pre></div>
</div>
<p>In some cases inline asms will contain code that will not work unless
the stack is aligned in some way, such as calls or SSE instructions on
x86, yet will not contain code that does that alignment within the asm.
The compiler should make conservative assumptions about what the asm
might contain and should generate its usual stack alignment code in the
prologue if the &#8216;<code class="docutils literal"><span class="pre">alignstack</span></code>&#8216; keyword is present:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">alignstack</span> <span class="s">&quot;eieio&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">()</span>
</pre></div>
</div>
<p>Inline asms also support using non-standard assembly dialects. The
assumed dialect is ATT. When the &#8216;<code class="docutils literal"><span class="pre">inteldialect</span></code>&#8216; keyword is present,
the inline asm is using the Intel dialect. Currently, ATT and Intel are
the only supported dialects. An example is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">inteldialect</span> <span class="s">&quot;eieio&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">()</span>
</pre></div>
</div>
<p>If multiple keywords appear the &#8216;<code class="docutils literal"><span class="pre">sideeffect</span></code>&#8216; keyword must come
first, the &#8216;<code class="docutils literal"><span class="pre">alignstack</span></code>&#8216; keyword second and the &#8216;<code class="docutils literal"><span class="pre">inteldialect</span></code>&#8216;
keyword last.</p>
<div class="section" id="inline-asm-constraint-string">
<h4><a class="toc-backref" href="#id715">Inline Asm Constraint String</a><a class="headerlink" href="#inline-asm-constraint-string" title="永久链接至标题">¶</a></h4>
<p>The constraint list is a comma-separated string, each element containing one or
more constraint codes.</p>
<p>For each element in the constraint list an appropriate register or memory
operand will be chosen, and it will be made available to assembly template
string expansion as <code class="docutils literal"><span class="pre">$0</span></code> for the first constraint in the list, <code class="docutils literal"><span class="pre">$1</span></code> for the
second, etc.</p>
<p>There are three different types of constraints, which are distinguished by a
prefix symbol in front of the constraint code: Output, Input, and Clobber. The
constraints must always be given in that order: outputs first, then inputs, then
clobbers. They cannot be intermingled.</p>
<p>There are also three different categories of constraint codes:</p>
<ul class="simple">
<li>Register constraint. This is either a register class, or a fixed physical
register. This kind of constraint will allocate a register, and if necessary,
bitcast the argument or result to the appropriate type.</li>
<li>Memory constraint. This kind of constraint is for use with an instruction
taking a memory operand. Different constraints allow for different addressing
modes used by the target.</li>
<li>Immediate value constraint. This kind of constraint is for an integer or other
immediate value which can be rendered directly into an instruction. The
various target-specific constraints allow the selection of a value in the
proper range for the instruction you wish to use it with.</li>
</ul>
<div class="section" id="output-constraints">
<h5><a class="toc-backref" href="#id716">Output constraints</a><a class="headerlink" href="#output-constraints" title="永久链接至标题">¶</a></h5>
<p>Output constraints are specified by an &#8220;<code class="docutils literal"><span class="pre">=</span></code>&#8221; prefix (e.g. &#8220;<code class="docutils literal"><span class="pre">=r</span></code>&#8221;). This
indicates that the assembly will write to this operand, and the operand will
then be made available as a return value of the <code class="docutils literal"><span class="pre">asm</span></code> expression. Output
constraints do not consume an argument from the call instruction. (Except, see
below about indirect outputs).</p>
<p>Normally, it is expected that no output locations are written to by the assembly
expression until <em>all</em> of the inputs have been read. As such, LLVM may assign
the same register to an output and an input. If this is not safe (e.g. if the
assembly contains two instructions, where the first writes to one output, and
the second reads an input and writes to a second output), then the &#8220;<code class="docutils literal"><span class="pre">&amp;</span></code>&#8221;
modifier must be used (e.g. &#8220;<code class="docutils literal"><span class="pre">=&amp;r</span></code>&#8221;) to specify that the output is an
&#8220;early-clobber&#8221; output. Marking an ouput as &#8220;early-clobber&#8221; ensures that LLVM
will not use the same register for any inputs (other than an input tied to this
output).</p>
</div>
<div class="section" id="input-constraints">
<h5><a class="toc-backref" href="#id717">Input constraints</a><a class="headerlink" href="#input-constraints" title="永久链接至标题">¶</a></h5>
<p>Input constraints do not have a prefix &#8211; just the constraint codes. Each input
constraint will consume one argument from the call instruction. It is not
permitted for the asm to write to any input register or memory location (unless
that input is tied to an output). Note also that multiple inputs may all be
assigned to the same register, if LLVM can determine that they necessarily all
contain the same value.</p>
<p>Instead of providing a Constraint Code, input constraints may also &#8220;tie&#8221;
themselves to an output constraint, by providing an integer as the constraint
string. Tied inputs still consume an argument from the call instruction, and
take up a position in the asm template numbering as is usual &#8211; they will simply
be constrained to always use the same register as the output they&#8217;ve been tied
to. For example, a constraint string of &#8220;<code class="docutils literal"><span class="pre">=r,0</span></code>&#8221; says to assign a register for
output, and use that register as an input as well (it being the 0&#8217;th
constraint).</p>
<p>It is permitted to tie an input to an &#8220;early-clobber&#8221; output. In that case, no
<em>other</em> input may share the same register as the input tied to the early-clobber
(even when the other input has the same value).</p>
<p>You may only tie an input to an output which has a register constraint, not a
memory constraint. Only a single input may be tied to an output.</p>
<p>There is also an &#8220;interesting&#8221; feature which deserves a bit of explanation: if a
register class constraint allocates a register which is too small for the value
type operand provided as input, the input value will be split into multiple
registers, and all of them passed to the inline asm.</p>
<p>However, this feature is often not as useful as you might think.</p>
<p>Firstly, the registers are <em>not</em> guaranteed to be consecutive. So, on those
architectures that have instructions which operate on multiple consecutive
instructions, this is not an appropriate way to support them. (e.g. the 32-bit
SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The
hardware then loads into both the named register, and the next register. This
feature of inline asm would not be useful to support that.)</p>
<p>A few of the targets provide a template string modifier allowing explicit access
to the second register of a two-register operand (e.g. MIPS <code class="docutils literal"><span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">M</span></code>, and
<code class="docutils literal"><span class="pre">D</span></code>). On such an architecture, you can actually access the second allocated
register (yet, still, not any subsequent ones). But, in that case, you&#8217;re still
probably better off simply splitting the value into two separate operands, for
clarity. (e.g. see the description of the <code class="docutils literal"><span class="pre">A</span></code> constraint on X86, which,
despite existing only for use with this feature, is not really a good idea to
use)</p>
</div>
<div class="section" id="indirect-inputs-and-outputs">
<h5><a class="toc-backref" href="#id718">Indirect inputs and outputs</a><a class="headerlink" href="#indirect-inputs-and-outputs" title="永久链接至标题">¶</a></h5>
<p>Indirect output or input constraints can be specified by the &#8220;<code class="docutils literal"><span class="pre">*</span></code>&#8221; modifier
(which goes after the &#8220;<code class="docutils literal"><span class="pre">=</span></code>&#8221; in case of an output). This indicates that the asm
will write to or read from the contents of an <em>address</em> provided as an input
argument. (Note that in this way, indirect outputs act more like an <em>input</em> than
an output: just like an input, they consume an argument of the call expression,
rather than producing a return value. An indirect output constraint is an
&#8220;output&#8221; only in that the asm is expected to write to the contents of the input
memory location, instead of just read from it).</p>
<p>This is most typically used for memory constraint, e.g. &#8220;<code class="docutils literal"><span class="pre">=*m</span></code>&#8221;, to pass the
address of a variable as a value.</p>
<p>It is also possible to use an indirect <em>register</em> constraint, but only on output
(e.g. &#8220;<code class="docutils literal"><span class="pre">=*r</span></code>&#8221;). This will cause LLVM to allocate a register for an output
value normally, and then, separately emit a store to the address provided as
input, after the provided inline asm. (It&#8217;s not clear what value this
functionality provides, compared to writing the store explicitly after the asm
statement, and it can only produce worse code, since it bypasses many
optimization passes. I would recommend not using it.)</p>
</div>
<div class="section" id="clobber-constraints">
<h5><a class="toc-backref" href="#id719">Clobber constraints</a><a class="headerlink" href="#clobber-constraints" title="永久链接至标题">¶</a></h5>
<p>A clobber constraint is indicated by a &#8220;<code class="docutils literal"><span class="pre">~</span></code>&#8221; prefix. A clobber does not
consume an input operand, nor generate an output. Clobbers cannot use any of the
general constraint code letters &#8211; they may use only explicit register
constraints, e.g. &#8220;<code class="docutils literal"><span class="pre">~{eax}</span></code>&#8221;. The one exception is that a clobber string of
&#8220;<code class="docutils literal"><span class="pre">~{memory}</span></code>&#8221; indicates that the assembly writes to arbitrary undeclared
memory locations &#8211; not only the memory pointed to by a declared indirect
output.</p>
</div>
<div class="section" id="constraint-codes">
<h5><a class="toc-backref" href="#id720">Constraint Codes</a><a class="headerlink" href="#constraint-codes" title="永久链接至标题">¶</a></h5>
<p>After a potential prefix comes constraint code, or codes.</p>
<p>A Constraint Code is either a single letter (e.g. &#8220;<code class="docutils literal"><span class="pre">r</span></code>&#8221;), a &#8220;<code class="docutils literal"><span class="pre">^</span></code>&#8221; character
followed by two letters (e.g. &#8220;<code class="docutils literal"><span class="pre">^wc</span></code>&#8221;), or &#8220;<code class="docutils literal"><span class="pre">{</span></code>&#8221; register-name &#8220;<code class="docutils literal"><span class="pre">}</span></code>&#8221;
(e.g. &#8220;<code class="docutils literal"><span class="pre">{eax}</span></code>&#8221;).</p>
<p>The one and two letter constraint codes are typically chosen to be the same as
GCC&#8217;s constraint codes.</p>
<p>A single constraint may include one or more than constraint code in it, leaving
it up to LLVM to choose which one to use. This is included mainly for
compatibility with the translation of GCC inline asm coming from clang.</p>
<p>There are two ways to specify alternatives, and either or both may be used in an
inline asm constraint list:</p>
<ol class="arabic simple">
<li>Append the codes to each other, making a constraint code set. E.g. &#8220;<code class="docutils literal"><span class="pre">im</span></code>&#8221;
or &#8220;<code class="docutils literal"><span class="pre">{eax}m</span></code>&#8221;. This means &#8220;choose any of the options in the set&#8221;. The
choice of constraint is made independently for each constraint in the
constraint list.</li>
<li>Use &#8220;<code class="docutils literal"><span class="pre">|</span></code>&#8221; between constraint code sets, creating alternatives. Every
constraint in the constraint list must have the same number of alternative
sets. With this syntax, the same alternative in <em>all</em> of the items in the
constraint list will be chosen together.</li>
</ol>
<p>Putting those together, you might have a two operand constraint string like
<code class="docutils literal"><span class="pre">&quot;rm|r,ri|rm&quot;</span></code>. This indicates that if operand 0 is <code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">m</span></code>, then
operand 1 may be one of <code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">i</span></code>. If operand 0 is <code class="docutils literal"><span class="pre">r</span></code>, then operand 1
may be one of <code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">m</span></code>. But, operand 0 and 1 cannot both be of type m.</p>
<p>However, the use of either of the alternatives features is <em>NOT</em> recommended, as
LLVM is not able to make an intelligent choice about which one to use. (At the
point it currently needs to choose, not enough information is available to do so
in a smart way.) Thus, it simply tries to make a choice that&#8217;s most likely to
compile, not one that will be optimal performance. (e.g., given &#8220;<code class="docutils literal"><span class="pre">rm</span></code>&#8221;, it&#8217;ll
always choose to use memory, not registers). And, if given multiple registers,
or multiple register classes, it will simply choose the first one. (In fact, it
doesn&#8217;t currently even ensure explicitly specified physical registers are
unique, so specifying multiple physical registers as alternatives, like
<code class="docutils literal"><span class="pre">{r11}{r12},{r11}{r12}</span></code>, will assign r11 to both operands, not at all what was
intended.)</p>
</div>
<div class="section" id="supported-constraint-code-list">
<h5><a class="toc-backref" href="#id721">Supported Constraint Code List</a><a class="headerlink" href="#supported-constraint-code-list" title="永久链接至标题">¶</a></h5>
<p>The constraint codes are, in general, expected to behave the same way they do in
GCC. LLVM&#8217;s support is often implemented on an &#8216;as-needed&#8217; basis, to support C
inline asm code which was supported by GCC. A mismatch in behavior between LLVM
and GCC likely indicates a bug in LLVM.</p>
<p>Some constraint codes are typically supported by all targets:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: A register in the target&#8217;s general purpose register class.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: A memory address operand. It is target-specific what addressing modes
are supported, typical examples are register, or register + register offset,
or register + immediate offset (of some target-specific size).</li>
<li><code class="docutils literal"><span class="pre">i</span></code>: An integer constant (of target-specific width). Allows either a simple
immediate, or a relocatable value.</li>
<li><code class="docutils literal"><span class="pre">n</span></code>: An integer constant &#8211; <em>not</em> including relocatable values.</li>
<li><code class="docutils literal"><span class="pre">s</span></code>: An integer constant, but allowing <em>only</em> relocatable values.</li>
<li><code class="docutils literal"><span class="pre">X</span></code>: Allows an operand of any kind, no constraint whatsoever. Typically
useful to pass a label for an asm branch or call.</li>
<li><code class="docutils literal"><span class="pre">{register-name}</span></code>: Requires exactly the named physical register.</li>
</ul>
<p>Other constraints are target-specific:</p>
<p>AArch64:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">z</span></code>: An immediate integer 0. Outputs <code class="docutils literal"><span class="pre">WZR</span></code> or <code class="docutils literal"><span class="pre">XZR</span></code>, as appropriate.</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer valid for an <code class="docutils literal"><span class="pre">ADD</span></code> or <code class="docutils literal"><span class="pre">SUB</span></code> instruction,
i.e. 0 to 4095 with optional shift by 12.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer that, when negated, is valid for an <code class="docutils literal"><span class="pre">ADD</span></code> or
<code class="docutils literal"><span class="pre">SUB</span></code> instruction, i.e. -1 to -4095 with optional left shift by 12.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate integer that is valid for the &#8216;bitmask immediate 32&#8217; of a
logical instruction like <code class="docutils literal"><span class="pre">AND</span></code>, <code class="docutils literal"><span class="pre">EOR</span></code>, or <code class="docutils literal"><span class="pre">ORR</span></code> with a 32-bit register.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer that is valid for the &#8216;bitmask immediate 64&#8217; of a
logical instruction like <code class="docutils literal"><span class="pre">AND</span></code>, <code class="docutils literal"><span class="pre">EOR</span></code>, or <code class="docutils literal"><span class="pre">ORR</span></code> with a 64-bit register.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer for use with the <code class="docutils literal"><span class="pre">MOV</span></code> assembly alias on a
32-bit register. This is a superset of <code class="docutils literal"><span class="pre">K</span></code>: in addition to the bitmask
immediate, also allows immediate integers which can be loaded with a single
<code class="docutils literal"><span class="pre">MOVZ</span></code> or <code class="docutils literal"><span class="pre">MOVL</span></code> instruction.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer for use with the <code class="docutils literal"><span class="pre">MOV</span></code> assembly alias on a
64-bit register. This is a superset of <code class="docutils literal"><span class="pre">L</span></code>.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>: Memory address operand must be in a single register (no
offsets). (However, LLVM currently does this for the <code class="docutils literal"><span class="pre">m</span></code> constraint as
well.)</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit integer register (W* or X*).</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: A 32, 64, or 128-bit floating-point/SIMD register.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: A lower 128-bit floating-point/SIMD register (<code class="docutils literal"><span class="pre">V0</span></code> to <code class="docutils literal"><span class="pre">V15</span></code>).</li>
</ul>
<p>AMDGPU:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">[0-9]v</span></code>: The 32-bit VGPR register, number 0-9.</li>
<li><code class="docutils literal"><span class="pre">[0-9]s</span></code>: The 32-bit SGPR register, number 0-9.</li>
</ul>
<p>All ARM modes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">Um</span></code>, <code class="docutils literal"><span class="pre">Un</span></code>, <code class="docutils literal"><span class="pre">Uq</span></code>, <code class="docutils literal"><span class="pre">Us</span></code>, <code class="docutils literal"><span class="pre">Ut</span></code>, <code class="docutils literal"><span class="pre">Uv</span></code>, <code class="docutils literal"><span class="pre">Uy</span></code>: Memory address
operand. Treated the same as operand <code class="docutils literal"><span class="pre">m</span></code>, at the moment.</li>
</ul>
<p>ARM and ARM&#8217;s Thumb2 mode:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">j</span></code>: An immediate integer between 0 and 65535 (valid for <code class="docutils literal"><span class="pre">MOVW</span></code>)</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer valid for a data-processing instruction.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer between -4095 and 4095.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate integer whose bitwise inverse is valid for a
data-processing instruction. (Can be used with template modifier &#8220;<code class="docutils literal"><span class="pre">B</span></code>&#8221; to
print the inverted value).</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer whose negation is valid for a data-processing
instruction. (Can be used with template modifier &#8220;<code class="docutils literal"><span class="pre">n</span></code>&#8221; to print the negated
value).</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: A power of two or a integer between 0 and 32.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: Invalid immediate constraint.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: Invalid immediate constraint.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A general-purpose 32-bit integer register (<code class="docutils literal"><span class="pre">r0-r15</span></code>).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: In Thumb2 mode, low 32-bit GPR registers (<code class="docutils literal"><span class="pre">r0-r7</span></code>). In ARM mode, same
as <code class="docutils literal"><span class="pre">r</span></code>.</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: In Thumb2 mode, a high 32-bit GPR register (<code class="docutils literal"><span class="pre">r8-r15</span></code>). In ARM mode,
invalid.</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s31</span></code>,
<code class="docutils literal"><span class="pre">d0-d31</span></code>, or <code class="docutils literal"><span class="pre">q0-q15</span></code>.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s15</span></code>,
<code class="docutils literal"><span class="pre">d0-d7</span></code>, or <code class="docutils literal"><span class="pre">q0-q3</span></code>.</li>
<li><code class="docutils literal"><span class="pre">t</span></code>: A floating-point/SIMD register, only supports 32-bit values:
<code class="docutils literal"><span class="pre">s0-s31</span></code>.</li>
</ul>
<p>ARM&#8217;s Thumb1 mode:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer between 0 and 255.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer between -255 and -1.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate integer between 0 and 255, with optional left-shift by
some amount.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer between -7 and 7.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer which is a multiple of 4 between 0 and 1020.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer between 0 and 31.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: An immediate integer which is a multiple of 4 between -508 and 508.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A low 32-bit GPR register (<code class="docutils literal"><span class="pre">r0-r7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: A low 32-bit GPR register (<code class="docutils literal"><span class="pre">r0-r7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: A high GPR register (<code class="docutils literal"><span class="pre">r0-r7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s31</span></code>,
<code class="docutils literal"><span class="pre">d0-d31</span></code>, or <code class="docutils literal"><span class="pre">q0-q15</span></code>.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: A 32, 64, or 128-bit floating-point/SIMD register: <code class="docutils literal"><span class="pre">s0-s15</span></code>,
<code class="docutils literal"><span class="pre">d0-d7</span></code>, or <code class="docutils literal"><span class="pre">q0-q3</span></code>.</li>
<li><code class="docutils literal"><span class="pre">t</span></code>: A floating-point/SIMD register, only supports 32-bit values:
<code class="docutils literal"><span class="pre">s0-s31</span></code>.</li>
</ul>
<p>Hexagon:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">o</span></code>, <code class="docutils literal"><span class="pre">v</span></code>: A memory address operand, treated the same as constraint <code class="docutils literal"><span class="pre">m</span></code>,
at the moment.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit register.</li>
</ul>
<p>MSP430:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: An 8 or 16-bit register.</li>
</ul>
<p>MIPS:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate signed 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer zero.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate unsigned 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate 32-bit integer, where the lower 16 bits are 0.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer between -65535 and -1.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: An immediate signed 15-bit integer.</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: An immediate integer between 1 and 65535.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: A memory address operand. In MIPS-SE mode, allows a base address
register plus 16-bit immediate offset. In MIPS mode, just a base register.</li>
<li><code class="docutils literal"><span class="pre">R</span></code>: A memory address operand. In MIPS-SE mode, allows a base address
register plus a 9-bit signed offset. In MIPS mode, the same as constraint
<code class="docutils literal"><span class="pre">m</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ZC</span></code>: A memory address operand, suitable for use in a <code class="docutils literal"><span class="pre">pref</span></code>, <code class="docutils literal"><span class="pre">ll</span></code>, or
<code class="docutils literal"><span class="pre">sc</span></code> instruction on the given subtarget (details vary).</li>
<li><code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">d</span></code>,  <code class="docutils literal"><span class="pre">y</span></code>: A 32 or 64-bit GPR register.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32 or 64-bit FPU register (<code class="docutils literal"><span class="pre">F0-F31</span></code>), or a 128-bit MSA register
(<code class="docutils literal"><span class="pre">W0-W31</span></code>). In the case of MSA registers, it is recommended to use the <code class="docutils literal"><span class="pre">w</span></code>
argument modifier for compatibility with GCC.</li>
<li><code class="docutils literal"><span class="pre">c</span></code>: A 32-bit or 64-bit GPR register suitable for indirect jump (always
<code class="docutils literal"><span class="pre">25</span></code>).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: The <code class="docutils literal"><span class="pre">lo</span></code> register, 32 or 64-bit.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Invalid.</li>
</ul>
<p>NVPTX:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">b</span></code>: A 1-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">c</span></code> or <code class="docutils literal"><span class="pre">h</span></code>: A 16-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">l</span></code> or <code class="docutils literal"><span class="pre">N</span></code>: A 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32-bit float register.</li>
<li><code class="docutils literal"><span class="pre">d</span></code>: A 64-bit float register.</li>
</ul>
<p>PowerPC:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate signed 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate unsigned 16-bit integer, shifted left 16 bits.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate unsigned 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate signed 16-bit integer, shifted left 16 bits.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer greater than 31.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate integer that is an exact power of 2.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: The immediate integer constant 0.</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: An immediate integer constant whose negation is a signed 16-bit
constant.</li>
<li><code class="docutils literal"><span class="pre">es</span></code>, <code class="docutils literal"><span class="pre">o</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">Z</span></code>, <code class="docutils literal"><span class="pre">Zy</span></code>: A memory address operand, currently
treated the same as <code class="docutils literal"><span class="pre">m</span></code>.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32 or 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">b</span></code>: A 32 or 64-bit integer register, excluding <code class="docutils literal"><span class="pre">R0</span></code> (that is:
<code class="docutils literal"><span class="pre">R1-R31</span></code>).</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32 or 64-bit float register (<code class="docutils literal"><span class="pre">F0-F31</span></code>), or when QPX is enabled, a
128 or 256-bit QPX register (<code class="docutils literal"><span class="pre">Q0-Q31</span></code>; aliases the <code class="docutils literal"><span class="pre">F</span></code> registers).</li>
<li><code class="docutils literal"><span class="pre">v</span></code>: For <code class="docutils literal"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">f32</span></code> or <code class="docutils literal"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">f64</span></code> types, when QPX is enabled, a
128 or 256-bit QPX register (<code class="docutils literal"><span class="pre">Q0-Q31</span></code>), otherwise a 128-bit
altivec vector register (<code class="docutils literal"><span class="pre">V0-V31</span></code>).</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: Condition register (<code class="docutils literal"><span class="pre">CR0-CR7</span></code>).</li>
<li><code class="docutils literal"><span class="pre">wc</span></code>: An individual CR bit in a CR register.</li>
<li><code class="docutils literal"><span class="pre">wa</span></code>, <code class="docutils literal"><span class="pre">wd</span></code>, <code class="docutils literal"><span class="pre">wf</span></code>: Any 128-bit VSX vector register, from the full VSX
register set (overlapping both the floating-point and vector register files).</li>
<li><code class="docutils literal"><span class="pre">ws</span></code>: A 32 or 64-bit floating point register, from the full VSX register
set.</li>
</ul>
<p>Sparc:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate 13-bit signed integer.</li>
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32-bit integer register.</li>
</ul>
<p>SystemZ:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate unsigned 8-bit integer.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate unsigned 12-bit integer.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate signed 16-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate signed 20-bit integer.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer 0x7fffffff.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">T</span></code>: A memory address operand, treated the same as
<code class="docutils literal"><span class="pre">m</span></code>, at the moment.</li>
<li><code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">d</span></code>: A 32, 64, or 128-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">a</span></code>: A 32, 64, or 128-bit integer address register (excludes R0, which in an
address context evaluates as zero).</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: A 32-bit value in the high part of a 64bit data register
(LLVM-specific)</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32, 64, or 128-bit floating point register.</li>
</ul>
<p>X86:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">I</span></code>: An immediate integer between 0 and 31.</li>
<li><code class="docutils literal"><span class="pre">J</span></code>: An immediate integer between 0 and 64.</li>
<li><code class="docutils literal"><span class="pre">K</span></code>: An immediate signed 8-bit integer.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: An immediate integer, 0xff or 0xffff or (in 64-bit mode only)
0xffffffff.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: An immediate integer between 0 and 3.</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: An immediate unsigned 8-bit integer.</li>
<li><code class="docutils literal"><span class="pre">O</span></code>: An immediate integer between 0 and 127.</li>
<li><code class="docutils literal"><span class="pre">e</span></code>: An immediate 32-bit signed integer.</li>
<li><code class="docutils literal"><span class="pre">Z</span></code>: An immediate 32-bit unsigned integer.</li>
<li><code class="docutils literal"><span class="pre">o</span></code>, <code class="docutils literal"><span class="pre">v</span></code>: Treated the same as <code class="docutils literal"><span class="pre">m</span></code>, at the moment.</li>
<li><code class="docutils literal"><span class="pre">q</span></code>: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit
<code class="docutils literal"><span class="pre">l</span></code> integer register. On X86-32, this is the <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code>, and <code class="docutils literal"><span class="pre">d</span></code>
registers, and on X86-64, it is all of the integer registers.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit
<code class="docutils literal"><span class="pre">h</span></code> integer register. This is the <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code>, and <code class="docutils literal"><span class="pre">d</span></code> registers.</li>
<li><code class="docutils literal"><span class="pre">r</span></code> or <code class="docutils literal"><span class="pre">l</span></code>: An 8, 16, 32, or 64-bit integer register.</li>
<li><code class="docutils literal"><span class="pre">R</span></code>: An 8, 16, 32, or 64-bit &#8220;legacy&#8221; integer register &#8211; one which has
existed since i386, and can be accessed without the REX prefix.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: A 32, 64, or 80-bit &#8216;387 FPU stack pseudo-register.</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: A 64-bit MMX register, if MMX is enabled.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector
operand in a SSE register. If AVX is also enabled, can also be a 256-bit
vector operand in an AVX register. If AVX-512 is also enabled, can also be a
512-bit vector operand in an AVX512 register, Otherwise, an error.</li>
<li><code class="docutils literal"><span class="pre">Y</span></code>: The same as <code class="docutils literal"><span class="pre">x</span></code>, if <em>SSE2</em> is enabled, otherwise an error.</li>
<li><code class="docutils literal"><span class="pre">A</span></code>: Special case: allocates EAX first, then EDX, for a single operand (in
32-bit mode, a 64-bit integer operand will get split into two registers). It
is not recommended to use this constraint, as in 64-bit mode, the 64-bit
operand will get allocated only to RAX &#8211; if two 32-bit operands are needed,
you&#8217;re better off splitting it yourself, before passing it to the asm
statement.</li>
</ul>
<p>XCore:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: A 32-bit integer register.</li>
</ul>
</div>
</div>
<div class="section" id="asm-template-argument-modifiers">
<span id="inline-asm-modifiers"></span><h4><a class="toc-backref" href="#id722">Asm template argument modifiers</a><a class="headerlink" href="#asm-template-argument-modifiers" title="永久链接至标题">¶</a></h4>
<p>In the asm template string, modifiers can be used on the operand reference, like
&#8220;<code class="docutils literal"><span class="pre">${0:n}</span></code>&#8221;.</p>
<p>The modifiers are, in general, expected to behave the same way they do in
GCC. LLVM&#8217;s support is often implemented on an &#8216;as-needed&#8217; basis, to support C
inline asm code which was supported by GCC. A mismatch in behavior between LLVM
and GCC likely indicates a bug in LLVM.</p>
<p>Target-independent:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">c</span></code>: Print an immediate integer constant unadorned, without
the target-specific immediate punctuation (e.g. no <code class="docutils literal"><span class="pre">$</span></code> prefix).</li>
<li><code class="docutils literal"><span class="pre">n</span></code>: Negate and print immediate integer constant unadorned, without the
target-specific immediate punctuation (e.g. no <code class="docutils literal"><span class="pre">$</span></code> prefix).</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: Print as an unadorned label, without the target-specific label
punctuation (e.g. no <code class="docutils literal"><span class="pre">$</span></code> prefix).</li>
</ul>
<p>AArch64:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">w</span></code>: Print a GPR register with a <code class="docutils literal"><span class="pre">w*</span></code> name instead of <code class="docutils literal"><span class="pre">x*</span></code> name. E.g.,
instead of <code class="docutils literal"><span class="pre">x30</span></code>, print <code class="docutils literal"><span class="pre">w30</span></code>.</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Print a GPR register with a <code class="docutils literal"><span class="pre">x*</span></code> name. (this is the default, anyhow).</li>
<li><code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, <code class="docutils literal"><span class="pre">q</span></code>: Print a floating-point/SIMD register with a
<code class="docutils literal"><span class="pre">b*</span></code>, <code class="docutils literal"><span class="pre">h*</span></code>, <code class="docutils literal"><span class="pre">s*</span></code>, <code class="docutils literal"><span class="pre">d*</span></code>, or <code class="docutils literal"><span class="pre">q*</span></code> name, rather than the default of
<code class="docutils literal"><span class="pre">v*</span></code>.</li>
</ul>
<p>AMDGPU:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: No effect.</li>
</ul>
<p>ARM:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">a</span></code>: Print an operand as an address (with <code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code> surrounding a
register).</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: No effect.</li>
<li><code class="docutils literal"><span class="pre">q</span></code>: No effect.</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: Print a VFP single-precision register as an indexed double (e.g. print
as <code class="docutils literal"><span class="pre">d4[1]</span></code> instead of <code class="docutils literal"><span class="pre">s9</span></code>)</li>
<li><code class="docutils literal"><span class="pre">B</span></code>: Bitwise invert and print an immediate integer constant without <code class="docutils literal"><span class="pre">#</span></code>
prefix.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the low 16-bits of an immediate integer constant.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: Print as a register set suitable for ldm/stm. Also prints <em>all</em>
register operands subsequent to the specified one (!), so use carefully.</li>
<li><code class="docutils literal"><span class="pre">Q</span></code>: Print the low-order register of a register-pair, or the low-order
register of a two-register operand.</li>
<li><code class="docutils literal"><span class="pre">R</span></code>: Print the high-order register of a register-pair, or the high-order
register of a two-register operand.</li>
<li><code class="docutils literal"><span class="pre">H</span></code>: Print the second register of a register-pair. (On a big-endian system,
<code class="docutils literal"><span class="pre">H</span></code> is equivalent to <code class="docutils literal"><span class="pre">Q</span></code>, and on little-endian system, <code class="docutils literal"><span class="pre">H</span></code> is equivalent
to <code class="docutils literal"><span class="pre">R</span></code>.)</li>
<li><code class="docutils literal"><span class="pre">e</span></code>: Print the low doubleword register of a NEON quad register.</li>
<li><code class="docutils literal"><span class="pre">f</span></code>: Print the high doubleword register of a NEON quad register.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: Print the base register of a memory operand without the <code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code>
adornment.</li>
</ul>
<p>Hexagon:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the second register of a two-register operand. Requires that it
has been allocated consecutively to the first.</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: Print the letter &#8216;i&#8217; if the operand is an integer constant, otherwise
nothing. Used to print &#8216;addi&#8217; vs &#8216;add&#8217; instructions.</li>
</ul>
<p>MSP430:</p>
<p>No additional modifiers.</p>
<p>MIPS:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code>: Print an immediate integer as hexadecimal</li>
<li><code class="docutils literal"><span class="pre">x</span></code>: Print the low 16 bits of an immediate integer as hexadecimal.</li>
<li><code class="docutils literal"><span class="pre">d</span></code>: Print an immediate integer as decimal.</li>
<li><code class="docutils literal"><span class="pre">m</span></code>: Subtract one and print an immediate integer as decimal.</li>
<li><code class="docutils literal"><span class="pre">z</span></code>: Print $0 if an immediate zero, otherwise print normally.</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the low-order register of a two-register operand, or prints the
address of the low-order word of a double-word memory operand.</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: Print the high-order register of a two-register operand, or prints the
address of the high-order word of a double-word memory operand.</li>
<li><code class="docutils literal"><span class="pre">D</span></code>: Print the second register of a two-register operand, or prints the
second word of a double-word memory operand. (On a big-endian system, <code class="docutils literal"><span class="pre">D</span></code> is
equivalent to <code class="docutils literal"><span class="pre">L</span></code>, and on little-endian system, <code class="docutils literal"><span class="pre">D</span></code> is equivalent to
<code class="docutils literal"><span class="pre">M</span></code>.)</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: No effect. Provided for compatibility with GCC which requires this
modifier in order to print MSA registers (<code class="docutils literal"><span class="pre">W0-W31</span></code>) with the <code class="docutils literal"><span class="pre">f</span></code>
constraint.</li>
</ul>
<p>NVPTX:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: No effect.</li>
</ul>
<p>PowerPC:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">L</span></code>: Print the second register of a two-register operand. Requires that it
has been allocated consecutively to the first.</li>
<li><code class="docutils literal"><span class="pre">I</span></code>: Print the letter &#8216;i&#8217; if the operand is an integer constant, otherwise
nothing. Used to print &#8216;addi&#8217; vs &#8216;add&#8217; instructions.</li>
<li><code class="docutils literal"><span class="pre">y</span></code>: For a memory operand, prints formatter for a two-register X-form
instruction. (Currently always prints <code class="docutils literal"><span class="pre">r0,OPERAND</span></code>).</li>
<li><code class="docutils literal"><span class="pre">U</span></code>: Prints &#8216;u&#8217; if the memory operand is an update form, and nothing
otherwise. (NOTE: LLVM does not support update form, so this will currently
always print nothing)</li>
<li><code class="docutils literal"><span class="pre">X</span></code>: Prints &#8216;x&#8217; if the memory operand is an indexed form. (NOTE: LLVM does
not support indexed form, so this will currently always print nothing)</li>
</ul>
<p>Sparc:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">r</span></code>: No effect.</li>
</ul>
<p>SystemZ:</p>
<p>SystemZ implements only <code class="docutils literal"><span class="pre">n</span></code>, and does <em>not</em> support any of the other
target-independent modifiers.</p>
<p>X86:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">c</span></code>: Print an unadorned integer or symbol name. (The latter is
target-specific behavior for this typically target-independent modifier).</li>
<li><code class="docutils literal"><span class="pre">A</span></code>: Print a register name with a &#8216;<code class="docutils literal"><span class="pre">*</span></code>&#8216; before it.</li>
<li><code class="docutils literal"><span class="pre">b</span></code>: Print an 8-bit register name (e.g. <code class="docutils literal"><span class="pre">al</span></code>); do nothing on a memory
operand.</li>
<li><code class="docutils literal"><span class="pre">h</span></code>: Print the upper 8-bit register name (e.g. <code class="docutils literal"><span class="pre">ah</span></code>); do nothing on a
memory operand.</li>
<li><code class="docutils literal"><span class="pre">w</span></code>: Print the 16-bit register name (e.g. <code class="docutils literal"><span class="pre">ax</span></code>); do nothing on a memory
operand.</li>
<li><code class="docutils literal"><span class="pre">k</span></code>: Print the 32-bit register name (e.g. <code class="docutils literal"><span class="pre">eax</span></code>); do nothing on a memory
operand.</li>
<li><code class="docutils literal"><span class="pre">q</span></code>: Print the 64-bit register name (e.g. <code class="docutils literal"><span class="pre">rax</span></code>), if 64-bit registers are
available, otherwise the 32-bit register name; do nothing on a memory operand.</li>
<li><code class="docutils literal"><span class="pre">n</span></code>: Negate and print an unadorned integer, or, for operands other than an
immediate integer (e.g. a relocatable symbol expression), print a &#8216;-&#8216; before
the operand. (The behavior for relocatable symbol expressions is a
target-specific behavior for this typically target-independent modifier)</li>
<li><code class="docutils literal"><span class="pre">H</span></code>: Print a memory reference with additional offset +8.</li>
<li><code class="docutils literal"><span class="pre">P</span></code>: Print a memory reference or operand for use as the argument of a call
instruction. (E.g. omit <code class="docutils literal"><span class="pre">(rip)</span></code>, even though it&#8217;s PC-relative.)</li>
</ul>
<p>XCore:</p>
<p>No additional modifiers.</p>
</div>
<div class="section" id="inline-asm-metadata">
<h4><a class="toc-backref" href="#id723">Inline Asm Metadata</a><a class="headerlink" href="#inline-asm-metadata" title="永久链接至标题">¶</a></h4>
<p>The call instructions that wrap inline asm nodes may have a
&#8220;<code class="docutils literal"><span class="pre">!srcloc</span></code>&#8221; MDNode attached to it that contains a list of constant
integers. If present, the code generator will use the integer as the
location cookie value when report errors through the <code class="docutils literal"><span class="pre">LLVMContext</span></code>
error reporting mechanisms. This allows a front-end to correlate backend
errors that occur with inline asm back to the source code that produced
it. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="k">asm</span> <span class="k">sideeffect</span> <span class="s">&quot;something bad&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">(),</span> <span class="nv">!srcloc</span> <span class="nv nv-Anonymous">!42</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!42</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">1234567</span> <span class="p">}</span>
</pre></div>
</div>
<p>It is up to the front-end to make sense of the magic numbers it places
in the IR. If the MDNode contains multiple constants, the code generator
will use the one that corresponds to the line of the asm that the error
occurs on.</p>
</div>
</div>
</div>
<div class="section" id="metadata">
<span id="id4"></span><h2><a class="toc-backref" href="#id724">Metadata</a><a class="headerlink" href="#metadata" title="永久链接至标题">¶</a></h2>
<p>LLVM IR allows metadata to be attached to instructions in the program
that can convey extra information about the code to the optimizers and
code generator. One example application of metadata is source-level
debug information. There are two metadata primitives: strings and nodes.</p>
<p>Metadata does not have a type, and is not a value. If referenced from a
<code class="docutils literal"><span class="pre">call</span></code> instruction, it uses the <code class="docutils literal"><span class="pre">metadata</span></code> type.</p>
<p>All metadata are identified in syntax by a exclamation point (&#8216;<code class="docutils literal"><span class="pre">!</span></code>&#8216;).</p>
<div class="section" id="metadata-nodes-and-metadata-strings">
<span id="metadata-string"></span><h3><a class="toc-backref" href="#id725">Metadata Nodes and Metadata Strings</a><a class="headerlink" href="#metadata-nodes-and-metadata-strings" title="永久链接至标题">¶</a></h3>
<p>A metadata string is a string surrounded by double quotes. It can
contain any character by escaping non-printable characters with
&#8220;<code class="docutils literal"><span class="pre">\xx</span></code>&#8221; where &#8220;<code class="docutils literal"><span class="pre">xx</span></code>&#8221; is the two digit hex code. For example:
&#8220;<code class="docutils literal"><span class="pre">!&quot;test\00&quot;</span></code>&#8221;.</p>
<p>Metadata nodes are represented with notation similar to structure
constants (a comma separated list of elements, surrounded by braces and
preceded by an exclamation point). Metadata nodes can have any values as
their operand. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="p">!{</span> <span class="nv">!&quot;test\00&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">10</span><span class="p">}</span>
</pre></div>
</div>
<p>Metadata nodes that aren&#8217;t uniqued use the <code class="docutils literal"><span class="pre">distinct</span></code> keyword. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = distinct !{!&quot;test\00&quot;, i32 10}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">distinct</span></code> nodes are useful when nodes shouldn&#8217;t be merged based on their
content. They can also occur when transformations cause uniquing collisions
when metadata operands change.</p>
<p>A <a class="reference internal" href="#namedmetadatastructure"><span class="std std-ref">named metadata</span></a> is a collection of
metadata nodes, which can be looked up in the module symbol table. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">!foo</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nv nv-Anonymous">!3</span><span class="p">}</span>
</pre></div>
</div>
<p>Metadata can be used as function arguments. Here <code class="docutils literal"><span class="pre">llvm.dbg.value</span></code>
function is using two metadata arguments:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="kt">metadata</span> <span class="nv nv-Anonymous">!24</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="kt">metadata</span> <span class="nv nv-Anonymous">!25</span><span class="p">)</span>
</pre></div>
</div>
<p>Metadata can be attached to an instruction. Here metadata <code class="docutils literal"><span class="pre">!21</span></code> is attached
to the <code class="docutils literal"><span class="pre">add</span></code> instruction using the <code class="docutils literal"><span class="pre">!dbg</span></code> identifier:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%indvar.next</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%indvar</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!21</span>
</pre></div>
</div>
<p>Metadata can also be attached to a function definition. Here metadata <code class="docutils literal"><span class="pre">!22</span></code>
is attached to the <code class="docutils literal"><span class="pre">foo</span></code> function using the <code class="docutils literal"><span class="pre">!dbg</span></code> identifier:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!22</span> <span class="p">{</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More information about specific metadata nodes recognized by the
optimizers and code generator is found below.</p>
<div class="section" id="specialized-metadata-nodes">
<span id="specialized-metadata"></span><h4><a class="toc-backref" href="#id726">Specialized Metadata Nodes</a><a class="headerlink" href="#specialized-metadata-nodes" title="永久链接至标题">¶</a></h4>
<p>Specialized metadata nodes are custom data structures in metadata (as opposed
to generic tuples). Their fields are labelled, and can be specified in any
order.</p>
<p>These aren&#8217;t inherently debug info centric, but currently all the specialized
metadata nodes are related to debug info.</p>
<div class="section" id="dicompileunit">
<span id="id5"></span><h5><a class="toc-backref" href="#id727">DICompileUnit</a><a class="headerlink" href="#dicompileunit" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DICompileUnit</span></code> nodes represent a compile unit. The <code class="docutils literal"><span class="pre">enums:</span></code>,
<code class="docutils literal"><span class="pre">retainedTypes:</span></code>, <code class="docutils literal"><span class="pre">subprograms:</span></code>, <code class="docutils literal"><span class="pre">globals:</span></code>, <code class="docutils literal"><span class="pre">imports:</span></code> and <code class="docutils literal"><span class="pre">macros:</span></code>
fields are tuples containing the debug info to be emitted along with the compile
unit, regardless of code optimizations (some nodes are only emitted if there are
references to them from instructions).</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: &quot;clang&quot;,
                    isOptimized: true, flags: &quot;-O2&quot;, runtimeVersion: 2,
                    splitDebugFilename: &quot;abc.debug&quot;, emissionKind: 1,
                    enums: !2, retainedTypes: !3, subprograms: !4,
                    globals: !5, imports: !6, macros: !7, dwoId: 0x0abcd)
</pre></div>
</div>
<p>Compile unit descriptors provide the root scope for objects declared in a
specific compilation unit. File descriptors are defined using this scope.
These descriptors are collected by a named metadata <code class="docutils literal"><span class="pre">!llvm.dbg.cu</span></code>. They
keep track of subprograms, global variables, type information, and imported
entities (declarations and namespaces).</p>
</div>
<div class="section" id="difile">
<span id="id6"></span><h5><a class="toc-backref" href="#id728">DIFile</a><a class="headerlink" href="#difile" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIFile</span></code> nodes represent files. The <code class="docutils literal"><span class="pre">filename:</span></code> can include slashes.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DIFile</span><span class="p">(</span><span class="nl">filename:</span> <span class="s">&quot;path/to/file&quot;</span><span class="p">,</span> <span class="nl">directory:</span> <span class="s">&quot;/path/to/dir&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Files are sometimes used in <code class="docutils literal"><span class="pre">scope:</span></code> fields, and are the only valid target
for <code class="docutils literal"><span class="pre">file:</span></code> fields.</p>
</div>
<div class="section" id="dibasictype">
<span id="id7"></span><h5><a class="toc-backref" href="#id729">DIBasicType</a><a class="headerlink" href="#dibasictype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIBasicType</span></code> nodes represent primitive types, such as <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">bool</span></code> and
<code class="docutils literal"><span class="pre">float</span></code>. <code class="docutils literal"><span class="pre">tag:</span></code> defaults to <code class="docutils literal"><span class="pre">DW_TAG_base_type</span></code>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIBasicType(name: &quot;unsigned char&quot;, size: 8, align: 8,
                  encoding: DW_ATE_unsigned_char)
!1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: &quot;decltype(nullptr)&quot;)
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">encoding:</span></code> describes the details of the type. Usually it&#8217;s one of the
following:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>DW_ATE_address       = 1
DW_ATE_boolean       = 2
DW_ATE_float         = 4
DW_ATE_signed        = 5
DW_ATE_signed_char   = 6
DW_ATE_unsigned      = 7
DW_ATE_unsigned_char = 8
</pre></div>
</div>
</div>
<div class="section" id="disubroutinetype">
<span id="id8"></span><h5><a class="toc-backref" href="#id730">DISubroutineType</a><a class="headerlink" href="#disubroutinetype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DISubroutineType</span></code> nodes represent subroutine types. Their <code class="docutils literal"><span class="pre">types:</span></code> field
refers to a tuple; the first operand is the return type, while the rest are the
types of the formal arguments in order. If the first operand is <code class="docutils literal"><span class="pre">null</span></code>, that
represents a function with no return value (such as <code class="docutils literal"><span class="pre">void</span> <span class="pre">foo()</span> <span class="pre">{}</span></code> in C++).</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !BasicType(name: &quot;int&quot;, size: 32, align: 32, DW_ATE_signed)
!1 = !BasicType(name: &quot;char&quot;, size: 8, align: 8, DW_ATE_signed_char)
!2 = !DISubroutineType(types: !{null, !0, !1}) ; void (int, char)
</pre></div>
</div>
</div>
<div class="section" id="diderivedtype">
<span id="id9"></span><h5><a class="toc-backref" href="#id731">DIDerivedType</a><a class="headerlink" href="#diderivedtype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIDerivedType</span></code> nodes represent types derived from other types, such as
qualified types.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIBasicType(name: &quot;unsigned char&quot;, size: 8, align: 8,
                  encoding: DW_ATE_unsigned_char)
!1 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !0, size: 32,
                    align: 32)
</pre></div>
</div>
<p>The following <code class="docutils literal"><span class="pre">tag:</span></code> values are valid:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>DW_TAG_formal_parameter   = 5
DW_TAG_member             = 13
DW_TAG_pointer_type       = 15
DW_TAG_reference_type     = 16
DW_TAG_typedef            = 22
DW_TAG_ptr_to_member_type = 31
DW_TAG_const_type         = 38
DW_TAG_volatile_type      = 53
DW_TAG_restrict_type      = 55
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">DW_TAG_member</span></code> is used to define a member of a <a class="reference internal" href="#dicompositetype"><span class="std std-ref">composite type</span></a> or <a class="reference internal" href="#disubprogram"><span class="std std-ref">subprogram</span></a>. The type of the member
is the <code class="docutils literal"><span class="pre">baseType:</span></code>. The <code class="docutils literal"><span class="pre">offset:</span></code> is the member&#8217;s bit offset.
<code class="docutils literal"><span class="pre">DW_TAG_formal_parameter</span></code> is used to define a member which is a formal
argument of a subprogram.</p>
<p><code class="docutils literal"><span class="pre">DW_TAG_typedef</span></code> is used to provide a name for the <code class="docutils literal"><span class="pre">baseType:</span></code>.</p>
<p><code class="docutils literal"><span class="pre">DW_TAG_pointer_type</span></code>, <code class="docutils literal"><span class="pre">DW_TAG_reference_type</span></code>, <code class="docutils literal"><span class="pre">DW_TAG_const_type</span></code>,
<code class="docutils literal"><span class="pre">DW_TAG_volatile_type</span></code> and <code class="docutils literal"><span class="pre">DW_TAG_restrict_type</span></code> are used to qualify the
<code class="docutils literal"><span class="pre">baseType:</span></code>.</p>
<p>Note that the <code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></code> type is expressed as a type derived from NULL.</p>
</div>
<div class="section" id="dicompositetype">
<span id="id10"></span><h5><a class="toc-backref" href="#id732">DICompositeType</a><a class="headerlink" href="#dicompositetype" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DICompositeType</span></code> nodes represent types composed of other types, like
structures and unions. <code class="docutils literal"><span class="pre">elements:</span></code> points to a tuple of the composed types.</p>
<p>If the source language supports ODR, the <code class="docutils literal"><span class="pre">identifier:</span></code> field gives the unique
identifier used for type merging between modules. When specified, other types
can refer to composite types indirectly via a <a class="reference internal" href="#metadata-string"><span class="std std-ref">metadata string</span></a> that matches their identifier.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIEnumerator(name: &quot;SixKind&quot;, value: 7)
!1 = !DIEnumerator(name: &quot;SevenKind&quot;, value: 7)
!2 = !DIEnumerator(name: &quot;NegEightKind&quot;, value: -8)
!3 = !DICompositeType(tag: DW_TAG_enumeration_type, name: &quot;Enum&quot;, file: !12,
                      line: 2, size: 32, align: 32, identifier: &quot;_M4Enum&quot;,
                      elements: !{!0, !1, !2})
</pre></div>
</div>
<p>The following <code class="docutils literal"><span class="pre">tag:</span></code> values are valid:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>DW_TAG_array_type       = 1
DW_TAG_class_type       = 2
DW_TAG_enumeration_type = 4
DW_TAG_structure_type   = 19
DW_TAG_union_type       = 23
DW_TAG_subroutine_type  = 21
DW_TAG_inheritance      = 28
</pre></div>
</div>
<p>For <code class="docutils literal"><span class="pre">DW_TAG_array_type</span></code>, the <code class="docutils literal"><span class="pre">elements:</span></code> should be <a class="reference internal" href="#disubrange"><span class="std std-ref">subrange
descriptors</span></a>, each representing the range of subscripts at that
level of indexing. The <code class="docutils literal"><span class="pre">DIFlagVector</span></code> flag to <code class="docutils literal"><span class="pre">flags:</span></code> indicates that an
array type is a native packed vector.</p>
<p>For <code class="docutils literal"><span class="pre">DW_TAG_enumeration_type</span></code>, the <code class="docutils literal"><span class="pre">elements:</span></code> should be <a class="reference internal" href="#dienumerator"><span class="std std-ref">enumerator
descriptors</span></a>, each representing the definition of an enumeration
value for the set. All enumeration type descriptors are collected in the
<code class="docutils literal"><span class="pre">enums:</span></code> field of the <a class="reference internal" href="#dicompileunit"><span class="std std-ref">compile unit</span></a>.</p>
<p>For <code class="docutils literal"><span class="pre">DW_TAG_structure_type</span></code>, <code class="docutils literal"><span class="pre">DW_TAG_class_type</span></code>, and
<code class="docutils literal"><span class="pre">DW_TAG_union_type</span></code>, the <code class="docutils literal"><span class="pre">elements:</span></code> should be <a class="reference internal" href="#diderivedtype"><span class="std std-ref">derived types</span></a> with <code class="docutils literal"><span class="pre">tag:</span> <span class="pre">DW_TAG_member</span></code> or <code class="docutils literal"><span class="pre">tag:</span> <span class="pre">DW_TAG_inheritance</span></code>.</p>
</div>
<div class="section" id="disubrange">
<span id="id11"></span><h5><a class="toc-backref" href="#id733">DISubrange</a><a class="headerlink" href="#disubrange" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DISubrange</span></code> nodes are the elements for <code class="docutils literal"><span class="pre">DW_TAG_array_type</span></code> variants of
<a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a>. <code class="docutils literal"><span class="pre">count:</span> <span class="pre">-1</span></code> indicates an empty array.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DISubrange</span><span class="p">(</span><span class="nl">count:</span> <span class="m">5</span><span class="p">,</span> <span class="nl">lowerBound:</span> <span class="m">0</span><span class="p">)</span> <span class="c">; array counting from 0</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="nv">!DISubrange</span><span class="p">(</span><span class="nl">count:</span> <span class="m">5</span><span class="p">,</span> <span class="nl">lowerBound:</span> <span class="m">1</span><span class="p">)</span> <span class="c">; array counting from 1</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="nv">!DISubrange</span><span class="p">(</span><span class="nl">count:</span> <span class="m">-1</span><span class="p">)</span> <span class="c">; empty array.</span>
</pre></div>
</div>
</div>
<div class="section" id="dienumerator">
<span id="id12"></span><h5><a class="toc-backref" href="#id734">DIEnumerator</a><a class="headerlink" href="#dienumerator" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIEnumerator</span></code> nodes are the elements for <code class="docutils literal"><span class="pre">DW_TAG_enumeration_type</span></code>
variants of <a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DIEnumerator</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;SixKind&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="m">7</span><span class="p">)</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="nv">!DIEnumerator</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;SevenKind&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="m">7</span><span class="p">)</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="nv">!DIEnumerator</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;NegEightKind&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="m">-8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ditemplatetypeparameter">
<h5><a class="toc-backref" href="#id735">DITemplateTypeParameter</a><a class="headerlink" href="#ditemplatetypeparameter" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DITemplateTypeParameter</span></code> nodes represent type parameters to generic source
language constructs. They are used (optionally) in <a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a> and
<a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a> <code class="docutils literal"><span class="pre">templateParams:</span></code> fields.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DITemplateTypeParameter</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;Ty&quot;</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ditemplatevalueparameter">
<h5><a class="toc-backref" href="#id736">DITemplateValueParameter</a><a class="headerlink" href="#ditemplatevalueparameter" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DITemplateValueParameter</span></code> nodes represent value parameters to generic source
language constructs. <code class="docutils literal"><span class="pre">tag:</span></code> defaults to <code class="docutils literal"><span class="pre">DW_TAG_template_value_parameter</span></code>,
but if specified can also be set to <code class="docutils literal"><span class="pre">DW_TAG_GNU_template_template_param</span></code> or
<code class="docutils literal"><span class="pre">DW_TAG_GNU_template_param_pack</span></code>. They are used (optionally) in
<a class="reference internal" href="#dicompositetype"><span class="std std-ref">DICompositeType</span></a> and <a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a> <code class="docutils literal"><span class="pre">templateParams:</span></code> fields.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DITemplateValueParameter</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;Ty&quot;</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">value:</span> <span class="k">i32</span> <span class="m">7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dinamespace">
<h5><a class="toc-backref" href="#id737">DINamespace</a><a class="headerlink" href="#dinamespace" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DINamespace</span></code> nodes represent namespaces in the source language.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DINamespace</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;myawesomeproject&quot;</span><span class="p">,</span> <span class="nl">scope:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="diglobalvariable">
<h5><a class="toc-backref" href="#id738">DIGlobalVariable</a><a class="headerlink" href="#diglobalvariable" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIGlobalVariable</span></code> nodes represent global variables in the source language.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DIGlobalVariable</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="nl">linkageName:</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="nl">scope:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span>
                       <span class="nl">file:</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nl">isLocal:</span> <span class="k">true</span><span class="p">,</span>
                       <span class="nl">isDefinition:</span> <span class="k">false</span><span class="p">,</span> <span class="nl">variable:</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@foo</span><span class="p">,</span>
                       <span class="nl">declaration:</span> <span class="nv nv-Anonymous">!4</span><span class="p">)</span>
</pre></div>
</div>
<p>All global variables should be referenced by the <cite>globals:</cite> field of a
<a class="reference internal" href="#dicompileunit"><span class="std std-ref">compile unit</span></a>.</p>
</div>
<div class="section" id="disubprogram">
<span id="id13"></span><h5><a class="toc-backref" href="#id739">DISubprogram</a><a class="headerlink" href="#disubprogram" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DISubprogram</span></code> nodes represent functions from the source language. A
<code class="docutils literal"><span class="pre">DISubprogram</span></code> may be attached to a function definition using <code class="docutils literal"><span class="pre">!dbg</span></code>
metadata. The <code class="docutils literal"><span class="pre">variables:</span></code> field points at <a class="reference internal" href="#dilocalvariable"><span class="std std-ref">variables</span></a>
that must be retained, even if their IR counterparts are optimized out of
the IR. The <code class="docutils literal"><span class="pre">type:</span></code> field must point at an <a class="reference internal" href="#disubroutinetype"><span class="std std-ref">DISubroutineType</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>define void @_Z3foov() !dbg !0 {
  ...
}

!0 = distinct !DISubprogram(name: &quot;foo&quot;, linkageName: &quot;_Zfoov&quot;, scope: !1,
                            file: !2, line: 7, type: !3, isLocal: true,
                            isDefinition: false, scopeLine: 8,
                            containingType: !4,
                            virtuality: DW_VIRTUALITY_pure_virtual,
                            virtualIndex: 10, flags: DIFlagPrototyped,
                            isOptimized: true, templateParams: !5,
                            declaration: !6, variables: !7)
</pre></div>
</div>
</div>
<div class="section" id="dilexicalblock">
<span id="id14"></span><h5><a class="toc-backref" href="#id740">DILexicalBlock</a><a class="headerlink" href="#dilexicalblock" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILexicalBlock</span></code> nodes describe nested blocks within a <a class="reference internal" href="#disubprogram"><span class="std std-ref">subprogram</span></a>. The line number and column numbers are used to distinguish
two lexical blocks at same depth. They are valid targets for <code class="docutils literal"><span class="pre">scope:</span></code>
fields.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = distinct !DILexicalBlock(scope: !1, file: !2, line: 7, column: 35)
</pre></div>
</div>
<p>Usually lexical blocks are <code class="docutils literal"><span class="pre">distinct</span></code> to prevent node merging based on
operands.</p>
</div>
<div class="section" id="dilexicalblockfile">
<span id="id15"></span><h5><a class="toc-backref" href="#id741">DILexicalBlockFile</a><a class="headerlink" href="#dilexicalblockfile" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILexicalBlockFile</span></code> nodes are used to discriminate between sections of a
<a class="reference internal" href="#dilexicalblock"><span class="std std-ref">lexical block</span></a>. The <code class="docutils literal"><span class="pre">file:</span></code> field can be changed to
indicate textual inclusion, or the <code class="docutils literal"><span class="pre">discriminator:</span></code> field can be used to
discriminate between control flow within a single block in the source language.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DILexicalBlock</span><span class="p">(</span><span class="nl">scope:</span> <span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">column:</span> <span class="m">35</span><span class="p">)</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="nv">!DILexicalBlockFile</span><span class="p">(</span><span class="nl">scope:</span> <span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nl">discriminator:</span> <span class="m">0</span><span class="p">)</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="nv">!DILexicalBlockFile</span><span class="p">(</span><span class="nl">scope:</span> <span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nl">discriminator:</span> <span class="m">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dilocation">
<span id="id16"></span><h5><a class="toc-backref" href="#id742">DILocation</a><a class="headerlink" href="#dilocation" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILocation</span></code> nodes represent source debug locations. The <code class="docutils literal"><span class="pre">scope:</span></code> field is
mandatory, and points at an <a class="reference internal" href="#dilexicalblockfile"><span class="std std-ref">DILexicalBlockFile</span></a>, an
<a class="reference internal" href="#dilexicalblock"><span class="std std-ref">DILexicalBlock</span></a>, or an <a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="nv">!DILocation</span><span class="p">(</span><span class="nl">line:</span> <span class="m">2900</span><span class="p">,</span> <span class="nl">column:</span> <span class="m">42</span><span class="p">,</span> <span class="nl">scope:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">inlinedAt:</span> <span class="nv nv-Anonymous">!2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dilocalvariable">
<span id="id17"></span><h5><a class="toc-backref" href="#id743">DILocalVariable</a><a class="headerlink" href="#dilocalvariable" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DILocalVariable</span></code> nodes represent local variables in the source language. If
the <code class="docutils literal"><span class="pre">arg:</span></code> field is set to non-zero, then this variable is a subprogram
parameter, and it will be included in the <code class="docutils literal"><span class="pre">variables:</span></code> field of its
<a class="reference internal" href="#disubprogram"><span class="std std-ref">DISubprogram</span></a>.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DILocalVariable(name: &quot;this&quot;, arg: 1, scope: !3, file: !2, line: 7,
                      type: !3, flags: DIFlagArtificial)
!1 = !DILocalVariable(name: &quot;x&quot;, arg: 2, scope: !4, file: !2, line: 7,
                      type: !3)
!2 = !DILocalVariable(name: &quot;y&quot;, scope: !5, file: !2, line: 7, type: !3)
</pre></div>
</div>
</div>
<div class="section" id="diexpression">
<h5><a class="toc-backref" href="#id744">DIExpression</a><a class="headerlink" href="#diexpression" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIExpression</span></code> nodes represent DWARF expression sequences. They are used in
<a class="reference internal" href="#dbg-intrinsics"><span class="std std-ref">debug intrinsics</span></a> (such as <code class="docutils literal"><span class="pre">llvm.dbg.declare</span></code>) to
describe how the referenced LLVM variable relates to the source language
variable.</p>
<p>The current supported vocabulary is limited:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">DW_OP_deref</span></code> dereferences the working expression.</li>
<li><code class="docutils literal"><span class="pre">DW_OP_plus,</span> <span class="pre">93</span></code> adds <code class="docutils literal"><span class="pre">93</span></code> to the working expression.</li>
<li><code class="docutils literal"><span class="pre">DW_OP_bit_piece,</span> <span class="pre">16,</span> <span class="pre">8</span></code> specifies the offset and size (<code class="docutils literal"><span class="pre">16</span></code> and <code class="docutils literal"><span class="pre">8</span></code>
here, respectively) of the variable piece from the working expression.</li>
</ul>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!0 = !DIExpression(DW_OP_deref)
!1 = !DIExpression(DW_OP_plus, 3)
!2 = !DIExpression(DW_OP_bit_piece, 3, 7)
!3 = !DIExpression(DW_OP_deref, DW_OP_plus, 3, DW_OP_bit_piece, 3, 7)
</pre></div>
</div>
</div>
<div class="section" id="diobjcproperty">
<h5><a class="toc-backref" href="#id745">DIObjCProperty</a><a class="headerlink" href="#diobjcproperty" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIObjCProperty</span></code> nodes represent Objective-C property nodes.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="nv">!DIObjCProperty</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="nl">file:</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nl">line:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">setter:</span> <span class="s">&quot;setFoo&quot;</span><span class="p">,</span>
                     <span class="nl">getter:</span> <span class="s">&quot;getFoo&quot;</span><span class="p">,</span> <span class="nl">attributes:</span> <span class="m">7</span><span class="p">,</span> <span class="nl">type:</span> <span class="nv nv-Anonymous">!2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="diimportedentity">
<h5><a class="toc-backref" href="#id746">DIImportedEntity</a><a class="headerlink" href="#diimportedentity" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIImportedEntity</span></code> nodes represent entities (such as modules) imported into a
compile unit.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!2 = !DIImportedEntity(tag: DW_TAG_imported_module, name: &quot;foo&quot;, scope: !0,
                       entity: !1, line: 7)
</pre></div>
</div>
</div>
<div class="section" id="dimacro">
<h5><a class="toc-backref" href="#id747">DIMacro</a><a class="headerlink" href="#dimacro" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIMacro</span></code> nodes represent definition or undefinition of a macro identifiers.
The <code class="docutils literal"><span class="pre">name:</span></code> field is the macro identifier, followed by macro parameters when
definining a function-like macro, and the <code class="docutils literal"><span class="pre">value</span></code> field is the token-string
used to expand the macro identifier.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!2 = !DIMacro(macinfo: DW_MACINFO_define, line: 7, name: &quot;foo(x)&quot;,
              value: &quot;((x) + 1)&quot;)
!3 = !DIMacro(macinfo: DW_MACINFO_undef, line: 30, name: &quot;foo&quot;)
</pre></div>
</div>
</div>
<div class="section" id="dimacrofile">
<h5><a class="toc-backref" href="#id748">DIMacroFile</a><a class="headerlink" href="#dimacrofile" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">DIMacroFile</span></code> nodes represent inclusion of source files.
The <code class="docutils literal"><span class="pre">nodes:</span></code> field is a list of <code class="docutils literal"><span class="pre">DIMacro</span></code> and <code class="docutils literal"><span class="pre">DIMacroFile</span></code> nodes that
appear in the included source file.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>!2 = !DIMacroFile(macinfo: DW_MACINFO_start_file, line: 7, file: !2,
                  nodes: !3)
</pre></div>
</div>
</div>
</div>
<div class="section" id="tbaa-metadata">
<h4><a class="toc-backref" href="#id749">&#8216;<code class="docutils literal"><span class="pre">tbaa</span></code>&#8216; Metadata</a><a class="headerlink" href="#tbaa-metadata" title="永久链接至标题">¶</a></h4>
<p>In LLVM IR, memory does not have types, so LLVM&#8217;s own type system is not
suitable for doing TBAA. Instead, metadata is added to the IR to
describe a type system of a higher level language. This can be used to
implement typical C/C++ TBAA, but it can also be used to implement
custom alias analysis behavior for other languages.</p>
<p>The current metadata format is very simple. TBAA metadata nodes have up
to three fields, e.g.:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;an example type tree&quot;</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;int&quot;</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;float&quot;</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv">!&quot;const float&quot;</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="k">i64</span> <span class="m">1</span> <span class="p">}</span>
</pre></div>
</div>
<p>The first field is an identity field. It can be any value, usually a
metadata string, which uniquely identifies the type. The most important
name in the tree is the name of the root node. Two trees with different
root node names are entirely disjoint, even if they have leaves with
common names.</p>
<p>The second field identifies the type&#8217;s parent node in the tree, or is
null or omitted for a root node. A type is considered to alias all of
its descendants and all of its ancestors in the tree. Also, a type is
considered to alias all types in other trees, so that bitcode produced
from multiple front-ends is handled conservatively.</p>
<p>If the third field is present, it&#8217;s an integer which if equal to 1
indicates that the type is &#8220;constant&#8221; (meaning
<code class="docutils literal"><span class="pre">pointsToConstantMemory</span></code> should return true; see <a class="reference external" href="AliasAnalysis.html#OtherItfs">other useful
AliasAnalysis methods</a>).</p>
</div>
<div class="section" id="tbaa-struct-metadata">
<h4><a class="toc-backref" href="#id750">&#8216;<code class="docutils literal"><span class="pre">tbaa.struct</span></code>&#8216; Metadata</a><a class="headerlink" href="#tbaa-struct-metadata" title="永久链接至标题">¶</a></h4>
<p>The <a class="reference internal" href="#int-memcpy"><span class="std std-ref">llvm.memcpy</span></a> is often used to implement
aggregate assignment operations in C and similar languages, however it
is defined to copy a contiguous region of memory, which is more than
strictly necessary for aggregate types which contain holes due to
padding. Also, it doesn&#8217;t contain any TBAA information about the fields
of the aggregate.</p>
<p><code class="docutils literal"><span class="pre">!tbaa.struct</span></code> metadata can describe which memory subregions in a
memcpy are padding and what the TBAA tags of the struct are.</p>
<p>The current metadata format is very simple. <code class="docutils literal"><span class="pre">!tbaa.struct</span></code> metadata
nodes are a list of operands which are in conceptual groups of three.
For each group of three, the first operand gives the byte offset of a
field in bytes, the second gives its size in bytes, and the third gives
its tbaa tag. e.g.:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!4</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">4</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="k">i64</span> <span class="m">8</span><span class="p">,</span> <span class="k">i64</span> <span class="m">4</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span> <span class="p">}</span>
</pre></div>
</div>
<p>This describes a struct with two fields. The first is at offset 0 bytes
with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes
and has size 4 bytes and has tbaa tag !2.</p>
<p>Note that the fields need not be contiguous. In this example, there is a
4 byte gap between the two fields. This gap represents padding which
does not carry useful data and need not be preserved.</p>
</div>
<div class="section" id="noalias-and-alias-scope-metadata">
<h4><a class="toc-backref" href="#id751">&#8216;<code class="docutils literal"><span class="pre">noalias</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">alias.scope</span></code>&#8216; Metadata</a><a class="headerlink" href="#noalias-and-alias-scope-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">noalias</span></code> and <code class="docutils literal"><span class="pre">alias.scope</span></code> metadata provide the ability to specify generic
noalias memory-access sets. This means that some collection of memory access
instructions (loads, stores, memory-accessing calls, etc.) that carry
<code class="docutils literal"><span class="pre">noalias</span></code> metadata can specifically be specified not to alias with some other
collection of memory access instructions that carry <code class="docutils literal"><span class="pre">alias.scope</span></code> metadata.
Each type of metadata specifies a list of scopes where each scope has an id and
a domain. When evaluating an aliasing query, if for some domain, the set
of scopes with that domain in one instruction&#8217;s <code class="docutils literal"><span class="pre">alias.scope</span></code> list is a
subset of (or equal to) the set of scopes for that domain in another
instruction&#8217;s <code class="docutils literal"><span class="pre">noalias</span></code> list, then the two memory accesses are assumed not to
alias.</p>
<p>The metadata identifying each domain is itself a list containing one or two
entries. The first entry is the name of the domain. Note that if the name is a
string then it can be combined across functions and translation units. A
self-reference can be used to create globally unique domain names. A
descriptive string may optionally be provided as a second list entry.</p>
<p>The metadata identifying each scope is also itself a list containing two or
three entries. The first entry is the name of the scope. Note that if the name
is a string then it can be combined across functions and translation units. A
self-reference can be used to create globally unique scope names. A metadata
reference to the scope&#8217;s domain is the second entry. A descriptive string may
optionally be provided as a third list entry.</p>
<p>For example,</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Two scope domains:</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span>

<span class="c">; Some scopes in these domains:</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!4</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">}</span>

<span class="c">; Some scope lists:</span>
<span class="nv nv-Anonymous">!5</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">}</span> <span class="c">; A list containing only scope !4</span>
<span class="nv nv-Anonymous">!6</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!4</span><span class="p">,</span> <span class="nv nv-Anonymous">!3</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">}</span>
<span class="nv nv-Anonymous">!7</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!3</span><span class="p">}</span>

<span class="c">; These two instructions don&#39;t alias:</span>
<span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%c</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!alias.scope</span> <span class="nv nv-Anonymous">!5</span>
<span class="k">store</span> <span class="kt">float</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%arrayidx.i</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!noalias</span> <span class="nv nv-Anonymous">!5</span>

<span class="c">; These two instructions also don&#39;t alias (for domain !1, the set of scopes</span>
<span class="c">; in the !alias.scope equals that in the !noalias list):</span>
<span class="nv nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%c</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!alias.scope</span> <span class="nv nv-Anonymous">!5</span>
<span class="k">store</span> <span class="kt">float</span> <span class="nv nv-Anonymous">%2</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%arrayidx.i2</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!noalias</span> <span class="nv nv-Anonymous">!6</span>

<span class="c">; These two instructions may alias (for domain !0, the set of scopes in</span>
<span class="c">; the !noalias list is not a superset of, or equal to, the scopes in the</span>
<span class="c">; !alias.scope list):</span>
<span class="nv nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%c</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!alias.scope</span> <span class="nv nv-Anonymous">!6</span>
<span class="k">store</span> <span class="kt">float</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="kt">float</span><span class="p">*</span> <span class="nv">%arrayidx.i</span><span class="p">,</span> <span class="k">align</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!noalias</span> <span class="nv nv-Anonymous">!7</span>
</pre></div>
</div>
</div>
<div class="section" id="fpmath-metadata">
<h4><a class="toc-backref" href="#id752">&#8216;<code class="docutils literal"><span class="pre">fpmath</span></code>&#8216; Metadata</a><a class="headerlink" href="#fpmath-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">fpmath</span></code> metadata may be attached to any instruction of floating point
type. It can be used to express the maximum acceptable error in the
result of that instruction, in ULPs, thus potentially allowing the
compiler to use a more efficient but less accurate method of computing
it. ULP is defined as follows:</p>
<blockquote>
<div>If <code class="docutils literal"><span class="pre">x</span></code> is a real number that lies between two finite consecutive
floating-point numbers <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>, without being equal to one
of them, then <code class="docutils literal"><span class="pre">ulp(x)</span> <span class="pre">=</span> <span class="pre">|b</span> <span class="pre">-</span> <span class="pre">a|</span></code>, otherwise <code class="docutils literal"><span class="pre">ulp(x)</span></code> is the
distance between the two non-equal finite floating-point numbers
nearest <code class="docutils literal"><span class="pre">x</span></code>. Moreover, <code class="docutils literal"><span class="pre">ulp(NaN)</span></code> is <code class="docutils literal"><span class="pre">NaN</span></code>.</div></blockquote>
<p>The metadata node shall consist of a single positive floating point
number representing the maximum relative error, for example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="kt">float</span> <span class="m">2.5</span> <span class="p">}</span> <span class="c">; maximum acceptable inaccuracy is 2.5 ULPs</span>
</pre></div>
</div>
</div>
<div class="section" id="range-metadata">
<span id="id18"></span><h4><a class="toc-backref" href="#id753">&#8216;<code class="docutils literal"><span class="pre">range</span></code>&#8216; Metadata</a><a class="headerlink" href="#range-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">range</span></code> metadata may be attached only to <code class="docutils literal"><span class="pre">load</span></code>, <code class="docutils literal"><span class="pre">call</span></code> and <code class="docutils literal"><span class="pre">invoke</span></code> of
integer types. It expresses the possible ranges the loaded value or the value
returned by the called function at this call site is in. The ranges are
represented with a flattened list of integers. The loaded value or the value
returned is known to be in the union of the ranges defined by each consecutive
pair. Each pair has the following properties:</p>
<ul class="simple">
<li>The type must match the type loaded by the instruction.</li>
<li>The pair <code class="docutils literal"><span class="pre">a,b</span></code> represents the range <code class="docutils literal"><span class="pre">[a,b)</span></code>.</li>
<li>Both <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are constants.</li>
<li>The range is allowed to wrap.</li>
<li>The range should not represent the full or empty set. That is,
<code class="docutils literal"><span class="pre">a!=b</span></code>.</li>
</ul>
<p>In addition, the pairs must be in signed order of the lower bound and
they must be non-contiguous.</p>
<p>Examples:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%a</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%x</span><span class="p">,</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!range</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can only be 0 or 1</span>
  <span class="nv">%b</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%y</span><span class="p">,</span> <span class="k">align</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!range</span> <span class="nv nv-Anonymous">!1</span> <span class="c">; Can only be 255 (-1), 0 or 1</span>
  <span class="nv">%c</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span> <span class="vg">@foo</span><span class="p">(),</span>       <span class="nv">!range</span> <span class="nv nv-Anonymous">!2</span> <span class="c">; Can only be 0, 1, 3, 4 or 5</span>
  <span class="nv">%d</span> <span class="p">=</span> <span class="k">invoke</span> <span class="k">i8</span> <span class="vg">@bar</span><span class="p">()</span> <span class="k">to</span> <span class="kt">label</span> <span class="nv">%cont</span>
         <span class="k">unwind</span> <span class="kt">label</span> <span class="nv">%lpad</span><span class="p">,</span> <span class="nv">!range</span> <span class="nv nv-Anonymous">!3</span> <span class="c">; Can only be -2, -1, 3, 4 or 5</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">0</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">255</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">0</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span><span class="p">,</span> <span class="k">i8</span> <span class="m">3</span><span class="p">,</span> <span class="k">i8</span> <span class="m">6</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i8</span> <span class="m">-2</span><span class="p">,</span> <span class="k">i8</span> <span class="m">0</span><span class="p">,</span> <span class="k">i8</span> <span class="m">3</span><span class="p">,</span> <span class="k">i8</span> <span class="m">6</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unpredictable-metadata">
<h4><a class="toc-backref" href="#id754">&#8216;<code class="docutils literal"><span class="pre">unpredictable</span></code>&#8216; Metadata</a><a class="headerlink" href="#unpredictable-metadata" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">unpredictable</span></code> metadata may be attached to any branch or switch
instruction. It can be used to express the unpredictability of control
flow. Similar to the llvm.expect intrinsic, it may be used to alter
optimizations related to compare and branch instructions. The metadata
is treated as a boolean value; if it exists, it signals that the branch
or switch that it is attached to is completely unpredictable.</p>
</div>
<div class="section" id="llvm-loop">
<h4><a class="toc-backref" href="#id755">&#8216;<code class="docutils literal"><span class="pre">llvm.loop</span></code>&#8216;</a><a class="headerlink" href="#llvm-loop" title="永久链接至标题">¶</a></h4>
<p>It is sometimes useful to attach information to loop constructs. Currently,
loop metadata is implemented as metadata attached to the branch instruction
in the loop latch block. This type of metadata refer to a metadata node that is
guaranteed to be separate for each loop. The loop identifier metadata is
specified with the name <code class="docutils literal"><span class="pre">llvm.loop</span></code>.</p>
<p>The loop identifier metadata is implemented using a metadata that refers to
itself to avoid merging it with any other identifier metadata, e.g.,
during module linkage or function inlining. That is, each loop should refer
to their own identification metadata even if they reside in separate functions.
The following example contains loop identifier metadata for two separate loop
constructs:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span>
</pre></div>
</div>
<p>The loop identifier metadata can be used to specify additional
per-loop metadata. Any operands after the first operand can be treated
as user-defined metadata. For example the <code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code>
suggests an unroll factor to the loop unroller:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%._crit_edge</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%.lr.ph</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!0</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.count&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-vectorize-and-llvm-loop-interleave">
<h4><a class="toc-backref" href="#id756">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code>&#8216;</a><a class="headerlink" href="#llvm-loop-vectorize-and-llvm-loop-interleave" title="永久链接至标题">¶</a></h4>
<p>Metadata prefixed with <code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code> or <code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code> are
used to control per-loop vectorization and interleaving parameters such as
vectorization width and interleave count. These metadata should be used in
conjunction with <code class="docutils literal"><span class="pre">llvm.loop</span></code> loop identification metadata. The
<code class="docutils literal"><span class="pre">llvm.loop.vectorize</span></code> and <code class="docutils literal"><span class="pre">llvm.loop.interleave</span></code> metadata are only
optimization hints and the optimizer will only interleave and vectorize loops if
it believes it is safe to do so. The <code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata
which contains information about loop-carried memory dependencies can be helpful
in determining the safety of these transformations.</p>
</div>
<div class="section" id="llvm-loop-interleave-count-metadata">
<h4><a class="toc-backref" href="#id757">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-interleave-count-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests an interleave count to the loop interleaver.
The first operand is the string <code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code> and the
second operand is an integer specifying the interleave count. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.interleave.count&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that setting <code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code> to 1 disables interleaving
multiple iterations of the loop. If <code class="docutils literal"><span class="pre">llvm.loop.interleave.count</span></code> is set to 0
then the interleave count will be determined automatically.</p>
</div>
<div class="section" id="llvm-loop-vectorize-enable-metadata">
<h4><a class="toc-backref" href="#id758">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.enable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-vectorize-enable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata selectively enables or disables vectorization for the loop. The
first operand is the string <code class="docutils literal"><span class="pre">llvm.loop.vectorize.enable</span></code> and the second operand
is a bit. If the bit operand value is 1 vectorization is enabled. A value of
0 disables vectorization:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.vectorize.enable&quot;</span><span class="p">,</span> <span class="k">i1</span> <span class="m">0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.vectorize.enable&quot;</span><span class="p">,</span> <span class="k">i1</span> <span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-vectorize-width-metadata">
<h4><a class="toc-backref" href="#id759">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-vectorize-width-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata sets the target width of the vectorizer. The first
operand is the string <code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code> and the second
operand is an integer specifying the width. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.vectorize.width&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that setting <code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code> to 1 disables
vectorization of the loop. If <code class="docutils literal"><span class="pre">llvm.loop.vectorize.width</span></code> is set to
0 or if the loop does not have this metadata the width will be
determined automatically.</p>
</div>
<div class="section" id="llvm-loop-unroll">
<h4><a class="toc-backref" href="#id760">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code>&#8216;</a><a class="headerlink" href="#llvm-loop-unroll" title="永久链接至标题">¶</a></h4>
<p>Metadata prefixed with <code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code> are loop unrolling
optimization hints such as the unroll factor. <code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code>
metadata should be used in conjunction with <code class="docutils literal"><span class="pre">llvm.loop</span></code> loop
identification metadata. The <code class="docutils literal"><span class="pre">llvm.loop.unroll</span></code> metadata are only
optimization hints and the unrolling will only be performed if the
optimizer believes it is safe to do so.</p>
</div>
<div class="section" id="llvm-loop-unroll-count-metadata">
<h4><a class="toc-backref" href="#id761">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-count-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests an unroll factor to the loop unroller. The
first operand is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.count</span></code> and the second
operand is a positive integer specifying the unroll factor. For
example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.count&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">}</span>
</pre></div>
</div>
<p>If the trip count of the loop is less than the unroll count the loop
will be partially unrolled.</p>
</div>
<div class="section" id="llvm-loop-unroll-disable-metadata">
<h4><a class="toc-backref" href="#id762">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.disable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-disable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata disables loop unrolling. The metadata has a single operand
which is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.disable</span></code>. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.disable&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-unroll-runtime-disable-metadata">
<h4><a class="toc-backref" href="#id763">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.runtime.disable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-runtime-disable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata disables runtime loop unrolling. The metadata has a single
operand which is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.runtime.disable</span></code>. For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.runtime.disable&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-unroll-enable-metadata">
<h4><a class="toc-backref" href="#id764">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.enable</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-enable-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests that the loop should be fully unrolled if the trip count
is known at compile time and partially unrolled if the trip count is not known
at compile time. The metadata has a single operand which is the string
<code class="docutils literal"><span class="pre">llvm.loop.unroll.enable</span></code>.  For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.enable&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-loop-unroll-full-metadata">
<h4><a class="toc-backref" href="#id765">&#8216;<code class="docutils literal"><span class="pre">llvm.loop.unroll.full</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-loop-unroll-full-metadata" title="永久链接至标题">¶</a></h4>
<p>This metadata suggests that the loop should be unrolled fully. The
metadata has a single operand which is the string <code class="docutils literal"><span class="pre">llvm.loop.unroll.full</span></code>.
For example:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;llvm.loop.unroll.full&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-mem">
<h4><a class="toc-backref" href="#id766">&#8216;<code class="docutils literal"><span class="pre">llvm.mem</span></code>&#8216;</a><a class="headerlink" href="#llvm-mem" title="永久链接至标题">¶</a></h4>
<p>Metadata types used to annotate memory accesses with information helpful
for optimizations are prefixed with <code class="docutils literal"><span class="pre">llvm.mem</span></code>.</p>
</div>
<div class="section" id="llvm-mem-parallel-loop-access-metadata">
<h4><a class="toc-backref" href="#id767">&#8216;<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code>&#8216; Metadata</a><a class="headerlink" href="#llvm-mem-parallel-loop-access-metadata" title="永久链接至标题">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata refers to a loop identifier,
or metadata containing a list of loop identifiers for nested loops.
The metadata is attached to memory accessing instructions and denotes that
no loop carried memory dependence exist between it and other instructions denoted
with the same loop identifier.</p>
<p>Precisely, given two instructions <code class="docutils literal"><span class="pre">m1</span></code> and <code class="docutils literal"><span class="pre">m2</span></code> that both have the
<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata, with <code class="docutils literal"><span class="pre">L1</span></code> and <code class="docutils literal"><span class="pre">L2</span></code> being the
set of loops associated with that metadata, respectively, then there is no loop
carried dependence between <code class="docutils literal"><span class="pre">m1</span></code> and <code class="docutils literal"><span class="pre">m2</span></code> for loops in both <code class="docutils literal"><span class="pre">L1</span></code> and
<code class="docutils literal"><span class="pre">L2</span></code>.</p>
<p>As a special case, if all memory accessing instructions in a loop have
<code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code> metadata that refers to that loop, then the
loop has no loop carried memory dependences and is considered to be a parallel
loop.</p>
<p>Note that if not all memory access instructions have such metadata referring to
the loop, then the loop is considered not being trivially parallel. Additional
memory dependence analysis is required to make that determination. As a fail
safe mechanism, this causes loops that were originally parallel to be considered
sequential (if optimization passes that are unaware of the parallel semantics
insert new memory instructions into the loop body).</p>
<p>Example of a loop that is considered parallel due to its correct use of
both <code class="docutils literal"><span class="pre">llvm.loop</span></code> and <code class="docutils literal"><span class="pre">llvm.mem.parallel_loop_access</span></code>
metadata types that refer to the same loop identifier metadata.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">for.body:</span>
  <span class="p">...</span>
  <span class="nv">%val0</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%val0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx1</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%for.end</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%for.body</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!0</span>

<span class="nl">for.end:</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
</pre></div>
</div>
<p>It is also possible to have nested parallel loops. In that case the
memory accesses refer to a list of loop identifier metadata nodes instead of
the loop identifier metadata node directly:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">outer.for.body:</span>
  <span class="p">...</span>
  <span class="nv">%val1</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx3</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!2</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%inner.for.body</span>

<span class="nl">inner.for.body:</span>
  <span class="p">...</span>
  <span class="nv">%val0</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx1</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%val0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx2</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!0</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%inner.for.end</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%inner.for.body</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!1</span>

<span class="nl">inner.for.end:</span>
  <span class="p">...</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%val1</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx4</span><span class="p">,</span> <span class="nv">!llvm.mem.parallel_loop_access</span> <span class="nv nv-Anonymous">!2</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%exitcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%outer.for.end</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%outer.for.body</span><span class="p">,</span> <span class="nv">!llvm.loop</span> <span class="nv nv-Anonymous">!2</span>

<span class="nl">outer.for.end:</span>                                          <span class="c">; preds = %for.body</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">}</span> <span class="c">; a list of loop identifiers</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span> <span class="c">; an identifier for the inner loop</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span><span class="nv nv-Anonymous">!2</span><span class="p">}</span> <span class="c">; an identifier for the outer loop</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-bitsets">
<h4><a class="toc-backref" href="#id768">&#8216;<code class="docutils literal"><span class="pre">llvm.bitsets</span></code>&#8216;</a><a class="headerlink" href="#llvm-bitsets" title="永久链接至标题">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">llvm.bitsets</span></code> global metadata is used to implement
<a class="reference internal" href="BitSets.html"><span class="doc">bitsets</span></a>.</p>
</div>
<div class="section" id="invariant-group-metadata">
<h4><a class="toc-backref" href="#id769">&#8216;<code class="docutils literal"><span class="pre">invariant.group</span></code>&#8216; Metadata</a><a class="headerlink" href="#invariant-group-metadata" title="永久链接至标题">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata may be attached to <code class="docutils literal"><span class="pre">load</span></code>/<code class="docutils literal"><span class="pre">store</span></code> instructions.
The existence of the <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata on the instruction tells
the optimizer that every <code class="docutils literal"><span class="pre">load</span></code> and <code class="docutils literal"><span class="pre">store</span></code> to the same pointer operand
within the same invariant group can be assumed to load or store the same
value (but see the <code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code> intrinsic which affects
when two pointers are considered the same).</p>
<p>Examples:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@unknownPtr</span> <span class="p">=</span> <span class="k">external</span> <span class="k">global</span> <span class="k">i8</span>
<span class="p">...</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i8</span>
<span class="k">store</span> <span class="k">i8</span> <span class="m">42</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span>
<span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>

<span class="nv">%a</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can assume that value under %ptr didn&#39;t change</span>
<span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%b</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!1</span> <span class="c">; Can&#39;t assume anything, because group changed</span>

<span class="nv">%newPtr</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@getPointer</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%c</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%newPtr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can&#39;t assume anything, because we only have information about %ptr</span>

<span class="nv">%unknownValue</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@unknownPtr</span>
<span class="k">store</span> <span class="k">i8</span> <span class="nv">%unknownValue</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span> <span class="c">; Can assume that %unknownValue == 42</span>

<span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%newPtr2</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.invariant.group.barrier</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%d</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%newPtr2</span><span class="p">,</span> <span class="nv">!invariant.group</span> <span class="nv nv-Anonymous">!0</span>  <span class="c">; Can&#39;t step through invariant.group.barrier to get value of %ptr</span>

<span class="p">...</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@getPointer</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.invariant.group.barrier</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>

<span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;magic ptr&quot;</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span><span class="nv">!&quot;other ptr&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="module-flags-metadata">
<h2><a class="toc-backref" href="#id770">Module Flags Metadata</a><a class="headerlink" href="#module-flags-metadata" title="永久链接至标题">¶</a></h2>
<p>Information about the module as a whole is difficult to convey to LLVM&#8217;s
subsystems. The LLVM IR isn&#8217;t sufficient to transmit this information.
The <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> named metadata exists in order to facilitate
this. These flags are in the form of key / value pairs &#8212; much like a
dictionary &#8212; making it easy for any subsystem who cares about a flag to
look it up.</p>
<p>The <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> metadata contains a list of metadata triplets.
Each triplet has the following form:</p>
<ul class="simple">
<li>The first element is a <em>behavior</em> flag, which specifies the behavior
when two (or more) modules are merged together, and it encounters two
(or more) metadata with the same ID. The supported behaviors are
described below.</li>
<li>The second element is a metadata string that is a unique ID for the
metadata. Each module may only have one flag entry for each unique ID (not
including entries with the <strong>Require</strong> behavior).</li>
<li>The third element is the value of the flag.</li>
</ul>
<p>When two (or more) modules are merged together, the resulting
<code class="docutils literal"><span class="pre">llvm.module.flags</span></code> metadata is the union of the modules&#8217; flags. That is, for
each unique metadata ID string, there will be exactly one entry in the merged
modules <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> metadata table, and the value for that entry will
be determined by the merge behavior flag, as described below. The only exception
is that entries with the <em>Require</em> behavior are always preserved.</p>
<p>The following behaviors are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Behavior</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td><dl class="first last docutils">
<dt><strong>Error</strong></dt>
<dd>Emits an error if two values disagree, otherwise the resulting value
is that of the operands.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td><dl class="first last docutils">
<dt><strong>Warning</strong></dt>
<dd>Emits a warning if two values disagree. The result value will be the
operand for the flag from the first module being linked.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td><dl class="first last docutils">
<dt><strong>Require</strong></dt>
<dd>Adds a requirement that another module flag be present and have a
specified value after linking is performed. The value must be a
metadata pair, where the first element of the pair is the ID of the
module flag to be restricted, and the second element of the pair is
the value the module flag should be restricted to. This behavior can
be used to restrict the allowable results (via triggering of an
error) of linking IDs with the <strong>Override</strong> behavior.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>4</td>
<td><dl class="first last docutils">
<dt><strong>Override</strong></dt>
<dd>Uses the specified value, regardless of the behavior or value of the
other module. If both modules specify <strong>Override</strong>, but the values
differ, an error will be emitted.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>5</td>
<td><dl class="first last docutils">
<dt><strong>Append</strong></dt>
<dd>Appends the two values, which are required to be metadata nodes.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>6</td>
<td><dl class="first last docutils">
<dt><strong>AppendUnique</strong></dt>
<dd>Appends the two values, which are required to be metadata
nodes. However, duplicate entries in the second list are dropped
during the append operation.</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>It is an error for a particular unique flag ID to have multiple behaviors,
except in the case of <strong>Require</strong> (which adds restrictions on another metadata
value) or <strong>Override</strong>.</p>
<p>An example of module flags:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!0</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!&quot;foo&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!1</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">4</span><span class="p">,</span> <span class="nv">!&quot;bar&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">37</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!2</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="nv">!&quot;qux&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">42</span> <span class="p">}</span>
<span class="nv nv-Anonymous">!3</span> <span class="p">=</span> <span class="p">!{</span> <span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="nv">!&quot;qux&quot;</span><span class="p">,</span>
  <span class="p">!{</span>
    <span class="nv">!&quot;foo&quot;</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nv">!llvm.module.flags</span> <span class="p">=</span> <span class="p">!{</span> <span class="nv nv-Anonymous">!0</span><span class="p">,</span> <span class="nv nv-Anonymous">!1</span><span class="p">,</span> <span class="nv nv-Anonymous">!2</span><span class="p">,</span> <span class="nv nv-Anonymous">!3</span> <span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!0</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;foo&quot;</span></code> and the value &#8216;1&#8217;. The behavior
if two or more <code class="docutils literal"><span class="pre">!&quot;foo&quot;</span></code> flags are seen is to emit an error if their
values are not equal.</p>
</li>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!1</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;bar&quot;</span></code> and the value &#8216;37&#8217;. The
behavior if two or more <code class="docutils literal"><span class="pre">!&quot;bar&quot;</span></code> flags are seen is to use the value
&#8216;37&#8217;.</p>
</li>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!2</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;qux&quot;</span></code> and the value &#8216;42&#8217;. The
behavior if two or more <code class="docutils literal"><span class="pre">!&quot;qux&quot;</span></code> flags are seen is to emit a
warning if their values are not equal.</p>
</li>
<li><p class="first">Metadata <code class="docutils literal"><span class="pre">!3</span></code> has the ID <code class="docutils literal"><span class="pre">!&quot;qux&quot;</span></code> and the value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>!{ !&quot;foo&quot;, i32 1 }
</pre></div>
</div>
<p>The behavior is to emit an error if the <code class="docutils literal"><span class="pre">llvm.module.flags</span></code> does not
contain a flag with the ID <code class="docutils literal"><span class="pre">!&quot;foo&quot;</span></code> that has the value &#8216;1&#8217; after linking is
performed.</p>
</li>
</ul>
<div class="section" id="objective-c-garbage-collection-module-flags-metadata">
<h3><a class="toc-backref" href="#id771">Objective-C Garbage Collection Module Flags Metadata</a><a class="headerlink" href="#objective-c-garbage-collection-module-flags-metadata" title="永久链接至标题">¶</a></h3>
<p>On the Mach-O platform, Objective-C stores metadata about garbage
collection in a special section called &#8220;image info&#8221;. The metadata
consists of a version number and a bitmask specifying what types of
garbage collection are supported (if any) by the file. If two or more
modules are linked together their garbage collection metadata needs to
be merged rather than appended together.</p>
<p>The Objective-C garbage collection module flags metadata consists of the
following key-value pairs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Version</span></code></td>
<td><strong>[Required]</strong> &#8212; The Objective-C ABI version. Valid values are 1 and 2.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Image</span> <span class="pre">Info</span> <span class="pre">Version</span></code></td>
<td><strong>[Required]</strong> &#8212; The version of the image info section. Currently
always 0.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Image</span> <span class="pre">Info</span> <span class="pre">Section</span></code></td>
<td><strong>[Required]</strong> &#8212; The section to place the metadata. Valid values are
<code class="docutils literal"><span class="pre">&quot;__OBJC,</span> <span class="pre">__image_info,</span> <span class="pre">regular&quot;</span></code> for Objective-C ABI version 1, and
<code class="docutils literal"><span class="pre">&quot;__DATA,__objc_imageinfo,</span> <span class="pre">regular,</span> <span class="pre">no_dead_strip&quot;</span></code> for
Objective-C ABI version 2.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code></td>
<td><strong>[Required]</strong> &#8212; Specifies whether garbage collection is supported or
not. Valid values are 0, for no garbage collection, and 2, for garbage
collection supported.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">GC</span> <span class="pre">Only</span></code></td>
<td><strong>[Optional]</strong> &#8212; Specifies that only garbage collection is supported.
If present, its value must be 6. This flag requires that the
<code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> flag have the value 2.</td>
</tr>
</tbody>
</table>
<p>Some important flag interactions:</p>
<ul class="simple">
<li>If a module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> set to 0 is
merged with a module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> set to
2, then the resulting module has the
<code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> flag set to 0.</li>
<li>A module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">Garbage</span> <span class="pre">Collection</span></code> set to 0 cannot be
merged with a module with <code class="docutils literal"><span class="pre">Objective-C</span> <span class="pre">GC</span> <span class="pre">Only</span></code> set to 6.</li>
</ul>
</div>
<div class="section" id="automatic-linker-flags-module-flags-metadata">
<h3><a class="toc-backref" href="#id772">Automatic Linker Flags Module Flags Metadata</a><a class="headerlink" href="#automatic-linker-flags-module-flags-metadata" title="永久链接至标题">¶</a></h3>
<p>Some targets support embedding flags to the linker inside individual object
files. Typically this is used in conjunction with language extensions which
allow source files to explicitly declare the libraries they depend on, and have
these automatically be transmitted to the linker via object files.</p>
<p>These flags are encoded in the IR using metadata in the module flags section,
using the <code class="docutils literal"><span class="pre">Linker</span> <span class="pre">Options</span></code> key. The merge behavior for this flag is required
to be <code class="docutils literal"><span class="pre">AppendUnique</span></code>, and the value for the key is expected to be a metadata
node which should be a list of other metadata nodes, each of which should be a
list of metadata strings defining linker options.</p>
<p>For example, the following metadata section specifies two separate sets of
linker options, presumably to link against <code class="docutils literal"><span class="pre">libz</span></code> and the <code class="docutils literal"><span class="pre">Cocoa</span></code>
framework:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>!0 = !{ i32 6, !&quot;Linker Options&quot;,
   !{
      !{ !&quot;-lz&quot; },
      !{ !&quot;-framework&quot;, !&quot;Cocoa&quot; } } }
!llvm.module.flags = !{ !0 }
</pre></div>
</div>
<p>The metadata encoding as lists of lists of options, as opposed to a collapsed
list of options, is chosen so that the IR encoding can use multiple option
strings to specify e.g., a single library, while still having that specifier be
preserved as an atomic element that can be recognized by a target specific
assembly writer or object file emitter.</p>
<p>Each individual option is required to be either a valid option for the target&#8217;s
linker, or an option that is reserved by the target specific assembly writer or
object file emitter. No other aspect of these options is defined by the IR.</p>
</div>
<div class="section" id="c-type-width-module-flags-metadata">
<h3><a class="toc-backref" href="#id773">C type width Module Flags Metadata</a><a class="headerlink" href="#c-type-width-module-flags-metadata" title="永久链接至标题">¶</a></h3>
<p>The ARM backend emits a section into each generated object file describing the
options that it was compiled with (in a compiler-independent way) to prevent
linking incompatible objects, and to allow automatic library selection. Some
of these options are not visible at the IR level, namely wchar_t width and enum
width.</p>
<p>To pass this information to the backend, these options are encoded in module
flags metadata, using the following key-value pairs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>short_wchar</td>
<td><ul class="first last simple">
<li>0 &#8212; sizeof(wchar_t) == 4</li>
<li>1 &#8212; sizeof(wchar_t) == 2</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>short_enum</td>
<td><ul class="first last simple">
<li>0 &#8212; Enums are at least as large as an <code class="docutils literal"><span class="pre">int</span></code>.</li>
<li>1 &#8212; Enums are stored in the smallest integer type which can
represent all of its values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>For example, the following metadata section specifies that the module was
compiled with a <code class="docutils literal"><span class="pre">wchar_t</span></code> width of 4 bytes, and the underlying type of an
enum is the smallest type which can represent all of its values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>!llvm.module.flags = !{!0, !1}
!0 = !{i32 1, !&quot;short_wchar&quot;, i32 1}
!1 = !{i32 1, !&quot;short_enum&quot;, i32 0}
</pre></div>
</div>
</div>
</div>
<div class="section" id="intrinsic-global-variables">
<span id="intrinsicglobalvariables"></span><h2><a class="toc-backref" href="#id774">Intrinsic Global Variables</a><a class="headerlink" href="#intrinsic-global-variables" title="永久链接至标题">¶</a></h2>
<p>LLVM has a number of &#8220;magic&#8221; global variables that contain data that
affect code generation or other IR semantics. These are documented here.
All globals of this sort should have a section specified as
&#8220;<code class="docutils literal"><span class="pre">llvm.metadata</span></code>&#8221;. This section and all globals that start with
&#8220;<code class="docutils literal"><span class="pre">llvm.</span></code>&#8221; are reserved for use by LLVM.</p>
<div class="section" id="the-llvm-used-global-variable">
<span id="gv-llvmused"></span><h3><a class="toc-backref" href="#id775">The &#8216;<code class="docutils literal"><span class="pre">llvm.used</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-used-global-variable" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> global is an array which has
<a class="reference internal" href="#linkage-appending"><span class="std std-ref">appending linkage</span></a>. This array contains a list of
pointers to named global variables, functions and aliases which may optionally
have a pointer cast formed of bitcast or getelementptr. For example, a legal
use of it is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@X</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i8</span> <span class="m">4</span>
<span class="vg">@Y</span> <span class="p">=</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">123</span>

<span class="vg">@llvm.used</span> <span class="p">=</span> <span class="k">appending</span> <span class="k">global</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*]</span> <span class="p">[</span>
   <span class="k">i8</span><span class="p">*</span> <span class="vg">@X</span><span class="p">,</span>
   <span class="k">i8</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">(</span><span class="k">i32</span><span class="p">*</span> <span class="vg">@Y</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*)</span>
<span class="p">],</span> <span class="k">section</span> <span class="s">&quot;llvm.metadata&quot;</span>
</pre></div>
</div>
<p>If a symbol appears in the <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> list, then the compiler, assembler,
and linker are required to treat the symbol as if there is a reference to the
symbol that it cannot see (which is why they have to be named). For example, if
a variable has internal linkage and no references other than that from the
<code class="docutils literal"><span class="pre">&#64;llvm.used</span></code> list, it cannot be deleted. This is commonly used to represent
references from inline asms and other things the compiler cannot &#8220;see&#8221;, and
corresponds to &#8220;<code class="docutils literal"><span class="pre">attribute((used))</span></code>&#8221; in GNU C.</p>
<p>On some targets, the code generator must emit a directive to the
assembler or object file to prevent the assembler and linker from
molesting the symbol.</p>
</div>
<div class="section" id="the-llvm-compiler-used-global-variable">
<span id="gv-llvmcompilerused"></span><h3><a class="toc-backref" href="#id776">The &#8216;<code class="docutils literal"><span class="pre">llvm.compiler.used</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-compiler-used-global-variable" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.compiler.used</span></code> directive is the same as the <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code>
directive, except that it only prevents the compiler from touching the
symbol. On targets that support it, this allows an intelligent linker to
optimize references to the symbol without being impeded as it would be
by <code class="docutils literal"><span class="pre">&#64;llvm.used</span></code>.</p>
<p>This is a rare construct that should only be used in rare circumstances,
and should not be exposed to source languages.</p>
</div>
<div class="section" id="the-llvm-global-ctors-global-variable">
<span id="gv-llvmglobalctors"></span><h3><a class="toc-backref" href="#id777">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_ctors</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-global-ctors-global-variable" title="永久链接至标题">¶</a></h3>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*,</span> <span class="k">i8</span><span class="p">*</span> <span class="p">}</span>
<span class="vg">@llvm.global_ctors</span> <span class="p">=</span> <span class="k">appending</span> <span class="k">global</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="nv nv-Anonymous">%0</span><span class="p">]</span> <span class="p">[</span><span class="nv nv-Anonymous">%0</span> <span class="p">{</span> <span class="k">i32</span> <span class="m">65535</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*</span> <span class="vg">@ctor</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@data</span> <span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.global_ctors</span></code> array contains a list of constructor
functions, priorities, and an optional associated global or function.
The functions referenced by this array will be called in ascending order
of priority (i.e. lowest first) when the module is loaded. The order of
functions with the same priority is not defined.</p>
<p>If the third field is present, non-null, and points to a global variable
or function, the initializer function will only run if the associated
data from the current module is not discarded.</p>
</div>
<div class="section" id="the-llvm-global-dtors-global-variable">
<span id="llvmglobaldtors"></span><h3><a class="toc-backref" href="#id778">The &#8216;<code class="docutils literal"><span class="pre">llvm.global_dtors</span></code>&#8216; Global Variable</a><a class="headerlink" href="#the-llvm-global-dtors-global-variable" title="永久链接至标题">¶</a></h3>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*,</span> <span class="k">i8</span><span class="p">*</span> <span class="p">}</span>
<span class="vg">@llvm.global_dtors</span> <span class="p">=</span> <span class="k">appending</span> <span class="k">global</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="nv nv-Anonymous">%0</span><span class="p">]</span> <span class="p">[</span><span class="nv nv-Anonymous">%0</span> <span class="p">{</span> <span class="k">i32</span> <span class="m">65535</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()*</span> <span class="vg">@dtor</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@data</span> <span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&#64;llvm.global_dtors</span></code> array contains a list of destructor
functions, priorities, and an optional associated global or function.
The functions referenced by this array will be called in descending
order of priority (i.e. highest first) when the module is unloaded. The
order of functions with the same priority is not defined.</p>
<p>If the third field is present, non-null, and points to a global variable
or function, the destructor function will only run if the associated
data from the current module is not discarded.</p>
</div>
</div>
<div class="section" id="instruction-reference">
<h2><a class="toc-backref" href="#id779">Instruction Reference</a><a class="headerlink" href="#instruction-reference" title="永久链接至标题">¶</a></h2>
<p>The LLVM instruction set consists of several different classifications
of instructions: <a class="reference internal" href="#terminators"><span class="std std-ref">terminator instructions</span></a>, <a class="reference internal" href="#binaryops"><span class="std std-ref">binary
instructions</span></a>, <a class="reference internal" href="#bitwiseops"><span class="std std-ref">bitwise binary
instructions</span></a>, <a class="reference internal" href="#memoryops"><span class="std std-ref">memory instructions</span></a>, and
<a class="reference internal" href="#otherops"><span class="std std-ref">other instructions</span></a>.</p>
<div class="section" id="terminator-instructions">
<span id="terminators"></span><h3><a class="toc-backref" href="#id780">Terminator Instructions</a><a class="headerlink" href="#terminator-instructions" title="永久链接至标题">¶</a></h3>
<p>As mentioned <a class="reference internal" href="#functionstructure"><span class="std std-ref">previously</span></a>, every basic block in a
program ends with a &#8220;Terminator&#8221; instruction, which indicates which
block should be executed after the current block is finished. These
terminator instructions typically yield a &#8216;<code class="docutils literal"><span class="pre">void</span></code>&#8216; value: they produce
control flow, not values (the one exception being the
&#8216;<a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>&#8216; instruction).</p>
<p>The terminator instructions are: &#8216;<a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-br"><span class="std std-ref">br</span></a>&#8216;, &#8216;<a class="reference internal" href="#i-switch"><span class="std std-ref">switch</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-indirectbr"><span class="std std-ref">indirectbr</span></a>&#8216;, &#8216;<a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a>&#8216;, &#8216;<a class="reference internal" href="#i-catchswitch"><span class="std std-ref">catchswitch</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-catchret"><span class="std std-ref">catchret</span></a>&#8216;,
&#8216;<a class="reference internal" href="#i-cleanupret"><span class="std std-ref">cleanupret</span></a>&#8216;,
and &#8216;<a class="reference internal" href="#i-unreachable"><span class="std std-ref">unreachable</span></a>&#8216;.</p>
<div class="section" id="ret-instruction">
<span id="i-ret"></span><h4><a class="toc-backref" href="#id781">&#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; Instruction</a><a class="headerlink" href="#ret-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="syntax">
<h5><a class="toc-backref" href="#id782">Syntax:</a><a class="headerlink" href="#syntax" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">Return</span> <span class="n">a</span> <span class="n">value</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">non</span><span class="o">-</span><span class="n">void</span> <span class="n">function</span>
<span class="n">ret</span> <span class="n">void</span>                 <span class="p">;</span> <span class="n">Return</span> <span class="kn">from</span> <span class="nn">void</span> <span class="n">function</span>
</pre></div>
</div>
</div>
<div class="section" id="overview">
<h5><a class="toc-backref" href="#id783">Overview:</a><a class="headerlink" href="#overview" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction is used to return control flow (and optionally
a value) from a function back to the caller.</p>
<p>There are two forms of the &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction: one that returns a
value and then causes control flow, and one that just causes control
flow to occur.</p>
</div>
<div class="section" id="arguments">
<h5><a class="toc-backref" href="#id784">Arguments:</a><a class="headerlink" href="#arguments" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction optionally accepts a single argument, the
return value. The type of the return value must be a &#8216;<a class="reference internal" href="#t-firstclass"><span class="std std-ref">first
class</span></a>&#8216; type.</p>
<p>A function is not <a class="reference internal" href="#wellformed"><span class="std std-ref">well formed</span></a> if it it has a non-void
return type and contains a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction with no return value or
a return value with a type that does not match its type, or if it has a
void return type and contains a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction with a return
value.</p>
</div>
<div class="section" id="semantics">
<h5><a class="toc-backref" href="#id785">Semantics:</a><a class="headerlink" href="#semantics" title="永久链接至标题">¶</a></h5>
<p>When the &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction is executed, control flow returns back to
the calling function&#8217;s context. If the caller is a
&#8220;<a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a>&#8221; instruction, execution continues at the
instruction after the call. If the caller was an
&#8220;<a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>&#8221; instruction, execution continues at the
beginning of the &#8220;normal&#8221; destination block. If the instruction returns
a value, that value shall set the call or invoke instruction&#8217;s return
value.</p>
</div>
<div class="section" id="example">
<h5><a class="toc-backref" href="#id786">Example:</a><a class="headerlink" href="#example" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">ret</span> <span class="k">i32</span> <span class="m">5</span>                       <span class="c">; Return an integer value of 5</span>
<span class="k">ret</span> <span class="kt">void</span>                        <span class="c">; Return from a void function</span>
<span class="k">ret</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i8</span> <span class="p">}</span> <span class="p">{</span> <span class="k">i32</span> <span class="m">4</span><span class="p">,</span> <span class="k">i8</span> <span class="m">2</span> <span class="p">}</span> <span class="c">; Return a struct of values 4 and 2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="br-instruction">
<span id="i-br"></span><h4><a class="toc-backref" href="#id787">&#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; Instruction</a><a class="headerlink" href="#br-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id19">
<h5><a class="toc-backref" href="#id788">Syntax:</a><a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">br</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">iftrue</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">iffalse</span><span class="o">&gt;</span>
<span class="n">br</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">Unconditional</span> <span class="n">branch</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h5><a class="toc-backref" href="#id789">Overview:</a><a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction is used to cause control flow to transfer to a
different basic block in the current function. There are two forms of
this instruction, corresponding to a conditional branch and an
unconditional branch.</p>
</div>
<div class="section" id="id21">
<h5><a class="toc-backref" href="#id790">Arguments:</a><a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h5>
<p>The conditional branch form of the &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction takes a single
&#8216;<code class="docutils literal"><span class="pre">i1</span></code>&#8216; value and two &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216; values. The unconditional form of the
&#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction takes a single &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216; value as a target.</p>
</div>
<div class="section" id="id22">
<h5><a class="toc-backref" href="#id791">Semantics:</a><a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h5>
<p>Upon execution of a conditional &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216; instruction, the &#8216;<code class="docutils literal"><span class="pre">i1</span></code>&#8216;
argument is evaluated. If the value is <code class="docutils literal"><span class="pre">true</span></code>, control flows to the
&#8216;<code class="docutils literal"><span class="pre">iftrue</span></code>&#8216; <code class="docutils literal"><span class="pre">label</span></code> argument. If &#8220;cond&#8221; is <code class="docutils literal"><span class="pre">false</span></code>, control flows
to the &#8216;<code class="docutils literal"><span class="pre">iffalse</span></code>&#8216; <code class="docutils literal"><span class="pre">label</span></code> argument.</p>
</div>
<div class="section" id="id23">
<h5><a class="toc-backref" href="#id792">Example:</a><a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">Test:</span>
  <span class="nv">%cond</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%IfEqual</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%IfUnequal</span>
<span class="nl">IfEqual:</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">1</span>
<span class="nl">IfUnequal:</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="m">0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="switch-instruction">
<span id="i-switch"></span><h4><a class="toc-backref" href="#id793">&#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; Instruction</a><a class="headerlink" href="#switch-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id24">
<h5><a class="toc-backref" href="#id794">Syntax:</a><a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">switch</span> <span class="o">&lt;</span><span class="n">intty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">defaultdest</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">intty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h5><a class="toc-backref" href="#id795">Overview:</a><a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; instruction is used to transfer control flow to one of
several different places. It is a generalization of the &#8216;<code class="docutils literal"><span class="pre">br</span></code>&#8216;
instruction, allowing a branch to occur to one of many possible
destinations.</p>
</div>
<div class="section" id="id26">
<h5><a class="toc-backref" href="#id796">Arguments:</a><a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; instruction uses three parameters: an integer
comparison value &#8216;<code class="docutils literal"><span class="pre">value</span></code>&#8216;, a default &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216; destination, and an
array of pairs of comparison value constants and &#8216;<code class="docutils literal"><span class="pre">label</span></code>&#8216;s. The table
is not allowed to contain duplicate constant entries.</p>
</div>
<div class="section" id="id27">
<h5><a class="toc-backref" href="#id797">Semantics:</a><a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">switch</span></code> instruction specifies a table of values and destinations.
When the &#8216;<code class="docutils literal"><span class="pre">switch</span></code>&#8216; instruction is executed, this table is searched
for the given value. If the value is found, control flow is transferred
to the corresponding destination; otherwise, control flow is transferred
to the default destination.</p>
</div>
<div class="section" id="implementation">
<h5><a class="toc-backref" href="#id798">Implementation:</a><a class="headerlink" href="#implementation" title="永久链接至标题">¶</a></h5>
<p>Depending on properties of the target machine and the particular
<code class="docutils literal"><span class="pre">switch</span></code> instruction, this instruction may be code generated in
different ways. For example, it could be generated as a series of
chained conditional branches or with a lookup table.</p>
</div>
<div class="section" id="id28">
<h5><a class="toc-backref" href="#id799">Example:</a><a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; Emulate a conditional br instruction</span>
<span class="nv">%Val</span> <span class="p">=</span> <span class="k">zext</span> <span class="k">i1</span> <span class="nv">%value</span> <span class="k">to</span> <span class="k">i32</span>
<span class="k">switch</span> <span class="k">i32</span> <span class="nv">%Val</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%truedest</span> <span class="p">[</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%falsedest</span> <span class="p">]</span>

<span class="c">; Emulate an unconditional br instruction</span>
<span class="k">switch</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%dest</span> <span class="p">[</span> <span class="p">]</span>

<span class="c">; Implement a jump table:</span>
<span class="k">switch</span> <span class="k">i32</span> <span class="nv">%val</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%otherwise</span> <span class="p">[</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%onzero</span>
                                    <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%onone</span>
                                    <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%ontwo</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="indirectbr-instruction">
<span id="i-indirectbr"></span><h4><a class="toc-backref" href="#id800">&#8216;<code class="docutils literal"><span class="pre">indirectbr</span></code>&#8216; Instruction</a><a class="headerlink" href="#indirectbr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id29">
<h5><a class="toc-backref" href="#id801">Syntax:</a><a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">indirectbr</span> <span class="o">&lt;</span><span class="n">somety</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">[</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">dest2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h5><a class="toc-backref" href="#id802">Overview:</a><a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">indirectbr</span></code>&#8216; instruction implements an indirect branch to a
label within the current function, whose address is specified by
&#8220;<code class="docutils literal"><span class="pre">address</span></code>&#8221;. Address must be derived from a
<a class="reference internal" href="#blockaddress"><span class="std std-ref">blockaddress</span></a> constant.</p>
</div>
<div class="section" id="id31">
<h5><a class="toc-backref" href="#id803">Arguments:</a><a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">address</span></code>&#8216; argument is the address of the label to jump to. The
rest of the arguments indicate the full set of possible destinations
that the address may point to. Blocks are allowed to occur multiple
times in the destination list, though this isn&#8217;t particularly useful.</p>
<p>This destination list is required so that dataflow analysis has an
accurate understanding of the CFG.</p>
</div>
<div class="section" id="id32">
<h5><a class="toc-backref" href="#id804">Semantics:</a><a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h5>
<p>Control transfers to the block specified in the address argument. All
possible destination blocks must be listed in the label list, otherwise
this instruction has undefined behavior. This implies that jumps to
labels defined in other functions have undefined behavior as well.</p>
</div>
<div class="section" id="id33">
<h5><a class="toc-backref" href="#id805">Implementation:</a><a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h5>
<p>This is typically implemented with a jump through a register.</p>
</div>
<div class="section" id="id34">
<h5><a class="toc-backref" href="#id806">Example:</a><a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">indirectbr</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%Addr</span><span class="p">,</span> <span class="p">[</span> <span class="kt">label</span> <span class="nv">%bb1</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb2</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%bb3</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="invoke-instruction">
<span id="i-invoke"></span><h4><a class="toc-backref" href="#id807">&#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; Instruction</a><a class="headerlink" href="#invoke-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id35">
<h5><a class="toc-backref" href="#id808">Syntax:</a><a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">invoke</span> <span class="p">[</span><span class="n">cconv</span><span class="p">]</span> <span class="p">[</span><span class="n">ret</span> <span class="n">attrs</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ptr</span> <span class="n">to</span> <span class="n">function</span> <span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">ptr</span> <span class="n">val</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">function</span> <span class="n">args</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">[</span><span class="n">fn</span> <span class="n">attrs</span><span class="p">]</span>
              <span class="p">[</span><span class="n">operand</span> <span class="n">bundles</span><span class="p">]</span> <span class="n">to</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">normal</span> <span class="n">label</span><span class="o">&gt;</span> <span class="n">unwind</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">exception</span> <span class="n">label</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h5><a class="toc-backref" href="#id809">Overview:</a><a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; instruction causes control to transfer to a specified
function, with the possibility of control flow transfer to either the
&#8216;<code class="docutils literal"><span class="pre">normal</span></code>&#8216; label or the &#8216;<code class="docutils literal"><span class="pre">exception</span></code>&#8216; label. If the callee function
returns with the &#8220;<code class="docutils literal"><span class="pre">ret</span></code>&#8221; instruction, control flow will return to the
&#8220;normal&#8221; label. If the callee (or any indirect callees) returns via the
&#8220;<a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a>&#8221; instruction or other exception handling
mechanism, control is interrupted and continued at the dynamically
nearest &#8220;exception&#8221; label.</p>
<p>The &#8216;<code class="docutils literal"><span class="pre">exception</span></code>&#8216; label is a <a class="reference external" href="ExceptionHandling.html#overview">landing
pad</a> for the exception. As such,
&#8216;<code class="docutils literal"><span class="pre">exception</span></code>&#8216; label is required to have the
&#8220;<a class="reference internal" href="#i-landingpad"><span class="std std-ref">landingpad</span></a>&#8221; instruction, which contains the
information about the behavior of the program after unwinding happens,
as its first non-PHI instruction. The restrictions on the
&#8220;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8221; instruction&#8217;s tightly couples it to the &#8220;<code class="docutils literal"><span class="pre">invoke</span></code>&#8221;
instruction, so that the important information contained within the
&#8220;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8221; instruction can&#8217;t be lost through normal code motion.</p>
</div>
<div class="section" id="id37">
<h5><a class="toc-backref" href="#id810">Arguments:</a><a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h5>
<p>This instruction requires several arguments:</p>
<ol class="arabic simple">
<li>The optional &#8220;cconv&#8221; marker indicates which <a class="reference internal" href="#callingconv"><span class="std std-ref">calling
convention</span></a> the call should use. If none is
specified, the call defaults to using C calling conventions.</li>
<li>The optional <a class="reference internal" href="#paramattrs"><span class="std std-ref">Parameter Attributes</span></a> list for return
values. Only &#8216;<code class="docutils literal"><span class="pre">zeroext</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">signext</span></code>&#8216;, and &#8216;<code class="docutils literal"><span class="pre">inreg</span></code>&#8216; attributes
are valid here.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">ptr</span> <span class="pre">to</span> <span class="pre">function</span> <span class="pre">ty</span></code>&#8216;: shall be the signature of the pointer to
function value being invoked. In most cases, this is a direct
function invocation, but indirect <code class="docutils literal"><span class="pre">invoke</span></code>&#8216;s are just as possible,
branching off an arbitrary pointer to function value.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">function</span> <span class="pre">ptr</span> <span class="pre">val</span></code>&#8216;: An LLVM value containing a pointer to a
function to be invoked.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">function</span> <span class="pre">args</span></code>&#8216;: argument list whose types match the function
signature argument types and parameter attributes. All arguments must
be of <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type. If the function signature
indicates the function accepts a variable number of arguments, the
extra arguments can be specified.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">normal</span> <span class="pre">label</span></code>&#8216;: the label reached when the called function
executes a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction.</li>
<li>&#8216;<code class="docutils literal"><span class="pre">exception</span> <span class="pre">label</span></code>&#8216;: the label reached when a callee returns via
the <a class="reference internal" href="#i-resume"><span class="std std-ref">resume</span></a> instruction or other exception handling
mechanism.</li>
<li>The optional <a class="reference internal" href="#fnattrs"><span class="std std-ref">function attributes</span></a> list. Only
&#8216;<code class="docutils literal"><span class="pre">noreturn</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">nounwind</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">readonly</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">readnone</span></code>&#8216;
attributes are valid here.</li>
<li>The optional <a class="reference internal" href="#opbundles"><span class="std std-ref">operand bundles</span></a> list.</li>
</ol>
</div>
<div class="section" id="id38">
<h5><a class="toc-backref" href="#id811">Semantics:</a><a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h5>
<p>This instruction is designed to operate as a standard &#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216;
instruction in most regards. The primary difference is that it
establishes an association with a label, which is used by the runtime
library to unwind the stack.</p>
<p>This instruction is used in languages with destructors to ensure that
proper cleanup is performed in the case of either a <code class="docutils literal"><span class="pre">longjmp</span></code> or a
thrown exception. Additionally, this is important for implementation of
&#8216;<code class="docutils literal"><span class="pre">catch</span></code>&#8216; clauses in high-level languages that support them.</p>
<p>For the purposes of the SSA form, the definition of the value returned
by the &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; instruction is deemed to occur on the edge from the
current block to the &#8220;normal&#8221; label. If the callee unwinds then no
return value is available.</p>
</div>
<div class="section" id="id39">
<h5><a class="toc-backref" href="#id812">Example:</a><a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%retval</span> <span class="p">=</span> <span class="k">invoke</span> <span class="k">i32</span> <span class="vg">@Test</span><span class="p">(</span><span class="k">i32</span> <span class="m">15</span><span class="p">)</span> <span class="k">to</span> <span class="kt">label</span> <span class="nv">%Continue</span>
            <span class="k">unwind</span> <span class="kt">label</span> <span class="nv">%TestCleanup</span>              <span class="c">; i32:retval set</span>
<span class="nv">%retval</span> <span class="p">=</span> <span class="k">invoke</span> <span class="k">coldcc</span> <span class="k">i32</span> <span class="nv">%Testfnptr</span><span class="p">(</span><span class="k">i32</span> <span class="m">15</span><span class="p">)</span> <span class="k">to</span> <span class="kt">label</span> <span class="nv">%Continue</span>
            <span class="k">unwind</span> <span class="kt">label</span> <span class="nv">%TestCleanup</span>              <span class="c">; i32:retval set</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="resume-instruction">
<span id="i-resume"></span><h4><a class="toc-backref" href="#id813">&#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; Instruction</a><a class="headerlink" href="#resume-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id40">
<h5><a class="toc-backref" href="#id814">Syntax:</a><a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">resume</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h5><a class="toc-backref" href="#id815">Overview:</a><a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; instruction is a terminator instruction that has no
successors.</p>
</div>
<div class="section" id="id42">
<h5><a class="toc-backref" href="#id816">Arguments:</a><a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; instruction requires one argument, which must have the
same type as the result of any &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction in the same
function.</p>
</div>
<div class="section" id="id43">
<h5><a class="toc-backref" href="#id817">Semantics:</a><a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">resume</span></code>&#8216; instruction resumes propagation of an existing
(in-flight) exception whose unwinding was interrupted with a
<a class="reference internal" href="#i-landingpad"><span class="std std-ref">landingpad</span></a> instruction.</p>
</div>
<div class="section" id="id44">
<h5><a class="toc-backref" href="#id818">Example:</a><a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">resume</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span> <span class="nv">%exn</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="catchswitch-instruction">
<span id="i-catchswitch"></span><h4><a class="toc-backref" href="#id819">&#8216;<code class="docutils literal"><span class="pre">catchswitch</span></code>&#8216; Instruction</a><a class="headerlink" href="#catchswitch-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id45">
<h5><a class="toc-backref" href="#id820">Syntax:</a><a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">catchswitch</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="n">unwind</span> <span class="n">to</span> <span class="n">caller</span>
<span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">catchswitch</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">handler2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="n">unwind</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">default</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id46">
<h5><a class="toc-backref" href="#id821">Overview:</a><a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchswitch</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling system</a> to describe the set of possible catch handlers
that may be executed by the <a class="reference internal" href="#personalityfn"><span class="std std-ref">EH personality routine</span></a>.</p>
</div>
<div class="section" id="id47">
<h5><a class="toc-backref" href="#id822">Arguments:</a><a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">parent</span></code> argument is the token of the funclet that contains the
<code class="docutils literal"><span class="pre">catchswitch</span></code> instruction. If the <code class="docutils literal"><span class="pre">catchswitch</span></code> is not inside a funclet,
this operand may be the token <code class="docutils literal"><span class="pre">none</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">default</span></code> argument is the label of another basic block beginning with
either a <code class="docutils literal"><span class="pre">cleanuppad</span></code> or <code class="docutils literal"><span class="pre">catchswitch</span></code> instruction.  This unwind destination
must be a legal target with respect to the <code class="docutils literal"><span class="pre">parent</span></code> links, as described in
the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">exception handling documentation</a>.</p>
<p>The <code class="docutils literal"><span class="pre">handlers</span></code> are a nonempty list of successor blocks that each begin with a
<a class="reference internal" href="#i-catchpad"><span class="std std-ref">catchpad</span></a> instruction.</p>
</div>
<div class="section" id="id48">
<h5><a class="toc-backref" href="#id823">Semantics:</a><a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h5>
<p>Executing this instruction transfers control to one of the successors in
<code class="docutils literal"><span class="pre">handlers</span></code>, if appropriate, or continues to unwind via the unwind label if
present.</p>
<p>The <code class="docutils literal"><span class="pre">catchswitch</span></code> is both a terminator and a &#8220;pad&#8221; instruction, meaning that
it must be both the first non-phi instruction and last instruction in the basic
block. Therefore, it must be the only non-phi instruction in the block.</p>
</div>
<div class="section" id="id49">
<h5><a class="toc-backref" href="#id824">Example:</a><a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>dispatch1:
  %cs1 = catchswitch within none [label %handler0, label %handler1] unwind to caller
dispatch2:
  %cs2 = catchswitch within %parenthandler [label %handler0] unwind label %cleanup
</pre></div>
</div>
</div>
</div>
<div class="section" id="catchret-instruction">
<span id="i-catchret"></span><h4><a class="toc-backref" href="#id825">&#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; Instruction</a><a class="headerlink" href="#catchret-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id50">
<h5><a class="toc-backref" href="#id826">Syntax:</a><a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">catchret</span> <span class="kn">from</span> <span class="o">&lt;</span><span class="n">token</span><span class="o">&gt;</span> <span class="n">to</span> <span class="n">label</span> <span class="o">&lt;</span><span class="n">normal</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h5><a class="toc-backref" href="#id827">Overview:</a><a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; instruction is a terminator instruction that has a
single successor.</p>
</div>
<div class="section" id="id52">
<h5><a class="toc-backref" href="#id828">Arguments:</a><a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h5>
<p>The first argument to a &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; indicates which <code class="docutils literal"><span class="pre">catchpad</span></code> it
exits.  It must be a <a class="reference internal" href="#i-catchpad"><span class="std std-ref">catchpad</span></a>.
The second argument to a &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; specifies where control will
transfer to next.</p>
</div>
<div class="section" id="id53">
<h5><a class="toc-backref" href="#id829">Semantics:</a><a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchret</span></code>&#8216; instruction ends an existing (in-flight) exception whose
unwinding was interrupted with a <a class="reference internal" href="#i-catchpad"><span class="std std-ref">catchpad</span></a> instruction.  The
<a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> gets a chance to execute arbitrary
code to, for example, destroy the active exception.  Control then transfers to
<code class="docutils literal"><span class="pre">normal</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">token</span></code> argument must be a token produced by a <code class="docutils literal"><span class="pre">catchpad</span></code> instruction.
If the specified <code class="docutils literal"><span class="pre">catchpad</span></code> is not the most-recently-entered not-yet-exited
funclet pad (as described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
the <code class="docutils literal"><span class="pre">catchret</span></code>&#8216;s behavior is undefined.</p>
</div>
<div class="section" id="id54">
<h5><a class="toc-backref" href="#id830">Example:</a><a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>catchret from %catch label %continue
</pre></div>
</div>
</div>
</div>
<div class="section" id="cleanupret-instruction">
<span id="i-cleanupret"></span><h4><a class="toc-backref" href="#id831">&#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; Instruction</a><a class="headerlink" href="#cleanupret-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id55">
<h5><a class="toc-backref" href="#id832">Syntax:</a><a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cleanupret</span> <span class="kn">from</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">unwind</span> <span class="n">label</span> <span class="o">&lt;</span><span class="k">continue</span><span class="o">&gt;</span>
<span class="n">cleanupret</span> <span class="kn">from</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">unwind</span> <span class="n">to</span> <span class="n">caller</span>
</pre></div>
</div>
</div>
<div class="section" id="id56">
<h5><a class="toc-backref" href="#id833">Overview:</a><a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction is a terminator instruction that has
an optional successor.</p>
</div>
<div class="section" id="id57">
<h5><a class="toc-backref" href="#id834">Arguments:</a><a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction requires one argument, which indicates
which <code class="docutils literal"><span class="pre">cleanuppad</span></code> it exits, and must be a <a class="reference internal" href="#i-cleanuppad"><span class="std std-ref">cleanuppad</span></a>.
If the specified <code class="docutils literal"><span class="pre">cleanuppad</span></code> is not the most-recently-entered not-yet-exited
funclet pad (as described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
the <code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216;s behavior is undefined.</p>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction also has an optional successor, <code class="docutils literal"><span class="pre">continue</span></code>,
which must be the label of another basic block beginning with either a
<code class="docutils literal"><span class="pre">cleanuppad</span></code> or <code class="docutils literal"><span class="pre">catchswitch</span></code> instruction.  This unwind destination must
be a legal target with respect to the <code class="docutils literal"><span class="pre">parent</span></code> links, as described in the
<a class="reference external" href="ExceptionHandling.html#wineh-constraints">exception handling documentation</a>.</p>
</div>
<div class="section" id="id60">
<h5><a class="toc-backref" href="#id835">Semantics:</a><a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanupret</span></code>&#8216; instruction indicates to the
<a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> that one
<a class="reference internal" href="#i-cleanuppad"><span class="std std-ref">cleanuppad</span></a> it transferred control to has ended.
It transfers control to <code class="docutils literal"><span class="pre">continue</span></code> or unwinds out of the function.</p>
</div>
<div class="section" id="id61">
<h5><a class="toc-backref" href="#id836">Example:</a><a class="headerlink" href="#id61" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>cleanupret from %cleanup unwind to caller
cleanupret from %cleanup unwind label %continue
</pre></div>
</div>
</div>
</div>
<div class="section" id="unreachable-instruction">
<span id="i-unreachable"></span><h4><a class="toc-backref" href="#id837">&#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; Instruction</a><a class="headerlink" href="#unreachable-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id62">
<h5><a class="toc-backref" href="#id838">Syntax:</a><a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unreachable</span>
</pre></div>
</div>
</div>
<div class="section" id="id63">
<h5><a class="toc-backref" href="#id839">Overview:</a><a class="headerlink" href="#id63" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; instruction has no defined semantics. This
instruction is used to inform the optimizer that a particular portion of
the code is not reachable. This can be used to indicate that the code
after a no-return function cannot be reached, and other facts.</p>
</div>
<div class="section" id="id64">
<h5><a class="toc-backref" href="#id840">Semantics:</a><a class="headerlink" href="#id64" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">unreachable</span></code>&#8216; instruction has no defined semantics.</p>
</div>
</div>
</div>
<div class="section" id="binary-operations">
<span id="binaryops"></span><h3><a class="toc-backref" href="#id841">Binary Operations</a><a class="headerlink" href="#binary-operations" title="永久链接至标题">¶</a></h3>
<p>Binary operators are used to do most of the computation in a program.
They require two operands of the same type, execute an operation on
them, and produce a single value. The operands might represent multiple
data, as is the case with the <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> data type. The
result value has the same type as its operands.</p>
<p>There are several different binary operators:</p>
<div class="section" id="add-instruction">
<span id="i-add"></span><h4><a class="toc-backref" href="#id842">&#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; Instruction</a><a class="headerlink" href="#add-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id65">
<h5><a class="toc-backref" href="#id843">Syntax:</a><a class="headerlink" href="#id65" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id66">
<h5><a class="toc-backref" href="#id844">Overview:</a><a class="headerlink" href="#id66" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; instruction returns the sum of its two operands.</p>
</div>
<div class="section" id="id67">
<h5><a class="toc-backref" href="#id845">Arguments:</a><a class="headerlink" href="#id67" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">add</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id68">
<h5><a class="toc-backref" href="#id846">Semantics:</a><a class="headerlink" href="#id68" title="永久链接至标题">¶</a></h5>
<p>The value produced is the integer sum of the two operands.</p>
<p>If the sum has unsigned overflow, the result returned is the
mathematical result modulo 2<sup>n</sup>, where n is the bit width of
the result.</p>
<p>Because LLVM integers use a two&#8217;s complement representation, this
instruction is appropriate for both signed and unsigned integers.</p>
<p><code class="docutils literal"><span class="pre">nuw</span></code> and <code class="docutils literal"><span class="pre">nsw</span></code> stand for &#8220;No Unsigned Wrap&#8221; and &#8220;No Signed Wrap&#8221;,
respectively. If the <code class="docutils literal"><span class="pre">nuw</span></code> and/or <code class="docutils literal"><span class="pre">nsw</span></code> keywords are present, the
result value of the <code class="docutils literal"><span class="pre">add</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if
unsigned and/or signed overflow, respectively, occurs.</p>
</div>
<div class="section" id="id69">
<h5><a class="toc-backref" href="#id847">Example:</a><a class="headerlink" href="#id69" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = add i32 4, %var          ; yields i32:result = 4 + %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fadd-instruction">
<span id="i-fadd"></span><h4><a class="toc-backref" href="#id848">&#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; Instruction</a><a class="headerlink" href="#fadd-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id70">
<h5><a class="toc-backref" href="#id849">Syntax:</a><a class="headerlink" href="#id70" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fadd</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id71">
<h5><a class="toc-backref" href="#id850">Overview:</a><a class="headerlink" href="#id71" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; instruction returns the sum of its two operands.</p>
</div>
<div class="section" id="id72">
<h5><a class="toc-backref" href="#id851">Arguments:</a><a class="headerlink" href="#id72" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fadd</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id73">
<h5><a class="toc-backref" href="#id852">Semantics:</a><a class="headerlink" href="#id73" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point sum of the two operands. This
instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>,
which are optimization hints to enable otherwise unsafe floating point
optimizations:</p>
</div>
<div class="section" id="id74">
<h5><a class="toc-backref" href="#id853">Example:</a><a class="headerlink" href="#id74" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fadd float 4.0, %var          ; yields float:result = 4.0 + %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="sub-instruction">
<h4><a class="toc-backref" href="#id854">&#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; Instruction</a><a class="headerlink" href="#sub-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id75">
<h5><a class="toc-backref" href="#id855">Syntax:</a><a class="headerlink" href="#id75" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id76">
<h5><a class="toc-backref" href="#id856">Overview:</a><a class="headerlink" href="#id76" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; instruction returns the difference of its two operands.</p>
<p>Note that the &#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; instruction is used to represent the &#8216;<code class="docutils literal"><span class="pre">neg</span></code>&#8216;
instruction present in most other intermediate representations.</p>
</div>
<div class="section" id="id77">
<h5><a class="toc-backref" href="#id857">Arguments:</a><a class="headerlink" href="#id77" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">sub</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id78">
<h5><a class="toc-backref" href="#id858">Semantics:</a><a class="headerlink" href="#id78" title="永久链接至标题">¶</a></h5>
<p>The value produced is the integer difference of the two operands.</p>
<p>If the difference has unsigned overflow, the result returned is the
mathematical result modulo 2<sup>n</sup>, where n is the bit width of
the result.</p>
<p>Because LLVM integers use a two&#8217;s complement representation, this
instruction is appropriate for both signed and unsigned integers.</p>
<p><code class="docutils literal"><span class="pre">nuw</span></code> and <code class="docutils literal"><span class="pre">nsw</span></code> stand for &#8220;No Unsigned Wrap&#8221; and &#8220;No Signed Wrap&#8221;,
respectively. If the <code class="docutils literal"><span class="pre">nuw</span></code> and/or <code class="docutils literal"><span class="pre">nsw</span></code> keywords are present, the
result value of the <code class="docutils literal"><span class="pre">sub</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if
unsigned and/or signed overflow, respectively, occurs.</p>
</div>
<div class="section" id="id79">
<h5><a class="toc-backref" href="#id859">Example:</a><a class="headerlink" href="#id79" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = sub i32 4, %var          ; yields i32:result = 4 - %var
&lt;result&gt; = sub i32 0, %val          ; yields i32:result = -%var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fsub-instruction">
<span id="i-fsub"></span><h4><a class="toc-backref" href="#id860">&#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; Instruction</a><a class="headerlink" href="#fsub-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id80">
<h5><a class="toc-backref" href="#id861">Syntax:</a><a class="headerlink" href="#id80" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fsub</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id81">
<h5><a class="toc-backref" href="#id862">Overview:</a><a class="headerlink" href="#id81" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; instruction returns the difference of its two operands.</p>
<p>Note that the &#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; instruction is used to represent the &#8216;<code class="docutils literal"><span class="pre">fneg</span></code>&#8216;
instruction present in most other intermediate representations.</p>
</div>
<div class="section" id="id82">
<h5><a class="toc-backref" href="#id863">Arguments:</a><a class="headerlink" href="#id82" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fsub</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id83">
<h5><a class="toc-backref" href="#id864">Semantics:</a><a class="headerlink" href="#id83" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point difference of the two operands.
This instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math
flags</span></a>, which are optimization hints to enable otherwise
unsafe floating point optimizations:</p>
</div>
<div class="section" id="id84">
<h5><a class="toc-backref" href="#id865">Example:</a><a class="headerlink" href="#id84" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fsub float 4.0, %var           ; yields float:result = 4.0 - %var
&lt;result&gt; = fsub float -0.0, %val          ; yields float:result = -%var
</pre></div>
</div>
</div>
</div>
<div class="section" id="mul-instruction">
<h4><a class="toc-backref" href="#id866">&#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; Instruction</a><a class="headerlink" href="#mul-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id85">
<h5><a class="toc-backref" href="#id867">Syntax:</a><a class="headerlink" href="#id85" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id86">
<h5><a class="toc-backref" href="#id868">Overview:</a><a class="headerlink" href="#id86" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; instruction returns the product of its two operands.</p>
</div>
<div class="section" id="id87">
<h5><a class="toc-backref" href="#id869">Arguments:</a><a class="headerlink" href="#id87" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">mul</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id88">
<h5><a class="toc-backref" href="#id870">Semantics:</a><a class="headerlink" href="#id88" title="永久链接至标题">¶</a></h5>
<p>The value produced is the integer product of the two operands.</p>
<p>If the result of the multiplication has unsigned overflow, the result
returned is the mathematical result modulo 2<sup>n</sup>, where n is the
bit width of the result.</p>
<p>Because LLVM integers use a two&#8217;s complement representation, and the
result is the same width as the operands, this instruction returns the
correct result for both signed and unsigned integers. If a full product
(e.g. <code class="docutils literal"><span class="pre">i32</span></code> * <code class="docutils literal"><span class="pre">i32</span></code> -&gt; <code class="docutils literal"><span class="pre">i64</span></code>) is needed, the operands should be
sign-extended or zero-extended as appropriate to the width of the full
product.</p>
<p><code class="docutils literal"><span class="pre">nuw</span></code> and <code class="docutils literal"><span class="pre">nsw</span></code> stand for &#8220;No Unsigned Wrap&#8221; and &#8220;No Signed Wrap&#8221;,
respectively. If the <code class="docutils literal"><span class="pre">nuw</span></code> and/or <code class="docutils literal"><span class="pre">nsw</span></code> keywords are present, the
result value of the <code class="docutils literal"><span class="pre">mul</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if
unsigned and/or signed overflow, respectively, occurs.</p>
</div>
<div class="section" id="id89">
<h5><a class="toc-backref" href="#id871">Example:</a><a class="headerlink" href="#id89" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = mul i32 4, %var          ; yields i32:result = 4 * %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fmul-instruction">
<span id="i-fmul"></span><h4><a class="toc-backref" href="#id872">&#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; Instruction</a><a class="headerlink" href="#fmul-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id90">
<h5><a class="toc-backref" href="#id873">Syntax:</a><a class="headerlink" href="#id90" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fmul</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id91">
<h5><a class="toc-backref" href="#id874">Overview:</a><a class="headerlink" href="#id91" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; instruction returns the product of its two operands.</p>
</div>
<div class="section" id="id92">
<h5><a class="toc-backref" href="#id875">Arguments:</a><a class="headerlink" href="#id92" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fmul</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id93">
<h5><a class="toc-backref" href="#id876">Semantics:</a><a class="headerlink" href="#id93" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point product of the two operands.
This instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math
flags</span></a>, which are optimization hints to enable otherwise
unsafe floating point optimizations:</p>
</div>
<div class="section" id="id94">
<h5><a class="toc-backref" href="#id877">Example:</a><a class="headerlink" href="#id94" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fmul float 4.0, %var          ; yields float:result = 4.0 * %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="udiv-instruction">
<h4><a class="toc-backref" href="#id878">&#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; Instruction</a><a class="headerlink" href="#udiv-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id95">
<h5><a class="toc-backref" href="#id879">Syntax:</a><a class="headerlink" href="#id95" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">udiv</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">udiv</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id96">
<h5><a class="toc-backref" href="#id880">Overview:</a><a class="headerlink" href="#id96" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; instruction returns the quotient of its two operands.</p>
</div>
<div class="section" id="id97">
<h5><a class="toc-backref" href="#id881">Arguments:</a><a class="headerlink" href="#id97" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id98">
<h5><a class="toc-backref" href="#id882">Semantics:</a><a class="headerlink" href="#id98" title="永久链接至标题">¶</a></h5>
<p>The value produced is the unsigned integer quotient of the two operands.</p>
<p>Note that unsigned integer division and signed integer division are
distinct operations; for signed integer division, use &#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216;.</p>
<p>Division by zero leads to undefined behavior.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">udiv</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if %op1 is not a multiple of %op2 (as
such, &#8220;((a udiv exact b) mul b) == a&#8221;).</p>
</div>
<div class="section" id="id99">
<h5><a class="toc-backref" href="#id883">Example:</a><a class="headerlink" href="#id99" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = udiv i32 4, %var          ; yields i32:result = 4 / %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="sdiv-instruction">
<h4><a class="toc-backref" href="#id884">&#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; Instruction</a><a class="headerlink" href="#sdiv-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id100">
<h5><a class="toc-backref" href="#id885">Syntax:</a><a class="headerlink" href="#id100" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sdiv</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sdiv</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id101">
<h5><a class="toc-backref" href="#id886">Overview:</a><a class="headerlink" href="#id101" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; instruction returns the quotient of its two operands.</p>
</div>
<div class="section" id="id102">
<h5><a class="toc-backref" href="#id887">Arguments:</a><a class="headerlink" href="#id102" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">sdiv</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id103">
<h5><a class="toc-backref" href="#id888">Semantics:</a><a class="headerlink" href="#id103" title="永久链接至标题">¶</a></h5>
<p>The value produced is the signed integer quotient of the two operands
rounded towards zero.</p>
<p>Note that signed integer division and unsigned integer division are
distinct operations; for unsigned integer division, use &#8216;<code class="docutils literal"><span class="pre">udiv</span></code>&#8216;.</p>
<p>Division by zero leads to undefined behavior. Overflow also leads to
undefined behavior; this is a rare case, but can occur, for example, by
doing a 32-bit division of -2147483648 by -1.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">sdiv</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if the result would be rounded.</p>
</div>
<div class="section" id="id104">
<h5><a class="toc-backref" href="#id889">Example:</a><a class="headerlink" href="#id104" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = sdiv i32 4, %var          ; yields i32:result = 4 / %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="fdiv-instruction">
<span id="i-fdiv"></span><h4><a class="toc-backref" href="#id890">&#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; Instruction</a><a class="headerlink" href="#fdiv-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id105">
<h5><a class="toc-backref" href="#id891">Syntax:</a><a class="headerlink" href="#id105" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fdiv</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id106">
<h5><a class="toc-backref" href="#id892">Overview:</a><a class="headerlink" href="#id106" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; instruction returns the quotient of its two operands.</p>
</div>
<div class="section" id="id107">
<h5><a class="toc-backref" href="#id893">Arguments:</a><a class="headerlink" href="#id107" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">fdiv</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id108">
<h5><a class="toc-backref" href="#id894">Semantics:</a><a class="headerlink" href="#id108" title="永久链接至标题">¶</a></h5>
<p>The value produced is the floating point quotient of the two operands.
This instruction can also take any number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math
flags</span></a>, which are optimization hints to enable otherwise
unsafe floating point optimizations:</p>
</div>
<div class="section" id="id109">
<h5><a class="toc-backref" href="#id895">Example:</a><a class="headerlink" href="#id109" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fdiv float 4.0, %var          ; yields float:result = 4.0 / %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="urem-instruction">
<h4><a class="toc-backref" href="#id896">&#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; Instruction</a><a class="headerlink" href="#urem-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id110">
<h5><a class="toc-backref" href="#id897">Syntax:</a><a class="headerlink" href="#id110" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">urem</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id111">
<h5><a class="toc-backref" href="#id898">Overview:</a><a class="headerlink" href="#id111" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; instruction returns the remainder from the unsigned
division of its two arguments.</p>
</div>
<div class="section" id="id112">
<h5><a class="toc-backref" href="#id899">Arguments:</a><a class="headerlink" href="#id112" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id113">
<h5><a class="toc-backref" href="#id900">Semantics:</a><a class="headerlink" href="#id113" title="永久链接至标题">¶</a></h5>
<p>This instruction returns the unsigned integer <em>remainder</em> of a division.
This instruction always performs an unsigned division to get the
remainder.</p>
<p>Note that unsigned integer remainder and signed integer remainder are
distinct operations; for signed integer remainder, use &#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216;.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.</p>
</div>
<div class="section" id="id114">
<h5><a class="toc-backref" href="#id901">Example:</a><a class="headerlink" href="#id114" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = urem i32 4, %var          ; yields i32:result = 4 % %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="srem-instruction">
<h4><a class="toc-backref" href="#id902">&#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; Instruction</a><a class="headerlink" href="#srem-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id115">
<h5><a class="toc-backref" href="#id903">Syntax:</a><a class="headerlink" href="#id115" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">srem</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id116">
<h5><a class="toc-backref" href="#id904">Overview:</a><a class="headerlink" href="#id116" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; instruction returns the remainder from the signed
division of its two operands. This instruction can also take
<a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> versions of the values in which case the elements
must be integers.</p>
</div>
<div class="section" id="id117">
<h5><a class="toc-backref" href="#id905">Arguments:</a><a class="headerlink" href="#id117" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">srem</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id118">
<h5><a class="toc-backref" href="#id906">Semantics:</a><a class="headerlink" href="#id118" title="永久链接至标题">¶</a></h5>
<p>This instruction returns the <em>remainder</em> of a division (where the result
is either zero or has the same sign as the dividend, <code class="docutils literal"><span class="pre">op1</span></code>), not the
<em>modulo</em> operator (where the result is either zero or has the same sign
as the divisor, <code class="docutils literal"><span class="pre">op2</span></code>) of a value. For more information about the
difference, see <a class="reference external" href="http://mathforum.org/dr.math/problems/anne.4.28.99.html">The Math
Forum</a>. For a
table of how this is implemented in various languages, please see
<a class="reference external" href="http://en.wikipedia.org/wiki/Modulo_operation">Wikipedia: modulo
operation</a>.</p>
<p>Note that signed integer remainder and unsigned integer remainder are
distinct operations; for unsigned integer remainder, use &#8216;<code class="docutils literal"><span class="pre">urem</span></code>&#8216;.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can
occur, for example, by taking the remainder of a 32-bit division of
-2147483648 by -1. (The remainder doesn&#8217;t actually overflow, but this
rule lets srem be implemented using instructions that return both the
result of the division and the remainder.)</p>
</div>
<div class="section" id="id119">
<h5><a class="toc-backref" href="#id907">Example:</a><a class="headerlink" href="#id119" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = srem i32 4, %var          ; yields i32:result = 4 % %var
</pre></div>
</div>
</div>
</div>
<div class="section" id="frem-instruction">
<span id="i-frem"></span><h4><a class="toc-backref" href="#id908">&#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; Instruction</a><a class="headerlink" href="#frem-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id120">
<h5><a class="toc-backref" href="#id909">Syntax:</a><a class="headerlink" href="#id120" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">frem</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id121">
<h5><a class="toc-backref" href="#id910">Overview:</a><a class="headerlink" href="#id121" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; instruction returns the remainder from the division of
its two operands.</p>
</div>
<div class="section" id="id122">
<h5><a class="toc-backref" href="#id911">Arguments:</a><a class="headerlink" href="#id122" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">frem</span></code>&#8216; instruction must be <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point values.
Both arguments must have identical types.</p>
</div>
<div class="section" id="id123">
<h5><a class="toc-backref" href="#id912">Semantics:</a><a class="headerlink" href="#id123" title="永久链接至标题">¶</a></h5>
<p>This instruction returns the <em>remainder</em> of a division. The remainder
has the same sign as the dividend. This instruction can also take any
number of <a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>, which are optimization hints
to enable otherwise unsafe floating point optimizations:</p>
</div>
<div class="section" id="id124">
<h5><a class="toc-backref" href="#id913">Example:</a><a class="headerlink" href="#id124" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = frem float 4.0, %var          ; yields float:result = 4.0 % %var
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="bitwise-binary-operations">
<span id="bitwiseops"></span><h3><a class="toc-backref" href="#id914">Bitwise Binary Operations</a><a class="headerlink" href="#bitwise-binary-operations" title="永久链接至标题">¶</a></h3>
<p>Bitwise binary operators are used to do various forms of bit-twiddling
in a program. They are generally very efficient instructions and can
commonly be strength reduced from other instructions. They require two
operands of the same type, execute an operation on them, and produce a
single value. The resulting value is the same type as its operands.</p>
<div class="section" id="shl-instruction">
<h4><a class="toc-backref" href="#id915">&#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; Instruction</a><a class="headerlink" href="#shl-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id125">
<h5><a class="toc-backref" href="#id916">Syntax:</a><a class="headerlink" href="#id125" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>           <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">nuw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shl</span> <span class="n">nuw</span> <span class="n">nsw</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id126">
<h5><a class="toc-backref" href="#id917">Overview:</a><a class="headerlink" href="#id126" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; instruction returns the first operand shifted to the left
a specified number of bits.</p>
</div>
<div class="section" id="id127">
<h5><a class="toc-backref" href="#id918">Arguments:</a><a class="headerlink" href="#id127" title="永久链接至标题">¶</a></h5>
<p>Both arguments to the &#8216;<code class="docutils literal"><span class="pre">shl</span></code>&#8216; instruction must be the same
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer type.
&#8216;<code class="docutils literal"><span class="pre">op2</span></code>&#8216; is treated as an unsigned value.</p>
</div>
<div class="section" id="id128">
<h5><a class="toc-backref" href="#id919">Semantics:</a><a class="headerlink" href="#id128" title="永久链接至标题">¶</a></h5>
<p>The value produced is <code class="docutils literal"><span class="pre">op1</span></code> * 2<sup>op2</sup> mod 2<sup>n</sup>,
where <code class="docutils literal"><span class="pre">n</span></code> is the width of the result. If <code class="docutils literal"><span class="pre">op2</span></code> is (statically or
dynamically) equal to or larger than the number of bits in
<code class="docutils literal"><span class="pre">op1</span></code>, the result is undefined. If the arguments are vectors, each
vector element of <code class="docutils literal"><span class="pre">op1</span></code> is shifted by the corresponding shift amount
in <code class="docutils literal"><span class="pre">op2</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">nuw</span></code> keyword is present, then the shift produces a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison
value</span></a> if it shifts out any non-zero bits. If the
<code class="docutils literal"><span class="pre">nsw</span></code> keyword is present, then the shift produces a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison
value</span></a> if it shifts out any bits that disagree with the
resultant sign bit. As such, NUW/NSW have the same semantics as they
would if the shift were expressed as a mul instruction with the same
nsw/nuw bits in (mul %op1, (shl 1, %op2)).</p>
</div>
<div class="section" id="id129">
<h5><a class="toc-backref" href="#id920">Example:</a><a class="headerlink" href="#id129" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = shl i32 4, %var   ; yields i32: 4 &lt;&lt; %var
&lt;result&gt; = shl i32 4, 2      ; yields i32: 16
&lt;result&gt; = shl i32 1, 10     ; yields i32: 1024
&lt;result&gt; = shl i32 1, 32     ; undefined
&lt;result&gt; = shl &lt;2 x i32&gt; &lt; i32 1, i32 1&gt;, &lt; i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 2, i32 4&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="lshr-instruction">
<h4><a class="toc-backref" href="#id921">&#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; Instruction</a><a class="headerlink" href="#lshr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id130">
<h5><a class="toc-backref" href="#id922">Syntax:</a><a class="headerlink" href="#id130" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">lshr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">lshr</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id131">
<h5><a class="toc-backref" href="#id923">Overview:</a><a class="headerlink" href="#id131" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; instruction (logical shift right) returns the first
operand shifted to the right a specified number of bits with zero fill.</p>
</div>
<div class="section" id="id132">
<h5><a class="toc-backref" href="#id924">Arguments:</a><a class="headerlink" href="#id132" title="永久链接至标题">¶</a></h5>
<p>Both arguments to the &#8216;<code class="docutils literal"><span class="pre">lshr</span></code>&#8216; instruction must be the same
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer type.
&#8216;<code class="docutils literal"><span class="pre">op2</span></code>&#8216; is treated as an unsigned value.</p>
</div>
<div class="section" id="id133">
<h5><a class="toc-backref" href="#id925">Semantics:</a><a class="headerlink" href="#id133" title="永久链接至标题">¶</a></h5>
<p>This instruction always performs a logical shift right operation. The
most significant bits of the result will be filled with zero bits after
the shift. If <code class="docutils literal"><span class="pre">op2</span></code> is (statically or dynamically) equal to or larger
than the number of bits in <code class="docutils literal"><span class="pre">op1</span></code>, the result is undefined. If the
arguments are vectors, each vector element of <code class="docutils literal"><span class="pre">op1</span></code> is shifted by the
corresponding shift amount in <code class="docutils literal"><span class="pre">op2</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">lshr</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if any of the bits shifted out are
non-zero.</p>
</div>
<div class="section" id="id134">
<h5><a class="toc-backref" href="#id926">Example:</a><a class="headerlink" href="#id134" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = lshr i32 4, 1   ; yields i32:result = 2
&lt;result&gt; = lshr i32 4, 2   ; yields i32:result = 1
&lt;result&gt; = lshr i8  4, 3   ; yields i8:result = 0
&lt;result&gt; = lshr i8 -2, 1   ; yields i8:result = 0x7F
&lt;result&gt; = lshr i32 1, 32  ; undefined
&lt;result&gt; = lshr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 0x7FFFFFFF, i32 1&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="ashr-instruction">
<h4><a class="toc-backref" href="#id927">&#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; Instruction</a><a class="headerlink" href="#ashr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id135">
<h5><a class="toc-backref" href="#id928">Syntax:</a><a class="headerlink" href="#id135" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">exact</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id136">
<h5><a class="toc-backref" href="#id929">Overview:</a><a class="headerlink" href="#id136" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; instruction (arithmetic shift right) returns the first
operand shifted to the right a specified number of bits with sign
extension.</p>
</div>
<div class="section" id="id137">
<h5><a class="toc-backref" href="#id930">Arguments:</a><a class="headerlink" href="#id137" title="永久链接至标题">¶</a></h5>
<p>Both arguments to the &#8216;<code class="docutils literal"><span class="pre">ashr</span></code>&#8216; instruction must be the same
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer type.
&#8216;<code class="docutils literal"><span class="pre">op2</span></code>&#8216; is treated as an unsigned value.</p>
</div>
<div class="section" id="id138">
<h5><a class="toc-backref" href="#id931">Semantics:</a><a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h5>
<p>This instruction always performs an arithmetic shift right operation,
The most significant bits of the result will be filled with the sign bit
of <code class="docutils literal"><span class="pre">op1</span></code>. If <code class="docutils literal"><span class="pre">op2</span></code> is (statically or dynamically) equal to or larger
than the number of bits in <code class="docutils literal"><span class="pre">op1</span></code>, the result is undefined. If the
arguments are vectors, each vector element of <code class="docutils literal"><span class="pre">op1</span></code> is shifted by the
corresponding shift amount in <code class="docutils literal"><span class="pre">op2</span></code>.</p>
<p>If the <code class="docutils literal"><span class="pre">exact</span></code> keyword is present, the result value of the <code class="docutils literal"><span class="pre">ashr</span></code> is
a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if any of the bits shifted out are
non-zero.</p>
</div>
<div class="section" id="id139">
<h5><a class="toc-backref" href="#id932">Example:</a><a class="headerlink" href="#id139" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = ashr i32 4, 1   ; yields i32:result = 2
&lt;result&gt; = ashr i32 4, 2   ; yields i32:result = 1
&lt;result&gt; = ashr i8  4, 3   ; yields i8:result = 0
&lt;result&gt; = ashr i8 -2, 1   ; yields i8:result = -1
&lt;result&gt; = ashr i32 1, 32  ; undefined
&lt;result&gt; = ashr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 3&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 -1, i32 0&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="and-instruction">
<h4><a class="toc-backref" href="#id933">&#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; Instruction</a><a class="headerlink" href="#and-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id140">
<h5><a class="toc-backref" href="#id934">Syntax:</a><a class="headerlink" href="#id140" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">and</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id141">
<h5><a class="toc-backref" href="#id935">Overview:</a><a class="headerlink" href="#id141" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; instruction returns the bitwise logical and of its two
operands.</p>
</div>
<div class="section" id="id142">
<h5><a class="toc-backref" href="#id936">Arguments:</a><a class="headerlink" href="#id142" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id143">
<h5><a class="toc-backref" href="#id937">Semantics:</a><a class="headerlink" href="#id143" title="永久链接至标题">¶</a></h5>
<p>The truth table used for the &#8216;<code class="docutils literal"><span class="pre">and</span></code>&#8216; instruction is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In0</td>
<td>In1</td>
<td>Out</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id144">
<h5><a class="toc-backref" href="#id938">Example:</a><a class="headerlink" href="#id144" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = and i32 4, %var         ; yields i32:result = 4 &amp; %var
&lt;result&gt; = and i32 15, 40          ; yields i32:result = 8
&lt;result&gt; = and i32 4, 8            ; yields i32:result = 0
</pre></div>
</div>
</div>
</div>
<div class="section" id="or-instruction">
<h4><a class="toc-backref" href="#id939">&#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; Instruction</a><a class="headerlink" href="#or-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id145">
<h5><a class="toc-backref" href="#id940">Syntax:</a><a class="headerlink" href="#id145" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id146">
<h5><a class="toc-backref" href="#id941">Overview:</a><a class="headerlink" href="#id146" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; instruction returns the bitwise logical inclusive or of its
two operands.</p>
</div>
<div class="section" id="id147">
<h5><a class="toc-backref" href="#id942">Arguments:</a><a class="headerlink" href="#id147" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id148">
<h5><a class="toc-backref" href="#id943">Semantics:</a><a class="headerlink" href="#id148" title="永久链接至标题">¶</a></h5>
<p>The truth table used for the &#8216;<code class="docutils literal"><span class="pre">or</span></code>&#8216; instruction is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In0</td>
<td>In1</td>
<td>Out</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id149">
<h5><a class="toc-backref" href="#id944">Example:</a><a class="headerlink" href="#id149" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="n">var</span>         <span class="p">;</span> <span class="n">yields</span> <span class="n">i32</span><span class="p">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">|</span> <span class="o">%</span><span class="n">var</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="n">i32</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">40</span>          <span class="p">;</span> <span class="n">yields</span> <span class="n">i32</span><span class="p">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">47</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">or</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span>            <span class="p">;</span> <span class="n">yields</span> <span class="n">i32</span><span class="p">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="xor-instruction">
<h4><a class="toc-backref" href="#id945">&#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; Instruction</a><a class="headerlink" href="#xor-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id150">
<h5><a class="toc-backref" href="#id946">Syntax:</a><a class="headerlink" href="#id150" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">xor</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id151">
<h5><a class="toc-backref" href="#id947">Overview:</a><a class="headerlink" href="#id151" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; instruction returns the bitwise logical exclusive or of
its two operands. The <code class="docutils literal"><span class="pre">xor</span></code> is used to implement the &#8220;one&#8217;s
complement&#8221; operation, which is the &#8220;~&#8221; operator in C.</p>
</div>
<div class="section" id="id152">
<h5><a class="toc-backref" href="#id948">Arguments:</a><a class="headerlink" href="#id152" title="永久链接至标题">¶</a></h5>
<p>The two arguments to the &#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; instruction must be
<a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of integer values. Both
arguments must have identical types.</p>
</div>
<div class="section" id="id153">
<h5><a class="toc-backref" href="#id949">Semantics:</a><a class="headerlink" href="#id153" title="永久链接至标题">¶</a></h5>
<p>The truth table used for the &#8216;<code class="docutils literal"><span class="pre">xor</span></code>&#8216; instruction is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In0</td>
<td>In1</td>
<td>Out</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id154">
<h5><a class="toc-backref" href="#id950">Example:</a><a class="headerlink" href="#id154" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = xor i32 4, %var         ; yields i32:result = 4 ^ %var
&lt;result&gt; = xor i32 15, 40          ; yields i32:result = 39
&lt;result&gt; = xor i32 4, 8            ; yields i32:result = 12
&lt;result&gt; = xor i32 %V, -1          ; yields i32:result = ~%V
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="vector-operations">
<h3><a class="toc-backref" href="#id951">Vector Operations</a><a class="headerlink" href="#vector-operations" title="永久链接至标题">¶</a></h3>
<p>LLVM supports several instructions to represent vector operations in a
target-independent manner. These instructions cover the element-access
and vector-specific operations needed to process vectors effectively.
While LLVM does directly support these vector operations, many
sophisticated algorithms will want to use target-specific intrinsics to
take full advantage of a specific target.</p>
<div class="section" id="extractelement-instruction">
<span id="i-extractelement"></span><h4><a class="toc-backref" href="#id952">&#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; Instruction</a><a class="headerlink" href="#extractelement-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id155">
<h5><a class="toc-backref" href="#id953">Syntax:</a><a class="headerlink" href="#id155" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id156">
<h5><a class="toc-backref" href="#id954">Overview:</a><a class="headerlink" href="#id156" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; instruction extracts a single scalar element
from a vector at a specified index.</p>
</div>
<div class="section" id="id157">
<h5><a class="toc-backref" href="#id955">Arguments:</a><a class="headerlink" href="#id157" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">extractelement</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> type. The second operand is an index indicating
the position from which to extract the element. The index may be a
variable of any integer type.</p>
</div>
<div class="section" id="id158">
<h5><a class="toc-backref" href="#id956">Semantics:</a><a class="headerlink" href="#id158" title="永久链接至标题">¶</a></h5>
<p>The result is a scalar of the same type as the element type of <code class="docutils literal"><span class="pre">val</span></code>.
Its value is the value at position <code class="docutils literal"><span class="pre">idx</span></code> of <code class="docutils literal"><span class="pre">val</span></code>. If <code class="docutils literal"><span class="pre">idx</span></code>
exceeds the length of <code class="docutils literal"><span class="pre">val</span></code>, the results are undefined.</p>
</div>
<div class="section" id="id159">
<h5><a class="toc-backref" href="#id957">Example:</a><a class="headerlink" href="#id159" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = extractelement &lt;4 x i32&gt; %vec, i32 0    ; yields i32
</pre></div>
</div>
</div>
</div>
<div class="section" id="insertelement-instruction">
<span id="i-insertelement"></span><h4><a class="toc-backref" href="#id958">&#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; Instruction</a><a class="headerlink" href="#insertelement-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id160">
<h5><a class="toc-backref" href="#id959">Syntax:</a><a class="headerlink" href="#id160" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">elt</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id161">
<h5><a class="toc-backref" href="#id960">Overview:</a><a class="headerlink" href="#id161" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; instruction inserts a scalar element into a
vector at a specified index.</p>
</div>
<div class="section" id="id162">
<h5><a class="toc-backref" href="#id961">Arguments:</a><a class="headerlink" href="#id162" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">insertelement</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> type. The second operand is a scalar value whose
type must equal the element type of the first operand. The third operand
is an index indicating the position at which to insert the value. The
index may be a variable of any integer type.</p>
</div>
<div class="section" id="id163">
<h5><a class="toc-backref" href="#id962">Semantics:</a><a class="headerlink" href="#id163" title="永久链接至标题">¶</a></h5>
<p>The result is a vector of the same type as <code class="docutils literal"><span class="pre">val</span></code>. Its element values
are those of <code class="docutils literal"><span class="pre">val</span></code> except at position <code class="docutils literal"><span class="pre">idx</span></code>, where it gets the value
<code class="docutils literal"><span class="pre">elt</span></code>. If <code class="docutils literal"><span class="pre">idx</span></code> exceeds the length of <code class="docutils literal"><span class="pre">val</span></code>, the results are
undefined.</p>
</div>
<div class="section" id="id164">
<h5><a class="toc-backref" href="#id963">Example:</a><a class="headerlink" href="#id164" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = insertelement &lt;4 x i32&gt; %vec, i32 1, i32 0    ; yields &lt;4 x i32&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="shufflevector-instruction">
<span id="i-shufflevector"></span><h4><a class="toc-backref" href="#id964">&#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; Instruction</a><a class="headerlink" href="#shufflevector-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id165">
<h5><a class="toc-backref" href="#id965">Syntax:</a><a class="headerlink" href="#id165" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">shufflevector</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">v1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">n</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">v2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">m</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">m</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id166">
<h5><a class="toc-backref" href="#id966">Overview:</a><a class="headerlink" href="#id166" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; instruction constructs a permutation of elements
from two input vectors, returning a vector with the same element type as
the input and length that is the same as the shuffle mask.</p>
</div>
<div class="section" id="id167">
<h5><a class="toc-backref" href="#id967">Arguments:</a><a class="headerlink" href="#id167" title="永久链接至标题">¶</a></h5>
<p>The first two operands of a &#8216;<code class="docutils literal"><span class="pre">shufflevector</span></code>&#8216; instruction are vectors
with the same type. The third argument is a shuffle mask whose element
type is always &#8216;i32&#8217;. The result of the instruction is a vector whose
length is the same as the shuffle mask and whose element type is the
same as the element type of the first two operands.</p>
<p>The shuffle mask operand is required to be a constant vector with either
constant integer or undef values.</p>
</div>
<div class="section" id="id168">
<h5><a class="toc-backref" href="#id968">Semantics:</a><a class="headerlink" href="#id168" title="永久链接至标题">¶</a></h5>
<p>The elements of the two input vectors are numbered from left to right
across both of the vectors. The shuffle mask operand specifies, for each
element of the result vector, which element of the two input vectors the
result element gets. The element selector may be undef (meaning &#8220;don&#8217;t
care&#8221;) and the second operand may be undef if performing a shuffle from
only one vector.</p>
</div>
<div class="section" id="id169">
<h5><a class="toc-backref" href="#id969">Example:</a><a class="headerlink" href="#id169" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2,
                        &lt;4 x i32&gt; &lt;i32 0, i32 4, i32 1, i32 5&gt;  ; yields &lt;4 x i32&gt;
&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; undef,
                        &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;  ; yields &lt;4 x i32&gt; - Identity shuffle.
&lt;result&gt; = shufflevector &lt;8 x i32&gt; %v1, &lt;8 x i32&gt; undef,
                        &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;  ; yields &lt;4 x i32&gt;
&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2,
                        &lt;8 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 &gt;  ; yields &lt;8 x i32&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="aggregate-operations">
<h3><a class="toc-backref" href="#id970">Aggregate Operations</a><a class="headerlink" href="#aggregate-operations" title="永久链接至标题">¶</a></h3>
<p>LLVM supports several instructions for working with
<a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> values.</p>
<div class="section" id="extractvalue-instruction">
<span id="i-extractvalue"></span><h4><a class="toc-backref" href="#id971">&#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; Instruction</a><a class="headerlink" href="#extractvalue-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id170">
<h5><a class="toc-backref" href="#id972">Syntax:</a><a class="headerlink" href="#id170" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">extractvalue</span> <span class="o">&lt;</span><span class="n">aggregate</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>
</pre></div>
</div>
</div>
<div class="section" id="id171">
<h5><a class="toc-backref" href="#id973">Overview:</a><a class="headerlink" href="#id171" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; instruction extracts the value of a member field
from an <a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> value.</p>
</div>
<div class="section" id="id172">
<h5><a class="toc-backref" href="#id974">Arguments:</a><a class="headerlink" href="#id172" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-struct"><span class="std std-ref">struct</span></a> or <a class="reference internal" href="#t-array"><span class="std std-ref">array</span></a> type. The other operands are
constant indices to specify which value to extract in a similar manner
as indices in a &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction.</p>
<p>The major differences to <code class="docutils literal"><span class="pre">getelementptr</span></code> indexing are:</p>
<ul class="simple">
<li>Since the value being indexed is not a pointer, the first index is
omitted and assumed to be zero.</li>
<li>At least one index must be specified.</li>
<li>Not only struct indices but also array indices must be in bounds.</li>
</ul>
</div>
<div class="section" id="id173">
<h5><a class="toc-backref" href="#id975">Semantics:</a><a class="headerlink" href="#id173" title="永久链接至标题">¶</a></h5>
<p>The result is the value at the position in the aggregate specified by
the index operands.</p>
</div>
<div class="section" id="id174">
<h5><a class="toc-backref" href="#id976">Example:</a><a class="headerlink" href="#id174" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = extractvalue {i32, float} %agg, 0    ; yields i32
</pre></div>
</div>
</div>
</div>
<div class="section" id="insertvalue-instruction">
<span id="i-insertvalue"></span><h4><a class="toc-backref" href="#id977">&#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; Instruction</a><a class="headerlink" href="#insertvalue-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id175">
<h5><a class="toc-backref" href="#id978">Syntax:</a><a class="headerlink" href="#id175" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">insertvalue</span> <span class="o">&lt;</span><span class="n">aggregate</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">elt</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>    <span class="p">;</span> <span class="n">yields</span> <span class="o">&lt;</span><span class="n">aggregate</span> <span class="nb">type</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id176">
<h5><a class="toc-backref" href="#id979">Overview:</a><a class="headerlink" href="#id176" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; instruction inserts a value into a member field in
an <a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> value.</p>
</div>
<div class="section" id="id177">
<h5><a class="toc-backref" href="#id980">Arguments:</a><a class="headerlink" href="#id177" title="永久链接至标题">¶</a></h5>
<p>The first operand of an &#8216;<code class="docutils literal"><span class="pre">insertvalue</span></code>&#8216; instruction is a value of
<a class="reference internal" href="#t-struct"><span class="std std-ref">struct</span></a> or <a class="reference internal" href="#t-array"><span class="std std-ref">array</span></a> type. The second operand is
a first-class value to insert. The following operands are constant
indices indicating the position at which to insert the value in a
similar manner as indices in a &#8216;<code class="docutils literal"><span class="pre">extractvalue</span></code>&#8216; instruction. The value
to insert must have the same type as the value identified by the
indices.</p>
</div>
<div class="section" id="id178">
<h5><a class="toc-backref" href="#id981">Semantics:</a><a class="headerlink" href="#id178" title="永久链接至标题">¶</a></h5>
<p>The result is an aggregate of the same type as <code class="docutils literal"><span class="pre">val</span></code>. Its value is
that of <code class="docutils literal"><span class="pre">val</span></code> except that the value at the position specified by the
indices is that of <code class="docutils literal"><span class="pre">elt</span></code>.</p>
</div>
<div class="section" id="id179">
<h5><a class="toc-backref" href="#id982">Example:</a><a class="headerlink" href="#id179" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%agg1</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="kt">float</span><span class="p">}</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span>              <span class="c">; yields {i32 1, float undef}</span>
<span class="nv">%agg2</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="kt">float</span><span class="p">}</span> <span class="nv">%agg1</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%val</span><span class="p">,</span> <span class="m">1</span>         <span class="c">; yields {i32 1, float %val}</span>
<span class="nv">%agg3</span> <span class="p">=</span> <span class="k">insertvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">{</span><span class="kt">float</span><span class="p">}}</span> <span class="k">undef</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%val</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span>    <span class="c">; yields {i32 undef, {float %val}}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="memory-access-and-addressing-operations">
<span id="memoryops"></span><h3><a class="toc-backref" href="#id983">Memory Access and Addressing Operations</a><a class="headerlink" href="#memory-access-and-addressing-operations" title="永久链接至标题">¶</a></h3>
<p>A key design point of an SSA-based representation is how it represents
memory. In LLVM, no memory locations are in SSA form, which makes things
very simple. This section describes how to read, write, and allocate
memory in LLVM.</p>
<div class="section" id="alloca-instruction">
<span id="i-alloca"></span><h4><a class="toc-backref" href="#id984">&#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; Instruction</a><a class="headerlink" href="#alloca-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id180">
<h5><a class="toc-backref" href="#id985">Syntax:</a><a class="headerlink" href="#id180" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">alloca</span> <span class="p">[</span><span class="n">inalloca</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="p">[,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">NumElements</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[,</span> <span class="n">align</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">]</span>     <span class="p">;</span> <span class="n">yields</span> <span class="nb">type</span><span class="o">*</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id181">
<h5><a class="toc-backref" href="#id986">Overview:</a><a class="headerlink" href="#id181" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; instruction allocates memory on the stack frame of the
currently executing function, to be automatically released when this
function returns to its caller. The object is always allocated in the
generic address space (address space zero).</p>
</div>
<div class="section" id="id182">
<h5><a class="toc-backref" href="#id987">Arguments:</a><a class="headerlink" href="#id182" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; instruction allocates <code class="docutils literal"><span class="pre">sizeof(&lt;type&gt;)*NumElements</span></code>
bytes of memory on the runtime stack, returning a pointer of the
appropriate type to the program. If &#8220;NumElements&#8221; is specified, it is
the number of elements allocated, otherwise &#8220;NumElements&#8221; is defaulted
to be one. If a constant alignment is specified, the value result of the
allocation is guaranteed to be aligned to at least that boundary. The
alignment may not be greater than <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>. If not specified, or if
zero, the target can choose to align the allocation on any convenient
boundary compatible with the type.</p>
<p>&#8216;<code class="docutils literal"><span class="pre">type</span></code>&#8216; may be any sized type.</p>
</div>
<div class="section" id="id183">
<h5><a class="toc-backref" href="#id988">Semantics:</a><a class="headerlink" href="#id183" title="永久链接至标题">¶</a></h5>
<p>Memory is allocated; a pointer is returned. The operation is undefined
if there is insufficient stack space for the allocation. &#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216;d
memory is automatically released when the function returns. The
&#8216;<code class="docutils literal"><span class="pre">alloca</span></code>&#8216; instruction is commonly used to represent automatic
variables that must have an address available. When the function returns
(either with the <code class="docutils literal"><span class="pre">ret</span></code> or <code class="docutils literal"><span class="pre">resume</span></code> instructions), the memory is
reclaimed. Allocating zero bytes is legal, but the result is undefined.
The order in which memory is allocated (ie., which way the stack grows)
is not specified.</p>
</div>
<div class="section" id="id184">
<h5><a class="toc-backref" href="#id989">Example:</a><a class="headerlink" href="#id184" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>                             <span class="c">; yields i32*:ptr</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span>                      <span class="c">; yields i32*:ptr</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">4</span><span class="p">,</span> <span class="k">align</span> <span class="m">1024</span>          <span class="c">; yields i32*:ptr</span>
<span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span><span class="p">,</span> <span class="k">align</span> <span class="m">1024</span>                 <span class="c">; yields i32*:ptr</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="load-instruction">
<span id="i-load"></span><h4><a class="toc-backref" href="#id990">&#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; Instruction</a><a class="headerlink" href="#load-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id185">
<h5><a class="toc-backref" href="#id991">Syntax:</a><a class="headerlink" href="#id185" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span>&lt;result&gt; = load [volatile] &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;index&gt;][, !invariant.load !&lt;index&gt;][, !invariant.group !&lt;index&gt;][, !nonnull !&lt;index&gt;][, !dereferenceable !&lt;deref_bytes_node&gt;][, !dereferenceable_or_null !&lt;deref_bytes_node&gt;][, !align !&lt;align_node&gt;]
&lt;result&gt; = load atomic [volatile] &lt;ty&gt;* &lt;pointer&gt; [singlethread] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;index&gt;]
!&lt;index&gt; = !{ i32 1 }
!&lt;deref_bytes_node&gt; = !{i64 &lt;dereferenceable_bytes&gt;}
!&lt;align_node&gt; = !{ i64 &lt;value_alignment&gt; }
</pre></div>
</div>
</div>
<div class="section" id="id186">
<h5><a class="toc-backref" href="#id992">Overview:</a><a class="headerlink" href="#id186" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">load</span></code>&#8216; instruction is used to read from memory.</p>
</div>
<div class="section" id="id187">
<h5><a class="toc-backref" href="#id993">Arguments:</a><a class="headerlink" href="#id187" title="永久链接至标题">¶</a></h5>
<p>The argument to the <code class="docutils literal"><span class="pre">load</span></code> instruction specifies the memory address
from which to load. The type specified must be a <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first
class</span></a> type. If the <code class="docutils literal"><span class="pre">load</span></code> is marked as <code class="docutils literal"><span class="pre">volatile</span></code>,
then the optimizer is not allowed to modify the number or order of
execution of this <code class="docutils literal"><span class="pre">load</span></code> with other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.</p>
<p>If the <code class="docutils literal"><span class="pre">load</span></code> is marked as <code class="docutils literal"><span class="pre">atomic</span></code>, it takes an extra <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> and optional <code class="docutils literal"><span class="pre">singlethread</span></code> argument. The <code class="docutils literal"><span class="pre">release</span></code> and
<code class="docutils literal"><span class="pre">acq_rel</span></code> orderings are not valid on <code class="docutils literal"><span class="pre">load</span></code> instructions. Atomic loads
produce <a class="reference internal" href="#memmodel"><span class="std std-ref">defined</span></a> results when they may see multiple atomic
stores. The type of the pointee must be an integer, pointer, or floating-point
type whose bit width is a power of two greater than or equal to eight and less
than or equal to a target-specific size limit.  <code class="docutils literal"><span class="pre">align</span></code> must be explicitly
specified on atomic loads, and the load has undefined behavior if the alignment
is not set to a value which is at least the size in bytes of the
pointee. <code class="docutils literal"><span class="pre">!nontemporal</span></code> does not have any defined semantics for atomic loads.</p>
<p>The optional constant <code class="docutils literal"><span class="pre">align</span></code> argument specifies the alignment of the
operation (that is, the alignment of the memory address). A value of 0
or an omitted <code class="docutils literal"><span class="pre">align</span></code> argument means that the operation has the ABI
alignment for the target. It is the responsibility of the code emitter
to ensure that the alignment information is correct. Overestimating the
alignment results in undefined behavior. Underestimating the alignment
may produce less efficient code. An alignment of 1 is always safe. The
maximum possible alignment is <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>.</p>
<p>The optional <code class="docutils literal"><span class="pre">!nontemporal</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with one
<code class="docutils literal"><span class="pre">i32</span></code> entry of value 1. The existence of the <code class="docutils literal"><span class="pre">!nontemporal</span></code>
metadata on the instruction tells the optimizer and code generator
that this load is not expected to be reused in the cache. The code
generator may select special instructions to save cache bandwidth, such
as the <code class="docutils literal"><span class="pre">MOVNT</span></code> instruction on x86.</p>
<p>The optional <code class="docutils literal"><span class="pre">!invariant.load</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with no
entries. The existence of the <code class="docutils literal"><span class="pre">!invariant.load</span></code> metadata on the
instruction tells the optimizer and code generator that the address
operand to this load points to memory which can be assumed unchanged.
Being invariant does not imply that a location is dereferenceable,
but it does imply that once the location is known dereferenceable
its value is henceforth unchanging.</p>
<dl class="docutils">
<dt>The optional <code class="docutils literal"><span class="pre">!invariant.group</span></code> metadata must reference a single metadata name</dt>
<dd><code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node. See <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata.</dd>
</dl>
<p>The optional <code class="docutils literal"><span class="pre">!nonnull</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with no
entries. The existence of the <code class="docutils literal"><span class="pre">!nonnull</span></code> metadata on the
instruction tells the optimizer that the value loaded is known to
never be null. This is analogous to the <code class="docutils literal"><span class="pre">nonnull</span></code> attribute
on parameters and return values. This metadata can only be applied
to loads of a pointer type.</p>
<p>The optional <code class="docutils literal"><span class="pre">!dereferenceable</span></code> metadata must reference a single metadata
name <code class="docutils literal"><span class="pre">&lt;deref_bytes_node&gt;</span></code> corresponding to a metadata node with one <code class="docutils literal"><span class="pre">i64</span></code>
entry. The existence of the <code class="docutils literal"><span class="pre">!dereferenceable</span></code> metadata on the instruction
tells the optimizer that the value loaded is known to be dereferenceable.
The number of bytes known to be dereferenceable is specified by the integer
value in the metadata node. This is analogous to the &#8216;&#8217;dereferenceable&#8217;&#8217;
attribute on parameters and return values. This metadata can only be applied
to loads of a pointer type.</p>
<p>The optional <code class="docutils literal"><span class="pre">!dereferenceable_or_null</span></code> metadata must reference a single
metadata name <code class="docutils literal"><span class="pre">&lt;deref_bytes_node&gt;</span></code> corresponding to a metadata node with one
<code class="docutils literal"><span class="pre">i64</span></code> entry. The existence of the <code class="docutils literal"><span class="pre">!dereferenceable_or_null</span></code> metadata on the
instruction tells the optimizer that the value loaded is known to be either
dereferenceable or null.
The number of bytes known to be dereferenceable is specified by the integer
value in the metadata node. This is analogous to the &#8216;&#8217;dereferenceable_or_null&#8217;&#8217;
attribute on parameters and return values. This metadata can only be applied
to loads of a pointer type.</p>
<p>The optional <code class="docutils literal"><span class="pre">!align</span></code> metadata must reference a single metadata name
<code class="docutils literal"><span class="pre">&lt;align_node&gt;</span></code> corresponding to a metadata node with one <code class="docutils literal"><span class="pre">i64</span></code> entry.
The existence of the <code class="docutils literal"><span class="pre">!align</span></code> metadata on the instruction tells the
optimizer that the value loaded is known to be aligned to a boundary specified
by the integer value in the metadata node. The alignment must be a power of 2.
This is analogous to the &#8216;&#8217;align&#8217;&#8217; attribute on parameters and return values.
This metadata can only be applied to loads of a pointer type.</p>
</div>
<div class="section" id="id188">
<h5><a class="toc-backref" href="#id994">Semantics:</a><a class="headerlink" href="#id188" title="永久链接至标题">¶</a></h5>
<p>The location of memory pointed to is loaded. If the value being loaded
is of scalar type then the number of bytes read does not exceed the
minimum number of bytes needed to hold all bits of the type. For
example, loading an <code class="docutils literal"><span class="pre">i24</span></code> reads at most three bytes. When loading a
value of a type like <code class="docutils literal"><span class="pre">i20</span></code> with a size that is not an integral number
of bytes, the result is undefined if the value was not originally
written using a store of the same type.</p>
</div>
<div class="section" id="id189">
<h5><a class="toc-backref" href="#id995">Examples:</a><a class="headerlink" href="#id189" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>                               <span class="c">; yields i32*:ptr</span>
<span class="k">store</span> <span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                          <span class="c">; yields void</span>
<span class="nv">%val</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                      <span class="c">; yields i32:val = i32 3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="store-instruction">
<span id="i-store"></span><h4><a class="toc-backref" href="#id996">&#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; Instruction</a><a class="headerlink" href="#store-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id190">
<h5><a class="toc-backref" href="#id997">Syntax:</a><a class="headerlink" href="#id190" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span>store [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;index&gt;][, !invariant.group !&lt;index&gt;]        ; yields void
store atomic [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt; [singlethread] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;index&gt;] ; yields void
</pre></div>
</div>
</div>
<div class="section" id="id191">
<h5><a class="toc-backref" href="#id998">Overview:</a><a class="headerlink" href="#id191" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">store</span></code>&#8216; instruction is used to write to memory.</p>
</div>
<div class="section" id="id192">
<h5><a class="toc-backref" href="#id999">Arguments:</a><a class="headerlink" href="#id192" title="永久链接至标题">¶</a></h5>
<p>There are two arguments to the <code class="docutils literal"><span class="pre">store</span></code> instruction: a value to store
and an address at which to store it. The type of the <code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>
operand must be a pointer to the <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type of
the <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> operand. If the <code class="docutils literal"><span class="pre">store</span></code> is marked as <code class="docutils literal"><span class="pre">volatile</span></code>,
then the optimizer is not allowed to modify the number or order of
execution of this <code class="docutils literal"><span class="pre">store</span></code> with other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.</p>
<p>If the <code class="docutils literal"><span class="pre">store</span></code> is marked as <code class="docutils literal"><span class="pre">atomic</span></code>, it takes an extra <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> and optional <code class="docutils literal"><span class="pre">singlethread</span></code> argument. The <code class="docutils literal"><span class="pre">acquire</span></code> and
<code class="docutils literal"><span class="pre">acq_rel</span></code> orderings aren&#8217;t valid on <code class="docutils literal"><span class="pre">store</span></code> instructions. Atomic loads
produce <a class="reference internal" href="#memmodel"><span class="std std-ref">defined</span></a> results when they may see multiple atomic
stores. The type of the pointee must be an integer, pointer, or floating-point
type whose bit width is a power of two greater than or equal to eight and less
than or equal to a target-specific size limit.  <code class="docutils literal"><span class="pre">align</span></code> must be explicitly
specified on atomic stores, and the store has undefined behavior if the
alignment is not set to a value which is at least the size in bytes of the
pointee. <code class="docutils literal"><span class="pre">!nontemporal</span></code> does not have any defined semantics for atomic stores.</p>
<p>The optional constant <code class="docutils literal"><span class="pre">align</span></code> argument specifies the alignment of the
operation (that is, the alignment of the memory address). A value of 0
or an omitted <code class="docutils literal"><span class="pre">align</span></code> argument means that the operation has the ABI
alignment for the target. It is the responsibility of the code emitter
to ensure that the alignment information is correct. Overestimating the
alignment results in undefined behavior. Underestimating the
alignment may produce less efficient code. An alignment of 1 is always
safe. The maximum possible alignment is <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">29</span></code>.</p>
<p>The optional <code class="docutils literal"><span class="pre">!nontemporal</span></code> metadata must reference a single metadata
name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code> corresponding to a metadata node with one <code class="docutils literal"><span class="pre">i32</span></code> entry of
value 1. The existence of the <code class="docutils literal"><span class="pre">!nontemporal</span></code> metadata on the instruction
tells the optimizer and code generator that this load is not expected to
be reused in the cache. The code generator may select special
instructions to save cache bandwidth, such as the <code class="docutils literal"><span class="pre">MOVNT</span></code> instruction on
x86.</p>
<p>The optional <code class="docutils literal"><span class="pre">!invariant.group</span></code> metadata must reference a
single metadata name <code class="docutils literal"><span class="pre">&lt;index&gt;</span></code>. See <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata.</p>
</div>
<div class="section" id="id193">
<h5><a class="toc-backref" href="#id1000">Semantics:</a><a class="headerlink" href="#id193" title="永久链接至标题">¶</a></h5>
<p>The contents of memory are updated to contain <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> at the
location specified by the <code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code> operand. If <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> is
of scalar type then the number of bytes written does not exceed the
minimum number of bytes needed to hold all bits of the type. For
example, storing an <code class="docutils literal"><span class="pre">i24</span></code> writes at most three bytes. When writing a
value of a type like <code class="docutils literal"><span class="pre">i20</span></code> with a size that is not an integral number
of bytes, it is unspecified what happens to the extra bits that do not
belong to the type, but they will typically be overwritten.</p>
</div>
<div class="section" id="id194">
<h5><a class="toc-backref" href="#id1001">Example:</a><a class="headerlink" href="#id194" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%ptr</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>                               <span class="c">; yields i32*:ptr</span>
<span class="k">store</span> <span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                          <span class="c">; yields void</span>
<span class="nv">%val</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span>                      <span class="c">; yields i32:val = i32 3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fence-instruction">
<span id="i-fence"></span><h4><a class="toc-backref" href="#id1002">&#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; Instruction</a><a class="headerlink" href="#fence-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id195">
<h5><a class="toc-backref" href="#id1003">Syntax:</a><a class="headerlink" href="#id195" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fence</span> <span class="p">[</span><span class="n">singlethread</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ordering</span><span class="o">&gt;</span>                   <span class="p">;</span> <span class="n">yields</span> <span class="n">void</span>
</pre></div>
</div>
</div>
<div class="section" id="id196">
<h5><a class="toc-backref" href="#id1004">Overview:</a><a class="headerlink" href="#id196" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; instruction is used to introduce happens-before edges
between operations.</p>
</div>
<div class="section" id="id197">
<h5><a class="toc-backref" href="#id1005">Arguments:</a><a class="headerlink" href="#id197" title="永久链接至标题">¶</a></h5>
<p>&#8216;<code class="docutils literal"><span class="pre">fence</span></code>&#8216; instructions take an <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> argument which
defines what <em>synchronizes-with</em> edges they add. They can only be given
<code class="docutils literal"><span class="pre">acquire</span></code>, <code class="docutils literal"><span class="pre">release</span></code>, <code class="docutils literal"><span class="pre">acq_rel</span></code>, and <code class="docutils literal"><span class="pre">seq_cst</span></code> orderings.</p>
</div>
<div class="section" id="id198">
<h5><a class="toc-backref" href="#id1006">Semantics:</a><a class="headerlink" href="#id198" title="永久链接至标题">¶</a></h5>
<p>A fence A which has (at least) <code class="docutils literal"><span class="pre">release</span></code> ordering semantics
<em>synchronizes with</em> a fence B with (at least) <code class="docutils literal"><span class="pre">acquire</span></code> ordering
semantics if and only if there exist atomic operations X and Y, both
operating on some atomic object M, such that A is sequenced before X, X
modifies M (either directly or through some side effect of a sequence
headed by X), Y is sequenced before B, and Y observes M. This provides a
<em>happens-before</em> dependency between A and B. Rather than an explicit
<code class="docutils literal"><span class="pre">fence</span></code>, one (but not both) of the atomic operations X or Y might
provide a <code class="docutils literal"><span class="pre">release</span></code> or <code class="docutils literal"><span class="pre">acquire</span></code> (resp.) ordering constraint and
still <em>synchronize-with</em> the explicit <code class="docutils literal"><span class="pre">fence</span></code> and establish the
<em>happens-before</em> edge.</p>
<p>A <code class="docutils literal"><span class="pre">fence</span></code> which has <code class="docutils literal"><span class="pre">seq_cst</span></code> ordering, in addition to having both
<code class="docutils literal"><span class="pre">acquire</span></code> and <code class="docutils literal"><span class="pre">release</span></code> semantics specified above, participates in
the global program order of other <code class="docutils literal"><span class="pre">seq_cst</span></code> operations and/or fences.</p>
<p>The optional &#8220;<a class="reference internal" href="#singlethread"><span class="std std-ref">singlethread</span></a>&#8221; argument specifies
that the fence only synchronizes with other fences in the same thread.
(This is useful for interacting with signal handlers.)</p>
</div>
<div class="section" id="id199">
<h5><a class="toc-backref" href="#id1007">Example:</a><a class="headerlink" href="#id199" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">fence</span> <span class="k">acquire</span>                          <span class="c">; yields void</span>
<span class="k">fence</span> <span class="k">singlethread</span> <span class="k">seq_cst</span>             <span class="c">; yields void</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cmpxchg-instruction">
<span id="i-cmpxchg"></span><h4><a class="toc-backref" href="#id1008">&#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; Instruction</a><a class="headerlink" href="#cmpxchg-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id200">
<h5><a class="toc-backref" href="#id1009">Syntax:</a><a class="headerlink" href="#id200" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cmpxchg</span> <span class="p">[</span><span class="n">weak</span><span class="p">]</span> <span class="p">[</span><span class="n">volatile</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nb">cmp</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">new</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">singlethread</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">success</span> <span class="n">ordering</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">failure</span> <span class="n">ordering</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">yields</span>  <span class="p">{</span> <span class="n">ty</span><span class="p">,</span> <span class="n">i1</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id201">
<h5><a class="toc-backref" href="#id1010">Overview:</a><a class="headerlink" href="#id201" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; instruction is used to atomically modify memory. It
loads a value in memory and compares it to a given value. If they are
equal, it tries to store a new value into the memory.</p>
</div>
<div class="section" id="id202">
<h5><a class="toc-backref" href="#id1011">Arguments:</a><a class="headerlink" href="#id202" title="永久链接至标题">¶</a></h5>
<p>There are three arguments to the &#8216;<code class="docutils literal"><span class="pre">cmpxchg</span></code>&#8216; instruction: an address
to operate on, a value to compare to the value currently be at that
address, and a new value to place at that address if the compared values
are equal. The type of &#8216;&lt;cmp&gt;&#8217; must be an integer type whose bit width
is a power of two greater than or equal to eight and less than or equal
to a target-specific size limit. &#8216;&lt;cmp&gt;&#8217; and &#8216;&lt;new&gt;&#8217; must have the same
type, and the type of &#8216;&lt;pointer&gt;&#8217; must be a pointer to that type. If the
<code class="docutils literal"><span class="pre">cmpxchg</span></code> is marked as <code class="docutils literal"><span class="pre">volatile</span></code>, then the optimizer is not allowed
to modify the number or order of execution of this <code class="docutils literal"><span class="pre">cmpxchg</span></code> with
other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operations</span></a>.</p>
<p>The success and failure <a class="reference internal" href="#ordering"><span class="std std-ref">ordering</span></a> arguments specify how this
<code class="docutils literal"><span class="pre">cmpxchg</span></code> synchronizes with other atomic operations. Both ordering parameters
must be at least <code class="docutils literal"><span class="pre">monotonic</span></code>, the ordering constraint on failure must be no
stronger than that on success, and the failure ordering cannot be either
<code class="docutils literal"><span class="pre">release</span></code> or <code class="docutils literal"><span class="pre">acq_rel</span></code>.</p>
<p>The optional &#8220;<code class="docutils literal"><span class="pre">singlethread</span></code>&#8221; argument declares that the <code class="docutils literal"><span class="pre">cmpxchg</span></code>
is only atomic with respect to code (usually signal handlers) running in
the same thread as the <code class="docutils literal"><span class="pre">cmpxchg</span></code>. Otherwise the cmpxchg is atomic with
respect to all other code in the system.</p>
<p>The pointer passed into cmpxchg must have alignment greater than or
equal to the size in memory of the operand.</p>
</div>
<div class="section" id="id203">
<h5><a class="toc-backref" href="#id1012">Semantics:</a><a class="headerlink" href="#id203" title="永久链接至标题">¶</a></h5>
<p>The contents of memory at the location specified by the &#8216;<code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>&#8216; operand
is read and compared to &#8216;<code class="docutils literal"><span class="pre">&lt;cmp&gt;</span></code>&#8216;; if the read value is the equal, the
&#8216;<code class="docutils literal"><span class="pre">&lt;new&gt;</span></code>&#8216; is written. The original value at the location is returned, together
with a flag indicating success (true) or failure (false).</p>
<p>If the cmpxchg operation is marked as <code class="docutils literal"><span class="pre">weak</span></code> then a spurious failure is
permitted: the operation may not write <code class="docutils literal"><span class="pre">&lt;new&gt;</span></code> even if the comparison
matched.</p>
<p>If the cmpxchg operation is strong (the default), the i1 value is 1 if and only
if the value loaded equals <code class="docutils literal"><span class="pre">cmp</span></code>.</p>
<p>A successful <code class="docutils literal"><span class="pre">cmpxchg</span></code> is a read-modify-write instruction for the purpose of
identifying release sequences. A failed <code class="docutils literal"><span class="pre">cmpxchg</span></code> is equivalent to an atomic
load with an ordering parameter determined the second ordering parameter.</p>
</div>
<div class="section" id="id204">
<h5><a class="toc-backref" href="#id1013">Example:</a><a class="headerlink" href="#id204" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
  <span class="nv">%orig</span> <span class="p">=</span> <span class="k">atomic</span> <span class="k">load</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span> <span class="k">unordered</span>                <span class="c">; yields i32</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">loop:</span>
  <span class="nv">%cmp</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%orig</span><span class="p">,</span> <span class="nv">%entry</span> <span class="p">],</span> <span class="p">[</span><span class="nv">%old</span><span class="p">,</span> <span class="nv">%loop</span><span class="p">]</span>
  <span class="nv">%squared</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i32</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="nv">%cmp</span>
  <span class="nv">%val_success</span> <span class="p">=</span> <span class="k">cmpxchg</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%cmp</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%squared</span> <span class="k">acq_rel</span> <span class="k">monotonic</span> <span class="c">; yields  { i32, i1 }</span>
  <span class="nv">%value_loaded</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i1</span> <span class="p">}</span> <span class="nv">%val_success</span><span class="p">,</span> <span class="m">0</span>
  <span class="nv">%success</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i1</span> <span class="p">}</span> <span class="nv">%val_success</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%success</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%done</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%loop</span>

<span class="nl">done:</span>
  <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="atomicrmw-instruction">
<span id="i-atomicrmw"></span><h4><a class="toc-backref" href="#id1014">&#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; Instruction</a><a class="headerlink" href="#atomicrmw-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id205">
<h5><a class="toc-backref" href="#id1015">Syntax:</a><a class="headerlink" href="#id205" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">atomicrmw</span> <span class="p">[</span><span class="n">volatile</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">operation</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">singlethread</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ordering</span><span class="o">&gt;</span>                   <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span>
</pre></div>
</div>
</div>
<div class="section" id="id206">
<h5><a class="toc-backref" href="#id1016">Overview:</a><a class="headerlink" href="#id206" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; instruction is used to atomically modify memory.</p>
</div>
<div class="section" id="id207">
<h5><a class="toc-backref" href="#id1017">Arguments:</a><a class="headerlink" href="#id207" title="永久链接至标题">¶</a></h5>
<p>There are three arguments to the &#8216;<code class="docutils literal"><span class="pre">atomicrmw</span></code>&#8216; instruction: an
operation to apply, an address whose value to modify, an argument to the
operation. The operation must be one of the following keywords:</p>
<ul class="simple">
<li>xchg</li>
<li>add</li>
<li>sub</li>
<li>and</li>
<li>nand</li>
<li>or</li>
<li>xor</li>
<li>max</li>
<li>min</li>
<li>umax</li>
<li>umin</li>
</ul>
<p>The type of &#8216;&lt;value&gt;&#8217; must be an integer type whose bit width is a power
of two greater than or equal to eight and less than or equal to a
target-specific size limit. The type of the &#8216;<code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>&#8216; operand must
be a pointer to that type. If the <code class="docutils literal"><span class="pre">atomicrmw</span></code> is marked as
<code class="docutils literal"><span class="pre">volatile</span></code>, then the optimizer is not allowed to modify the number or
order of execution of this <code class="docutils literal"><span class="pre">atomicrmw</span></code> with other <a class="reference internal" href="#volatile"><span class="std std-ref">volatile
operations</span></a>.</p>
</div>
<div class="section" id="id208">
<h5><a class="toc-backref" href="#id1018">Semantics:</a><a class="headerlink" href="#id208" title="永久链接至标题">¶</a></h5>
<p>The contents of memory at the location specified by the &#8216;<code class="docutils literal"><span class="pre">&lt;pointer&gt;</span></code>&#8216;
operand are atomically read, modified, and written back. The original
value at the location is returned. The modification is specified by the
operation argument:</p>
<ul class="simple">
<li>xchg: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">val</span></code></li>
<li>add: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">+</span> <span class="pre">val</span></code></li>
<li>sub: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">-</span> <span class="pre">val</span></code></li>
<li>and: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&amp;</span> <span class="pre">val</span></code></li>
<li>nand: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(*ptr</span> <span class="pre">&amp;</span> <span class="pre">val)</span></code></li>
<li>or: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">|</span> <span class="pre">val</span></code></li>
<li>xor: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">^</span> <span class="pre">val</span></code></li>
<li>max: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&gt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using a signed comparison)</li>
<li>min: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&lt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using a signed comparison)</li>
<li>umax: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&gt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using an unsigned
comparison)</li>
<li>umin: <code class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">*ptr</span> <span class="pre">&lt;</span> <span class="pre">val</span> <span class="pre">?</span> <span class="pre">*ptr</span> <span class="pre">:</span> <span class="pre">val</span></code> (using an unsigned
comparison)</li>
</ul>
</div>
<div class="section" id="id209">
<h5><a class="toc-backref" href="#id1019">Example:</a><a class="headerlink" href="#id209" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%old</span> <span class="p">=</span> <span class="k">atomicrmw</span> <span class="k">add</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span> <span class="k">acquire</span>                        <span class="c">; yields i32</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="getelementptr-instruction">
<span id="i-getelementptr"></span><h4><a class="toc-backref" href="#id1020">&#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; Instruction</a><a class="headerlink" href="#getelementptr-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id210">
<h5><a class="toc-backref" href="#id1021">Syntax:</a><a class="headerlink" href="#id210" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="n">inbounds</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span><span class="p">{,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span><span class="p">}</span><span class="o">*</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ptr</span> <span class="n">vector</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">vector</span> <span class="n">index</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">idx</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id211">
<h5><a class="toc-backref" href="#id1022">Overview:</a><a class="headerlink" href="#id211" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction is used to get the address of a
subelement of an <a class="reference internal" href="#t-aggregate"><span class="std std-ref">aggregate</span></a> data structure. It performs
address calculation only and does not access memory. The instruction can also
be used to calculate a vector of such addresses.</p>
</div>
<div class="section" id="id212">
<h5><a class="toc-backref" href="#id1023">Arguments:</a><a class="headerlink" href="#id212" title="永久链接至标题">¶</a></h5>
<p>The first argument is always a type used as the basis for the calculations.
The second argument is always a pointer or a vector of pointers, and is the
base address to start from. The remaining arguments are indices
that indicate which of the elements of the aggregate object are indexed.
The interpretation of each index is dependent on the type being indexed
into. The first index always indexes the pointer value given as the
first argument, the second index indexes a value of the type pointed to
(not necessarily the value directly pointed to, since the first index
can be non-zero), etc. The first type indexed into must be a pointer
value, subsequent types can be arrays, vectors, and structs. Note that
subsequent types being indexed into can never be pointers, since that
would require loading the pointer before continuing calculation.</p>
<p>The type of each index argument depends on the type it is indexing into.
When indexing into a (optionally packed) structure, only <code class="docutils literal"><span class="pre">i32</span></code> integer
<strong>constants</strong> are allowed (when using a vector of indices they must all
be the <strong>same</strong> <code class="docutils literal"><span class="pre">i32</span></code> integer constant). When indexing into an array,
pointer or vector, integers of any width are allowed, and they are not
required to be constant. These integers are treated as signed values
where relevant.</p>
<p>For example, let&#8217;s consider a C code fragment and how it gets compiled
to LLVM:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RT</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">A</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">C</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ST</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">Y</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">RT</span> <span class="n">Z</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="o">*</span><span class="nf">foo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ST</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Z</span><span class="p">.</span><span class="n">B</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">13</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The LLVM code generated by Clang is:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%struct.RT</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i8</span><span class="p">,</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]],</span> <span class="k">i8</span> <span class="p">}</span>
<span class="nv">%struct.ST</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="nv">%struct.RT</span> <span class="p">}</span>

<span class="k">define</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@foo</span><span class="p">(</span><span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">)</span> <span class="k">nounwind</span> <span class="k">uwtable</span> <span class="k">readnone</span> <span class="k">optsize</span> <span class="k">ssp</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%arrayidx</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="nv">%struct.ST</span><span class="p">,</span> <span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">,</span> <span class="k">i64</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i64</span> <span class="m">5</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span>
  <span class="k">ret</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%arrayidx</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id213">
<h5><a class="toc-backref" href="#id1024">Semantics:</a><a class="headerlink" href="#id213" title="永久链接至标题">¶</a></h5>
<p>In the example above, the first index is indexing into the
&#8216;<code class="docutils literal"><span class="pre">%struct.ST*</span></code>&#8216; type, which is a pointer, yielding a &#8216;<code class="docutils literal"><span class="pre">%struct.ST</span></code>&#8216;
= &#8216;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i32,</span> <span class="pre">double,</span> <span class="pre">%struct.RT</span> <span class="pre">}</span></code>&#8216; type, a structure. The second index
indexes into the third element of the structure, yielding a
&#8216;<code class="docutils literal"><span class="pre">%struct.RT</span></code>&#8216; = &#8216;<code class="docutils literal"><span class="pre">{</span> <span class="pre">i8</span> <span class="pre">,</span> <span class="pre">[10</span> <span class="pre">x</span> <span class="pre">[20</span> <span class="pre">x</span> <span class="pre">i32]],</span> <span class="pre">i8</span> <span class="pre">}</span></code>&#8216; type, another
structure. The third index indexes into the second element of the
structure, yielding a &#8216;<code class="docutils literal"><span class="pre">[10</span> <span class="pre">x</span> <span class="pre">[20</span> <span class="pre">x</span> <span class="pre">i32]]</span></code>&#8216; type, an array. The two
dimensions of the array are subscripted into, yielding an &#8216;<code class="docutils literal"><span class="pre">i32</span></code>&#8216;
type. The &#8216;<code class="docutils literal"><span class="pre">getelementptr</span></code>&#8216; instruction returns a pointer to this
element, thus computing a value of &#8216;<code class="docutils literal"><span class="pre">i32*</span></code>&#8216; type.</p>
<p>Note that it is perfectly legal to index partially through a structure,
returning a pointer to an inner element. Because of this, the LLVM code
for the given testcase is equivalent to:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@foo</span><span class="p">(</span><span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%t1</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%struct.ST</span><span class="p">,</span> <span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%s</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>                        <span class="c">; yields %struct.ST*:%t1</span>
  <span class="nv">%t2</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%struct.ST</span><span class="p">,</span> <span class="nv">%struct.ST</span><span class="p">*</span> <span class="nv">%t1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span>                <span class="c">; yields %struct.RT*:%t2</span>
  <span class="nv">%t3</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%struct.RT</span><span class="p">,</span> <span class="nv">%struct.RT</span><span class="p">*</span> <span class="nv">%t2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>                <span class="c">; yields [10 x [20 x i32]]*:%t3</span>
  <span class="nv">%t4</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]],</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]]*</span> <span class="nv">%t3</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">5</span>  <span class="c">; yields [20 x i32]*:%t4</span>
  <span class="nv">%t5</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">],</span> <span class="p">[</span><span class="m">20</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]*</span> <span class="nv">%t4</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">13</span>               <span class="c">; yields i32*:%t5</span>
  <span class="k">ret</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%t5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal"><span class="pre">inbounds</span></code> keyword is present, the result value of the
<code class="docutils literal"><span class="pre">getelementptr</span></code> is a <a class="reference internal" href="#poisonvalues"><span class="std std-ref">poison value</span></a> if the base
pointer is not an <em>in bounds</em> address of an allocated object, or if any
of the addresses that would be formed by successive addition of the
offsets implied by the indices to the base address with infinitely
precise signed arithmetic are not an <em>in bounds</em> address of that
allocated object. The <em>in bounds</em> addresses for an allocated object are
all the addresses that point into the object, plus the address one byte
past the end. In cases where the base is a vector of pointers the
<code class="docutils literal"><span class="pre">inbounds</span></code> keyword applies to each of the computations element-wise.</p>
<p>If the <code class="docutils literal"><span class="pre">inbounds</span></code> keyword is not present, the offsets are added to the
base address with silently-wrapping two&#8217;s complement arithmetic. If the
offsets have a different width from the pointer, they are sign-extended
or truncated to the width of the pointer. The result value of the
<code class="docutils literal"><span class="pre">getelementptr</span></code> may be outside the object pointed to by the base
pointer. The result value may not necessarily be used to access memory
though, even if it happens to point into allocated storage. See the
<a class="reference internal" href="#pointeraliasing"><span class="std std-ref">Pointer Aliasing Rules</span></a> section for more
information.</p>
<p>The getelementptr instruction is often confusing. For some more insight
into how it works, see <a class="reference internal" href="GetElementPtr.html"><span class="doc">the getelementptr FAQ</span></a>.</p>
</div>
<div class="section" id="id214">
<h5><a class="toc-backref" href="#id1025">Example:</a><a class="headerlink" href="#id214" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; yields [12 x i8]*:aptr</span>
<span class="nv">%aptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]},</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]}*</span> <span class="nv">%saptr</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
<span class="c">; yields i8*:vptr</span>
<span class="nv">%vptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;},</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;}*</span> <span class="nv">%svptr</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
<span class="c">; yields i8*:eptr</span>
<span class="nv">%eptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">12</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="nv">%aptr</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span>
<span class="c">; yields i32*:iptr</span>
<span class="nv">%iptr</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i32</span><span class="p">],</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i32</span><span class="p">]*</span> <span class="vg">@arr</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span>
</pre></div>
</div>
</div>
<div class="section" id="vector-of-pointers">
<h5><a class="toc-backref" href="#id1026">Vector of pointers:</a><a class="headerlink" href="#vector-of-pointers" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">getelementptr</span></code> returns a vector of pointers, instead of a single address,
when one or more of its arguments is a vector. In such cases, all vector
arguments should have the same number of elements, and every scalar argument
will be effectively broadcast into a vector during address calculation.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; All arguments are vectors:</span>
<span class="c">;   A[i] = ptrs[i] + offsets[i]*sizeof(i8)</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i8</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*&gt;</span> <span class="nv">%ptrs</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%offsets</span>

<span class="c">; Add the same scalar offset to each pointer of a vector:</span>
<span class="c">;   A[i] = ptrs[i] + offset*sizeof(i8)</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i8</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*&gt;</span> <span class="nv">%ptrs</span><span class="p">,</span> <span class="k">i64</span> <span class="nv">%offset</span>

<span class="c">; Add distinct offsets to the same pointer:</span>
<span class="c">;   A[i] = ptr + offsets[i]*sizeof(i8)</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="k">i8</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%offsets</span>

<span class="c">; In all cases described above the type of the result is &lt;4 x i8*&gt;</span>
</pre></div>
</div>
<p>The two following instructions are equivalent:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">getelementptr</span>  <span class="nv">%struct.ST</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="nv">%struct.ST</span><span class="p">*&gt;</span> <span class="nv">%s</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%ind1</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">&gt;,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">&gt;,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%ind4</span><span class="p">,</span>
  <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i64</span> <span class="m">13</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span><span class="p">&gt;</span>

<span class="k">getelementptr</span>  <span class="nv">%struct.ST</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="nv">%struct.ST</span><span class="p">*&gt;</span> <span class="nv">%s</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span> <span class="nv">%ind1</span><span class="p">,</span>
  <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%ind4</span><span class="p">,</span> <span class="k">i64</span> <span class="m">13</span>
</pre></div>
</div>
<p>Let&#8217;s look at the C code, where the vector version of <code class="docutils literal"><span class="pre">getelementptr</span></code>
makes sense:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Let&#39;s assume that we vectorize the following loop:</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">;</span> <span class="kt">int</span> <span class="o">*</span><span class="n">C</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; get pointers for 8 elements from array B</span>
<span class="nv">%ptrs</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">*</span> <span class="nv">%B</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%C</span>
<span class="c">; load 8 elements from array B into A</span>
<span class="nv">%A</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="kt">double</span><span class="p">&gt;</span> <span class="vg">@llvm.masked.gather.v8f64</span><span class="p">(&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="kt">double</span><span class="p">*&gt;</span> <span class="nv">%ptrs</span><span class="p">,</span>
     <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="k">i1</span><span class="p">&gt;</span> <span class="nv">%mask</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">8</span> <span class="k">x</span> <span class="kt">double</span><span class="p">&gt;</span> <span class="nv">%passthru</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="conversion-operations">
<h3><a class="toc-backref" href="#id1027">Conversion Operations</a><a class="headerlink" href="#conversion-operations" title="永久链接至标题">¶</a></h3>
<p>The instructions in this category are the conversion instructions
(casting) which all take a single operand and a type. They perform
various bit conversions on the operand.</p>
<div class="section" id="trunc-to-instruction">
<h4><a class="toc-backref" href="#id1028">&#8216;<code class="docutils literal"><span class="pre">trunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#trunc-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id215">
<h5><a class="toc-backref" href="#id1029">Syntax:</a><a class="headerlink" href="#id215" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">trunc</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id216">
<h5><a class="toc-backref" href="#id1030">Overview:</a><a class="headerlink" href="#id216" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">trunc</span></code>&#8216; instruction truncates its operand to the type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id217">
<h5><a class="toc-backref" href="#id1031">Arguments:</a><a class="headerlink" href="#id217" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">trunc</span></code>&#8216; instruction takes a value to trunc, and a type to trunc
it to. Both types must be of <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> types, or vectors
of the same number of integers. The bit size of the <code class="docutils literal"><span class="pre">value</span></code> must be
larger than the bit size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>. Equal sized
types are not allowed.</p>
</div>
<div class="section" id="id218">
<h5><a class="toc-backref" href="#id1032">Semantics:</a><a class="headerlink" href="#id218" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">trunc</span></code>&#8216; instruction truncates the high order bits in <code class="docutils literal"><span class="pre">value</span></code>
and converts the remaining bits to <code class="docutils literal"><span class="pre">ty2</span></code>. Since the source size must
be larger than the destination size, <code class="docutils literal"><span class="pre">trunc</span></code> cannot be a <em>no-op cast</em>.
It will always truncate bits.</p>
</div>
<div class="section" id="id219">
<h5><a class="toc-backref" href="#id1033">Example:</a><a class="headerlink" href="#id219" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">trunc</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="k">i8</span>                        <span class="c">; yields i8:1</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">trunc</span> <span class="k">i32</span> <span class="m">123</span> <span class="k">to</span> <span class="k">i1</span>                        <span class="c">; yields i1:true</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">trunc</span> <span class="k">i32</span> <span class="m">122</span> <span class="k">to</span> <span class="k">i1</span>                        <span class="c">; yields i1:false</span>
<span class="nv">%W</span> <span class="p">=</span> <span class="k">trunc</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i16</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i16</span> <span class="m">8</span><span class="p">,</span> <span class="k">i16</span> <span class="m">7</span><span class="p">&gt;</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="c">; yields &lt;i8 8, i8 7&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="zext-to-instruction">
<h4><a class="toc-backref" href="#id1034">&#8216;<code class="docutils literal"><span class="pre">zext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#zext-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id220">
<h5><a class="toc-backref" href="#id1035">Syntax:</a><a class="headerlink" href="#id220" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">zext</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id221">
<h5><a class="toc-backref" href="#id1036">Overview:</a><a class="headerlink" href="#id221" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">zext</span></code>&#8216; instruction zero extends its operand to type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id222">
<h5><a class="toc-backref" href="#id1037">Arguments:</a><a class="headerlink" href="#id222" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">zext</span></code>&#8216; instruction takes a value to cast, and a type to cast it
to. Both types must be of <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> types, or vectors of
the same number of integers. The bit size of the <code class="docutils literal"><span class="pre">value</span></code> must be
smaller than the bit size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id223">
<h5><a class="toc-backref" href="#id1038">Semantics:</a><a class="headerlink" href="#id223" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">zext</span></code> fills the high order bits of the <code class="docutils literal"><span class="pre">value</span></code> with zero bits
until it reaches the size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
<p>When zero extending from i1, the result will always be either 0 or 1.</p>
</div>
<div class="section" id="id224">
<h5><a class="toc-backref" href="#id1039">Example:</a><a class="headerlink" href="#id224" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">zext</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="k">i64</span>              <span class="c">; yields i64:257</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">zext</span> <span class="k">i1</span> <span class="k">true</span> <span class="k">to</span> <span class="k">i32</span>              <span class="c">; yields i32:1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">zext</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i16</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i16</span> <span class="m">8</span><span class="p">,</span> <span class="k">i16</span> <span class="m">7</span><span class="p">&gt;</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="c">; yields &lt;i32 8, i32 7&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sext-to-instruction">
<h4><a class="toc-backref" href="#id1040">&#8216;<code class="docutils literal"><span class="pre">sext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#sext-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id225">
<h5><a class="toc-backref" href="#id1041">Syntax:</a><a class="headerlink" href="#id225" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sext</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id226">
<h5><a class="toc-backref" href="#id1042">Overview:</a><a class="headerlink" href="#id226" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sext</span></code>&#8216; sign extends <code class="docutils literal"><span class="pre">value</span></code> to the type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id227">
<h5><a class="toc-backref" href="#id1043">Arguments:</a><a class="headerlink" href="#id227" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sext</span></code>&#8216; instruction takes a value to cast, and a type to cast it
to. Both types must be of <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> types, or vectors of
the same number of integers. The bit size of the <code class="docutils literal"><span class="pre">value</span></code> must be
smaller than the bit size of the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id228">
<h5><a class="toc-backref" href="#id1044">Semantics:</a><a class="headerlink" href="#id228" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sext</span></code>&#8216; instruction performs a sign extension by copying the sign
bit (highest order bit) of the <code class="docutils literal"><span class="pre">value</span></code> until it reaches the bit size
of the type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
<p>When sign extending from i1, the extension always results in -1 or 0.</p>
</div>
<div class="section" id="id229">
<h5><a class="toc-backref" href="#id1045">Example:</a><a class="headerlink" href="#id229" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">sext</span> <span class="k">i8</span>  <span class="m">-1</span> <span class="k">to</span> <span class="k">i16</span>              <span class="c">; yields i16   :65535</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">sext</span> <span class="k">i1</span> <span class="k">true</span> <span class="k">to</span> <span class="k">i32</span>             <span class="c">; yields i32:-1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">sext</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i16</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="k">i16</span> <span class="m">8</span><span class="p">,</span> <span class="k">i16</span> <span class="m">7</span><span class="p">&gt;</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="c">; yields &lt;i32 8, i32 7&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fptrunc-to-instruction">
<h4><a class="toc-backref" href="#id1046">&#8216;<code class="docutils literal"><span class="pre">fptrunc</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fptrunc-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id230">
<h5><a class="toc-backref" href="#id1047">Syntax:</a><a class="headerlink" href="#id230" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fptrunc</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id231">
<h5><a class="toc-backref" href="#id1048">Overview:</a><a class="headerlink" href="#id231" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptrunc</span></code>&#8216; instruction truncates <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id232">
<h5><a class="toc-backref" href="#id1049">Arguments:</a><a class="headerlink" href="#id232" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptrunc</span></code>&#8216; instruction takes a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a>
value to cast and a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to cast it to.
The size of <code class="docutils literal"><span class="pre">value</span></code> must be larger than the size of <code class="docutils literal"><span class="pre">ty2</span></code>. This
implies that <code class="docutils literal"><span class="pre">fptrunc</span></code> cannot be used to make a <em>no-op cast</em>.</p>
</div>
<div class="section" id="id233">
<h5><a class="toc-backref" href="#id1050">Semantics:</a><a class="headerlink" href="#id233" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptrunc</span></code>&#8216; instruction casts a <code class="docutils literal"><span class="pre">value</span></code> from a larger
<a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to a smaller <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type. If the value cannot fit (i.e. overflows) within the
destination type, <code class="docutils literal"><span class="pre">ty2</span></code>, then the results are undefined. If the cast produces
an inexact result, how rounding is performed (e.g. truncation, also known as
round to zero) is undefined.</p>
</div>
<div class="section" id="id234">
<h5><a class="toc-backref" href="#id1051">Example:</a><a class="headerlink" href="#id234" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fptrunc</span> <span class="kt">double</span> <span class="m">123.0</span> <span class="k">to</span> <span class="kt">float</span>         <span class="c">; yields float:123.0</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fptrunc</span> <span class="kt">double</span> <span class="m">1.0E+300</span> <span class="k">to</span> <span class="kt">float</span>      <span class="c">; yields undefined</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fpext-to-instruction">
<h4><a class="toc-backref" href="#id1052">&#8216;<code class="docutils literal"><span class="pre">fpext</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fpext-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id235">
<h5><a class="toc-backref" href="#id1053">Syntax:</a><a class="headerlink" href="#id235" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fpext</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id236">
<h5><a class="toc-backref" href="#id1054">Overview:</a><a class="headerlink" href="#id236" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fpext</span></code>&#8216; extends a floating point <code class="docutils literal"><span class="pre">value</span></code> to a larger floating
point value.</p>
</div>
<div class="section" id="id237">
<h5><a class="toc-backref" href="#id1055">Arguments:</a><a class="headerlink" href="#id237" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fpext</span></code>&#8216; instruction takes a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a>
<code class="docutils literal"><span class="pre">value</span></code> to cast, and a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to cast it
to. The source type must be smaller than the destination type.</p>
</div>
<div class="section" id="id238">
<h5><a class="toc-backref" href="#id1056">Semantics:</a><a class="headerlink" href="#id238" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fpext</span></code>&#8216; instruction extends the <code class="docutils literal"><span class="pre">value</span></code> from a smaller
<a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type to a larger <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type. The <code class="docutils literal"><span class="pre">fpext</span></code> cannot be used to make a
<em>no-op cast</em> because it always changes bits. Use <code class="docutils literal"><span class="pre">bitcast</span></code> to make a
<em>no-op cast</em> for a floating point cast.</p>
</div>
<div class="section" id="id239">
<h5><a class="toc-backref" href="#id1057">Example:</a><a class="headerlink" href="#id239" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fpext</span> <span class="kt">float</span> <span class="m">3.125</span> <span class="k">to</span> <span class="kt">double</span>         <span class="c">; yields double:3.125000e+00</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fpext</span> <span class="kt">double</span> <span class="nv">%X</span> <span class="k">to</span> <span class="kt">fp128</span>            <span class="c">; yields fp128:0xL00000000000000004000900000000000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fptoui-to-instruction">
<h4><a class="toc-backref" href="#id1058">&#8216;<code class="docutils literal"><span class="pre">fptoui</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fptoui-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id240">
<h5><a class="toc-backref" href="#id1059">Syntax:</a><a class="headerlink" href="#id240" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fptoui</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id241">
<h5><a class="toc-backref" href="#id1060">Overview:</a><a class="headerlink" href="#id241" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptoui</span></code>&#8216; converts a floating point <code class="docutils literal"><span class="pre">value</span></code> to its unsigned
integer equivalent of type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id242">
<h5><a class="toc-backref" href="#id1061">Arguments:</a><a class="headerlink" href="#id242" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptoui</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> value, and a type to
cast it to <code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector floating point type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector integer
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id243">
<h5><a class="toc-backref" href="#id1062">Semantics:</a><a class="headerlink" href="#id243" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptoui</span></code>&#8216; instruction converts its <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> operand into the nearest (rounding towards zero)
unsigned integer value. If the value cannot fit in <code class="docutils literal"><span class="pre">ty2</span></code>, the results
are undefined.</p>
</div>
<div class="section" id="id244">
<h5><a class="toc-backref" href="#id1063">Example:</a><a class="headerlink" href="#id244" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fptoui</span> <span class="kt">double</span> <span class="m">123.0</span> <span class="k">to</span> <span class="k">i32</span>      <span class="c">; yields i32:123</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fptoui</span> <span class="kt">float</span> <span class="m">1.0E+300</span> <span class="k">to</span> <span class="k">i1</span>     <span class="c">; yields undefined:1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">fptoui</span> <span class="kt">float</span> <span class="m">1.04E+17</span> <span class="k">to</span> <span class="k">i8</span>     <span class="c">; yields undefined:1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fptosi-to-instruction">
<h4><a class="toc-backref" href="#id1064">&#8216;<code class="docutils literal"><span class="pre">fptosi</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#fptosi-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id245">
<h5><a class="toc-backref" href="#id1065">Syntax:</a><a class="headerlink" href="#id245" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fptosi</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id246">
<h5><a class="toc-backref" href="#id1066">Overview:</a><a class="headerlink" href="#id246" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptosi</span></code>&#8216; instruction converts <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a>
<code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id247">
<h5><a class="toc-backref" href="#id1067">Arguments:</a><a class="headerlink" href="#id247" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptosi</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> value, and a type to
cast it to <code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector floating point type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector integer
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id248">
<h5><a class="toc-backref" href="#id1068">Semantics:</a><a class="headerlink" href="#id248" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fptosi</span></code>&#8216; instruction converts its <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> operand into the nearest (rounding towards zero)
signed integer value. If the value cannot fit in <code class="docutils literal"><span class="pre">ty2</span></code>, the results
are undefined.</p>
</div>
<div class="section" id="id249">
<h5><a class="toc-backref" href="#id1069">Example:</a><a class="headerlink" href="#id249" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">fptosi</span> <span class="kt">double</span> <span class="m">-123.0</span> <span class="k">to</span> <span class="k">i32</span>      <span class="c">; yields i32:-123</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">fptosi</span> <span class="kt">float</span> <span class="m">1.0E-247</span> <span class="k">to</span> <span class="k">i1</span>      <span class="c">; yields undefined:1</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">fptosi</span> <span class="kt">float</span> <span class="m">1.04E+17</span> <span class="k">to</span> <span class="k">i8</span>      <span class="c">; yields undefined:1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="uitofp-to-instruction">
<h4><a class="toc-backref" href="#id1070">&#8216;<code class="docutils literal"><span class="pre">uitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#uitofp-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id250">
<h5><a class="toc-backref" href="#id1071">Syntax:</a><a class="headerlink" href="#id250" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">uitofp</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id251">
<h5><a class="toc-backref" href="#id1072">Overview:</a><a class="headerlink" href="#id251" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">uitofp</span></code>&#8216; instruction regards <code class="docutils literal"><span class="pre">value</span></code> as an unsigned integer
and converts that value to the <code class="docutils literal"><span class="pre">ty2</span></code> type.</p>
</div>
<div class="section" id="id252">
<h5><a class="toc-backref" href="#id1073">Arguments:</a><a class="headerlink" href="#id252" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">uitofp</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> value, and a type to cast it to
<code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector integer type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector floating point
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id253">
<h5><a class="toc-backref" href="#id1074">Semantics:</a><a class="headerlink" href="#id253" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">uitofp</span></code>&#8216; instruction interprets its operand as an unsigned
integer quantity and converts it to the corresponding floating point
value. If the value cannot fit in the floating point value, the results
are undefined.</p>
</div>
<div class="section" id="id254">
<h5><a class="toc-backref" href="#id1075">Example:</a><a class="headerlink" href="#id254" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="kt">float</span>         <span class="c">; yields float:257.0</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i8</span> <span class="m">-1</span> <span class="k">to</span> <span class="kt">double</span>          <span class="c">; yields double:255.0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sitofp-to-instruction">
<h4><a class="toc-backref" href="#id1076">&#8216;<code class="docutils literal"><span class="pre">sitofp</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#sitofp-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id255">
<h5><a class="toc-backref" href="#id1077">Syntax:</a><a class="headerlink" href="#id255" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">sitofp</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id256">
<h5><a class="toc-backref" href="#id1078">Overview:</a><a class="headerlink" href="#id256" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sitofp</span></code>&#8216; instruction regards <code class="docutils literal"><span class="pre">value</span></code> as a signed integer and
converts that value to the <code class="docutils literal"><span class="pre">ty2</span></code> type.</p>
</div>
<div class="section" id="id257">
<h5><a class="toc-backref" href="#id1079">Arguments:</a><a class="headerlink" href="#id257" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sitofp</span></code>&#8216; instruction takes a value to cast, which must be a
scalar or vector <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> value, and a type to cast it to
<code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-floating"><span class="std std-ref">floating point</span></a> type. If
<code class="docutils literal"><span class="pre">ty</span></code> is a vector integer type, <code class="docutils literal"><span class="pre">ty2</span></code> must be a vector floating point
type with the same number of elements as <code class="docutils literal"><span class="pre">ty</span></code></p>
</div>
<div class="section" id="id258">
<h5><a class="toc-backref" href="#id1080">Semantics:</a><a class="headerlink" href="#id258" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">sitofp</span></code>&#8216; instruction interprets its operand as a signed integer
quantity and converts it to the corresponding floating point value. If
the value cannot fit in the floating point value, the results are
undefined.</p>
</div>
<div class="section" id="id259">
<h5><a class="toc-backref" href="#id1081">Example:</a><a class="headerlink" href="#id259" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">sitofp</span> <span class="k">i32</span> <span class="m">257</span> <span class="k">to</span> <span class="kt">float</span>         <span class="c">; yields float:257.0</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">sitofp</span> <span class="k">i8</span> <span class="m">-1</span> <span class="k">to</span> <span class="kt">double</span>          <span class="c">; yields double:-1.0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ptrtoint-to-instruction">
<span id="i-ptrtoint"></span><h4><a class="toc-backref" href="#id1082">&#8216;<code class="docutils literal"><span class="pre">ptrtoint</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#ptrtoint-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id260">
<h5><a class="toc-backref" href="#id1083">Syntax:</a><a class="headerlink" href="#id260" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ptrtoint</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id261">
<h5><a class="toc-backref" href="#id1084">Overview:</a><a class="headerlink" href="#id261" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ptrtoint</span></code>&#8216; instruction converts the pointer or a vector of
pointers <code class="docutils literal"><span class="pre">value</span></code> to the integer (or vector of integers) type <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id262">
<h5><a class="toc-backref" href="#id1085">Arguments:</a><a class="headerlink" href="#id262" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ptrtoint</span></code>&#8216; instruction takes a <code class="docutils literal"><span class="pre">value</span></code> to cast, which must be
a value of type <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> or a vector of pointers, and a
type to cast it to <code class="docutils literal"><span class="pre">ty2</span></code>, which must be an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or
a vector of integers type.</p>
</div>
<div class="section" id="id263">
<h5><a class="toc-backref" href="#id1086">Semantics:</a><a class="headerlink" href="#id263" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">ptrtoint</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to integer type
<code class="docutils literal"><span class="pre">ty2</span></code> by interpreting the pointer value as an integer and either
truncating or zero extending that value to the size of the integer type.
If <code class="docutils literal"><span class="pre">value</span></code> is smaller than <code class="docutils literal"><span class="pre">ty2</span></code> then a zero extension is done. If
<code class="docutils literal"><span class="pre">value</span></code> is larger than <code class="docutils literal"><span class="pre">ty2</span></code> then a truncation is done. If they are
the same size, then nothing is done (<em>no-op cast</em>) other than a type
change.</p>
</div>
<div class="section" id="id264">
<h5><a class="toc-backref" href="#id1087">Example:</a><a class="headerlink" href="#id264" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%P</span> <span class="k">to</span> <span class="k">i8</span>                         <span class="c">; yields truncation on 32-bit architecture</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%P</span> <span class="k">to</span> <span class="k">i64</span>                        <span class="c">; yields zero extension on 32-bit architecture</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">ptrtoint</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">*&gt;</span> <span class="nv">%P</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i64</span><span class="p">&gt;</span><span class="c">; yields vector zero extension for a vector of addresses on 32-bit architecture</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="inttoptr-to-instruction">
<span id="i-inttoptr"></span><h4><a class="toc-backref" href="#id1088">&#8216;<code class="docutils literal"><span class="pre">inttoptr</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#inttoptr-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id265">
<h5><a class="toc-backref" href="#id1089">Syntax:</a><a class="headerlink" href="#id265" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">inttoptr</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id266">
<h5><a class="toc-backref" href="#id1090">Overview:</a><a class="headerlink" href="#id266" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">inttoptr</span></code>&#8216; instruction converts an integer <code class="docutils literal"><span class="pre">value</span></code> to a
pointer type, <code class="docutils literal"><span class="pre">ty2</span></code>.</p>
</div>
<div class="section" id="id267">
<h5><a class="toc-backref" href="#id1091">Arguments:</a><a class="headerlink" href="#id267" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">inttoptr</span></code>&#8216; instruction takes an <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> value to
cast, and a type to cast it to, which must be a <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a>
type.</p>
</div>
<div class="section" id="id268">
<h5><a class="toc-backref" href="#id1092">Semantics:</a><a class="headerlink" href="#id268" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">inttoptr</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code> by
applying either a zero extension or a truncation depending on the size
of the integer <code class="docutils literal"><span class="pre">value</span></code>. If <code class="docutils literal"><span class="pre">value</span></code> is larger than the size of a
pointer then a truncation is done. If <code class="docutils literal"><span class="pre">value</span></code> is smaller than the size
of a pointer then a zero extension is done. If they are the same size,
nothing is done (<em>no-op cast</em>).</p>
</div>
<div class="section" id="id269">
<h5><a class="toc-backref" href="#id1093">Example:</a><a class="headerlink" href="#id269" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i32</span> <span class="m">255</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>          <span class="c">; yields zero extension on 64-bit architecture</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i32</span> <span class="m">255</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>          <span class="c">; yields no-op on 32-bit architecture</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i64</span> <span class="m">0</span> <span class="k">to</span> <span class="k">i32</span><span class="p">*</span>            <span class="c">; yields truncation on 32-bit architecture</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%G</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">*&gt;</span><span class="c">; yields truncation of vector G to four pointers</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bitcast-to-instruction">
<span id="i-bitcast"></span><h4><a class="toc-backref" href="#id1094">&#8216;<code class="docutils literal"><span class="pre">bitcast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#bitcast-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id270">
<h5><a class="toc-backref" href="#id1095">Syntax:</a><a class="headerlink" href="#id270" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">bitcast</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">ty2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id271">
<h5><a class="toc-backref" href="#id1096">Overview:</a><a class="headerlink" href="#id271" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code> without
changing any bits.</p>
</div>
<div class="section" id="id272">
<h5><a class="toc-backref" href="#id1097">Arguments:</a><a class="headerlink" href="#id272" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216; instruction takes a value to cast, which must be a
non-aggregate first class value, and a type to cast it to, which must
also be a non-aggregate <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type. The
bit sizes of <code class="docutils literal"><span class="pre">value</span></code> and the destination type, <code class="docutils literal"><span class="pre">ty2</span></code>, must be
identical. If the source type is a pointer, the destination type must
also be a pointer of the same size. This instruction supports bitwise
conversion of vectors to integers and to vectors of other types (as
long as they have the same size).</p>
</div>
<div class="section" id="id273">
<h5><a class="toc-backref" href="#id1098">Semantics:</a><a class="headerlink" href="#id273" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">bitcast</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">value</span></code> to type <code class="docutils literal"><span class="pre">ty2</span></code>. It
is always a <em>no-op cast</em> because no bits change with this
conversion. The conversion is done as if the <code class="docutils literal"><span class="pre">value</span></code> had been stored
to memory and read back as type <code class="docutils literal"><span class="pre">ty2</span></code>. Pointer (or vector of
pointers) types may only be converted to other pointer (or vector of
pointers) types with the same address space through this instruction.
To convert pointers to other types, use the <a class="reference internal" href="#i-inttoptr"><span class="std std-ref">inttoptr</span></a>
or <a class="reference internal" href="#i-ptrtoint"><span class="std std-ref">ptrtoint</span></a> instructions first.</p>
</div>
<div class="section" id="id274">
<h5><a class="toc-backref" href="#id1099">Example:</a><a class="headerlink" href="#id274" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>%X = bitcast i8 255 to i8              ; yields i8 :-1
%Y = bitcast i32* %x to sint*          ; yields sint*:%x
%Z = bitcast &lt;2 x int&gt; %V to i64;        ; yields i64: %V
%Z = bitcast &lt;2 x i32*&gt; %V to &lt;2 x i64*&gt; ; yields &lt;2 x i64*&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="addrspacecast-to-instruction">
<span id="i-addrspacecast"></span><h4><a class="toc-backref" href="#id1100">&#8216;<code class="docutils literal"><span class="pre">addrspacecast</span> <span class="pre">..</span> <span class="pre">to</span></code>&#8216; Instruction</a><a class="headerlink" href="#addrspacecast-to-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id275">
<h5><a class="toc-backref" href="#id1101">Syntax:</a><a class="headerlink" href="#id275" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">addrspacecast</span> <span class="o">&lt;</span><span class="n">pty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ptrval</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">pty2</span><span class="o">&gt;</span>       <span class="p">;</span> <span class="n">yields</span> <span class="n">pty2</span>
</pre></div>
</div>
</div>
<div class="section" id="id276">
<h5><a class="toc-backref" href="#id1102">Overview:</a><a class="headerlink" href="#id276" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">addrspacecast</span></code>&#8216; instruction converts <code class="docutils literal"><span class="pre">ptrval</span></code> from <code class="docutils literal"><span class="pre">pty</span></code> in
address space <code class="docutils literal"><span class="pre">n</span></code> to type <code class="docutils literal"><span class="pre">pty2</span></code> in address space <code class="docutils literal"><span class="pre">m</span></code>.</p>
</div>
<div class="section" id="id277">
<h5><a class="toc-backref" href="#id1103">Arguments:</a><a class="headerlink" href="#id277" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">addrspacecast</span></code>&#8216; instruction takes a pointer or vector of pointer value
to cast and a pointer type to cast it to, which must have a different
address space.</p>
</div>
<div class="section" id="id278">
<h5><a class="toc-backref" href="#id1104">Semantics:</a><a class="headerlink" href="#id278" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">addrspacecast</span></code>&#8216; instruction converts the pointer value
<code class="docutils literal"><span class="pre">ptrval</span></code> to type <code class="docutils literal"><span class="pre">pty2</span></code>. It can be a <em>no-op cast</em> or a complex
value modification, depending on the target and the address space
pair. Pointer conversions within the same address space must be
performed with the <code class="docutils literal"><span class="pre">bitcast</span></code> instruction. Note that if the address space
conversion is legal then both result and operand refer to the same memory
location.</p>
</div>
<div class="section" id="id279">
<h5><a class="toc-backref" href="#id1105">Example:</a><a class="headerlink" href="#id279" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">addrspacecast</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%x</span> <span class="k">to</span> <span class="k">i32</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)*</span>    <span class="c">; yields i32 addrspace(1)*:%x</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">addrspacecast</span> <span class="k">i32</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)*</span> <span class="nv">%y</span> <span class="k">to</span> <span class="k">i64</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">2</span><span class="p">)*</span>    <span class="c">; yields i64 addrspace(2)*:%y</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">addrspacecast</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="k">i32</span><span class="p">*&gt;</span> <span class="nv">%z</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">4</span> <span class="k">x</span> <span class="kt">float</span> <span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)*&gt;</span>   <span class="c">; yields &lt;4 x float addrspace(3)*&gt;:%z</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="other-operations">
<span id="otherops"></span><h3><a class="toc-backref" href="#id1106">Other Operations</a><a class="headerlink" href="#other-operations" title="永久链接至标题">¶</a></h3>
<p>The instructions in this category are the &#8220;miscellaneous&#8221; instructions,
which defy better classification.</p>
<div class="section" id="icmp-instruction">
<span id="i-icmp"></span><h4><a class="toc-backref" href="#id1107">&#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; Instruction</a><a class="headerlink" href="#icmp-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id280">
<h5><a class="toc-backref" href="#id1108">Syntax:</a><a class="headerlink" href="#id280" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">icmp</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>   <span class="p">;</span> <span class="n">yields</span> <span class="n">i1</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">N</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id281">
<h5><a class="toc-backref" href="#id1109">Overview:</a><a class="headerlink" href="#id281" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; instruction returns a boolean value or a vector of
boolean values based on comparison of its two integer, integer vector,
pointer, or pointer vector operands.</p>
</div>
<div class="section" id="id282">
<h5><a class="toc-backref" href="#id1110">Arguments:</a><a class="headerlink" href="#id282" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; instruction takes three operands. The first operand is
the condition code indicating the kind of comparison to perform. It is
not a value, just a keyword. The possible condition code are:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">eq</span></code>: equal</li>
<li><code class="docutils literal"><span class="pre">ne</span></code>: not equal</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: unsigned greater than</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: unsigned greater or equal</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: unsigned less than</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: unsigned less or equal</li>
<li><code class="docutils literal"><span class="pre">sgt</span></code>: signed greater than</li>
<li><code class="docutils literal"><span class="pre">sge</span></code>: signed greater or equal</li>
<li><code class="docutils literal"><span class="pre">slt</span></code>: signed less than</li>
<li><code class="docutils literal"><span class="pre">sle</span></code>: signed less or equal</li>
</ol>
<p>The remaining two arguments must be <a class="reference internal" href="#t-integer"><span class="std std-ref">integer</span></a> or
<a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> or integer <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> typed. They
must also be identical types.</p>
</div>
<div class="section" id="id283">
<h5><a class="toc-backref" href="#id1111">Semantics:</a><a class="headerlink" href="#id283" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">icmp</span></code>&#8216; compares <code class="docutils literal"><span class="pre">op1</span></code> and <code class="docutils literal"><span class="pre">op2</span></code> according to the condition
code given as <code class="docutils literal"><span class="pre">cond</span></code>. The comparison performed always yields either an
<a class="reference internal" href="#t-integer"><span class="std std-ref">i1</span></a> or vector of <code class="docutils literal"><span class="pre">i1</span></code> result, as follows:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">eq</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if the operands are equal, <code class="docutils literal"><span class="pre">false</span></code>
otherwise. No sign interpretation is necessary or performed.</li>
<li><code class="docutils literal"><span class="pre">ne</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if the operands are unequal, <code class="docutils literal"><span class="pre">false</span></code>
otherwise. No sign interpretation is necessary or performed.</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: interprets the operands as unsigned values and yields
<code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">op1</span></code> is less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sgt</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sge</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">slt</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sle</span></code>: interprets the operands as signed values and yields <code class="docutils literal"><span class="pre">true</span></code>
if <code class="docutils literal"><span class="pre">op1</span></code> is less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
</ol>
<p>If the operands are <a class="reference internal" href="#t-pointer"><span class="std std-ref">pointer</span></a> typed, the pointer values
are compared as if they were integers.</p>
<p>If the operands are integer vectors, then they are compared element by
element. The result is an <code class="docutils literal"><span class="pre">i1</span></code> vector with the same number of elements
as the values being compared. Otherwise, the result is an <code class="docutils literal"><span class="pre">i1</span></code>.</p>
</div>
<div class="section" id="id284">
<h5><a class="toc-backref" href="#id1112">Example:</a><a class="headerlink" href="#id284" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = icmp eq i32 4, 5          ; yields: result=false
&lt;result&gt; = icmp ne float* %X, %X     ; yields: result=false
&lt;result&gt; = icmp ult i16  4, 5        ; yields: result=true
&lt;result&gt; = icmp sgt i16  4, 5        ; yields: result=false
&lt;result&gt; = icmp ule i16 -4, 5        ; yields: result=false
&lt;result&gt; = icmp sge i16  4, 5        ; yields: result=false
</pre></div>
</div>
<p>Note that the code generator does not yet support vector types with the
<code class="docutils literal"><span class="pre">icmp</span></code> instruction.</p>
</div>
</div>
<div class="section" id="fcmp-instruction">
<span id="i-fcmp"></span><h4><a class="toc-backref" href="#id1113">&#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; Instruction</a><a class="headerlink" href="#fcmp-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id285">
<h5><a class="toc-backref" href="#id1114">Syntax:</a><a class="headerlink" href="#id285" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fcmp</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span>     <span class="p">;</span> <span class="n">yields</span> <span class="n">i1</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">N</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span><span class="p">:</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id286">
<h5><a class="toc-backref" href="#id1115">Overview:</a><a class="headerlink" href="#id286" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; instruction returns a boolean value or vector of boolean
values based on comparison of its operands.</p>
<p>If the operands are floating point scalars, then the result type is a
boolean (<a class="reference internal" href="#t-integer"><span class="std std-ref">i1</span></a>).</p>
<p>If the operands are floating point vectors, then the result type is a
vector of boolean with the same number of elements as the operands being
compared.</p>
</div>
<div class="section" id="id287">
<h5><a class="toc-backref" href="#id1116">Arguments:</a><a class="headerlink" href="#id287" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; instruction takes three operands. The first operand is
the condition code indicating the kind of comparison to perform. It is
not a value, just a keyword. The possible condition code are:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">false</span></code>: no comparison, always returns false</li>
<li><code class="docutils literal"><span class="pre">oeq</span></code>: ordered and equal</li>
<li><code class="docutils literal"><span class="pre">ogt</span></code>: ordered and greater than</li>
<li><code class="docutils literal"><span class="pre">oge</span></code>: ordered and greater than or equal</li>
<li><code class="docutils literal"><span class="pre">olt</span></code>: ordered and less than</li>
<li><code class="docutils literal"><span class="pre">ole</span></code>: ordered and less than or equal</li>
<li><code class="docutils literal"><span class="pre">one</span></code>: ordered and not equal</li>
<li><code class="docutils literal"><span class="pre">ord</span></code>: ordered (no nans)</li>
<li><code class="docutils literal"><span class="pre">ueq</span></code>: unordered or equal</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: unordered or greater than</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: unordered or greater than or equal</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: unordered or less than</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: unordered or less than or equal</li>
<li><code class="docutils literal"><span class="pre">une</span></code>: unordered or not equal</li>
<li><code class="docutils literal"><span class="pre">uno</span></code>: unordered (either nans)</li>
<li><code class="docutils literal"><span class="pre">true</span></code>: no comparison, always returns true</li>
</ol>
<p><em>Ordered</em> means that neither operand is a QNAN while <em>unordered</em> means
that either operand may be a QNAN.</p>
<p>Each of <code class="docutils literal"><span class="pre">val1</span></code> and <code class="docutils literal"><span class="pre">val2</span></code> arguments must be either a <a class="reference internal" href="#t-floating"><span class="std std-ref">floating
point</span></a> type or a <a class="reference internal" href="#t-vector"><span class="std std-ref">vector</span></a> of floating point
type. They must have identical types.</p>
</div>
<div class="section" id="id288">
<h5><a class="toc-backref" href="#id1117">Semantics:</a><a class="headerlink" href="#id288" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">fcmp</span></code>&#8216; instruction compares <code class="docutils literal"><span class="pre">op1</span></code> and <code class="docutils literal"><span class="pre">op2</span></code> according to the
condition code given as <code class="docutils literal"><span class="pre">cond</span></code>. If the operands are vectors, then the
vectors are compared element by element. Each comparison performed
always yields an <a class="reference internal" href="#t-integer"><span class="std std-ref">i1</span></a> result, as follows:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">false</span></code>: always yields <code class="docutils literal"><span class="pre">false</span></code>, regardless of operands.</li>
<li><code class="docutils literal"><span class="pre">oeq</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ogt</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">oge</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">olt</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ole</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">one</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN and <code class="docutils literal"><span class="pre">op1</span></code>
is not equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ord</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if both operands are not a QNAN.</li>
<li><code class="docutils literal"><span class="pre">ueq</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ugt</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
greater than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">uge</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
greater than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ult</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
less than <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ule</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
less than or equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">une</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN or <code class="docutils literal"><span class="pre">op1</span></code> is
not equal to <code class="docutils literal"><span class="pre">op2</span></code>.</li>
<li><code class="docutils literal"><span class="pre">uno</span></code>: yields <code class="docutils literal"><span class="pre">true</span></code> if either operand is a QNAN.</li>
<li><code class="docutils literal"><span class="pre">true</span></code>: always yields <code class="docutils literal"><span class="pre">true</span></code>, regardless of operands.</li>
</ol>
<p>The <code class="docutils literal"><span class="pre">fcmp</span></code> instruction can also optionally take any number of
<a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>, which are optimization hints to enable
otherwise unsafe floating point optimizations.</p>
<p>Any set of fast-math flags are legal on an <code class="docutils literal"><span class="pre">fcmp</span></code> instruction, but the
only flags that have any effect on its semantics are those that allow
assumptions to be made about the values of input arguments; namely
<code class="docutils literal"><span class="pre">nnan</span></code>, <code class="docutils literal"><span class="pre">ninf</span></code>, and <code class="docutils literal"><span class="pre">nsz</span></code>. See <a class="reference internal" href="#fastmath"><span class="std std-ref">Fast-Math Flags</span></a> for more information.</p>
</div>
<div class="section" id="id289">
<h5><a class="toc-backref" href="#id1118">Example:</a><a class="headerlink" href="#id289" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>&lt;result&gt; = fcmp oeq float 4.0, 5.0    ; yields: result=false
&lt;result&gt; = fcmp one float 4.0, 5.0    ; yields: result=true
&lt;result&gt; = fcmp olt float 4.0, 5.0    ; yields: result=true
&lt;result&gt; = fcmp ueq double 1.0, 2.0   ; yields: result=false
</pre></div>
</div>
<p>Note that the code generator does not yet support vector types with the
<code class="docutils literal"><span class="pre">fcmp</span></code> instruction.</p>
</div>
</div>
<div class="section" id="phi-instruction">
<span id="i-phi"></span><h4><a class="toc-backref" href="#id1119">&#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; Instruction</a><a class="headerlink" href="#phi-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id290">
<h5><a class="toc-backref" href="#id1120">Syntax:</a><a class="headerlink" href="#id290" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">val0</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">label0</span><span class="o">&gt;</span><span class="p">],</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id291">
<h5><a class="toc-backref" href="#id1121">Overview:</a><a class="headerlink" href="#id291" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; instruction is used to implement the φ node in the SSA
graph representing the function.</p>
</div>
<div class="section" id="id292">
<h5><a class="toc-backref" href="#id1122">Arguments:</a><a class="headerlink" href="#id292" title="永久链接至标题">¶</a></h5>
<p>The type of the incoming values is specified with the first type field.
After this, the &#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; instruction takes a list of pairs as
arguments, with one pair for each predecessor basic block of the current
block. Only values of <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type may be used as
the value arguments to the PHI node. Only labels may be used as the
label arguments.</p>
<p>There must be no non-phi instructions between the start of a basic block
and the PHI instructions: i.e. PHI instructions must be first in a basic
block.</p>
<p>For the purposes of the SSA form, the use of each incoming value is
deemed to occur on the edge from the corresponding predecessor block to
the current block (but after any definition of an &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216;
instruction&#8217;s return value on the same edge).</p>
</div>
<div class="section" id="id293">
<h5><a class="toc-backref" href="#id1123">Semantics:</a><a class="headerlink" href="#id293" title="永久链接至标题">¶</a></h5>
<p>At runtime, the &#8216;<code class="docutils literal"><span class="pre">phi</span></code>&#8216; instruction logically takes on the value
specified by the pair corresponding to the predecessor basic block that
executed just prior to the current block.</p>
</div>
<div class="section" id="id294">
<h5><a class="toc-backref" href="#id1124">Example:</a><a class="headerlink" href="#id294" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">Loop:</span>       <span class="c">; Infinite loop that counts from 0 on up...</span>
  <span class="nv">%indvar</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="m">0</span><span class="p">,</span> <span class="nv">%LoopHeader</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%nextindvar</span><span class="p">,</span> <span class="nv">%Loop</span> <span class="p">]</span>
  <span class="nv">%nextindvar</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%indvar</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%Loop</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="select-instruction">
<span id="i-select"></span><h4><a class="toc-backref" href="#id1125">&#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; Instruction</a><a class="headerlink" href="#select-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id295">
<h5><a class="toc-backref" href="#id1126">Syntax:</a><a class="headerlink" href="#id295" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">select</span> <span class="n">selty</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">val2</span><span class="o">&gt;</span>             <span class="p">;</span> <span class="n">yields</span> <span class="n">ty</span>

<span class="n">selty</span> <span class="ow">is</span> <span class="n">either</span> <span class="n">i1</span> <span class="ow">or</span> <span class="p">{</span><span class="o">&lt;</span><span class="n">N</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id296">
<h5><a class="toc-backref" href="#id1127">Overview:</a><a class="headerlink" href="#id296" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; instruction is used to choose one value based on a
condition, without IR-level branching.</p>
</div>
<div class="section" id="id297">
<h5><a class="toc-backref" href="#id1128">Arguments:</a><a class="headerlink" href="#id297" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">select</span></code>&#8216; instruction requires an &#8216;i1&#8217; value or a vector of &#8216;i1&#8217;
values indicating the condition, and two values of the same <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first
class</span></a> type.</p>
</div>
<div class="section" id="id298">
<h5><a class="toc-backref" href="#id1129">Semantics:</a><a class="headerlink" href="#id298" title="永久链接至标题">¶</a></h5>
<p>If the condition is an i1 and it evaluates to 1, the instruction returns
the first value argument; otherwise, it returns the second value
argument.</p>
<p>If the condition is a vector of i1, then the value arguments must be
vectors of the same size, and the selection is done element by element.</p>
<p>If the condition is an i1 and the value arguments are vectors of the
same size, then an entire vector is selected.</p>
</div>
<div class="section" id="id299">
<h5><a class="toc-backref" href="#id1130">Example:</a><a class="headerlink" href="#id299" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%X</span> <span class="p">=</span> <span class="k">select</span> <span class="k">i1</span> <span class="k">true</span><span class="p">,</span> <span class="k">i8</span> <span class="m">17</span><span class="p">,</span> <span class="k">i8</span> <span class="m">42</span>          <span class="c">; yields i8:17</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="call-instruction">
<span id="i-call"></span><h4><a class="toc-backref" href="#id1131">&#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; Instruction</a><a class="headerlink" href="#call-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id300">
<h5><a class="toc-backref" href="#id1132">Syntax:</a><a class="headerlink" href="#id300" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="n">tail</span> <span class="o">|</span> <span class="n">musttail</span> <span class="o">|</span> <span class="n">notail</span> <span class="p">]</span> <span class="n">call</span> <span class="p">[</span><span class="n">fast</span><span class="o">-</span><span class="n">math</span> <span class="n">flags</span><span class="p">]</span> <span class="p">[</span><span class="n">cconv</span><span class="p">]</span> <span class="p">[</span><span class="n">ret</span> <span class="n">attrs</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">fnty</span><span class="o">&gt;*</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">fnptrval</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">function</span> <span class="n">args</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">[</span><span class="n">fn</span> <span class="n">attrs</span><span class="p">]</span>
             <span class="p">[</span> <span class="n">operand</span> <span class="n">bundles</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id301">
<h5><a class="toc-backref" href="#id1133">Overview:</a><a class="headerlink" href="#id301" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; instruction represents a simple function call.</p>
</div>
<div class="section" id="id302">
<h5><a class="toc-backref" href="#id1134">Arguments:</a><a class="headerlink" href="#id302" title="永久链接至标题">¶</a></h5>
<p>This instruction requires several arguments:</p>
<ol class="arabic">
<li><p class="first">The optional <code class="docutils literal"><span class="pre">tail</span></code> and <code class="docutils literal"><span class="pre">musttail</span></code> markers indicate that the optimizers
should perform tail call optimization. The <code class="docutils literal"><span class="pre">tail</span></code> marker is a hint that
<a class="reference external" href="CodeGenerator.html#sibcallopt">can be ignored</a>. The <code class="docutils literal"><span class="pre">musttail</span></code> marker
means that the call must be tail call optimized in order for the program to
be correct. The <code class="docutils literal"><span class="pre">musttail</span></code> marker provides these guarantees:</p>
<ol class="arabic simple">
<li>The call will not cause unbounded stack growth if it is part of a
recursive cycle in the call graph.</li>
<li>Arguments with the <a class="reference internal" href="#attr-inalloca"><span class="std std-ref">inalloca</span></a> attribute are
forwarded in place.</li>
</ol>
<p>Both markers imply that the callee does not access allocas or varargs from
the caller. Calls marked <code class="docutils literal"><span class="pre">musttail</span></code> must obey the following additional
rules:</p>
<ul class="simple">
<li>The call must immediately precede a <a class="reference internal" href="#i-ret"><span class="std std-ref">ret</span></a> instruction,
or a pointer bitcast followed by a ret instruction.</li>
<li>The ret instruction must return the (possibly bitcasted) value
produced by the call or void.</li>
<li>The caller and callee prototypes must match. Pointer types of
parameters or return types may differ in pointee type, but not
in address space.</li>
<li>The calling conventions of the caller and callee must match.</li>
<li>All ABI-impacting function attributes, such as sret, byval, inreg,
returned, and inalloca, must match.</li>
<li>The callee must be varargs iff the caller is varargs. Bitcasting a
non-varargs function to the appropriate varargs type is legal so
long as the non-varargs prefixes obey the other rules.</li>
</ul>
<p>Tail call optimization for calls marked <code class="docutils literal"><span class="pre">tail</span></code> is guaranteed to occur if
the following conditions are met:</p>
<ul class="simple">
<li>Caller and callee both have the calling convention <code class="docutils literal"><span class="pre">fastcc</span></code>.</li>
<li>The call is in tail position (ret immediately follows call and ret
uses value of call or is void).</li>
<li>Option <code class="docutils literal"><span class="pre">-tailcallopt</span></code> is enabled, or
<code class="docutils literal"><span class="pre">llvm::GuaranteedTailCallOpt</span></code> is <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li><a class="reference external" href="CodeGenerator.html#tailcallopt">Platform-specific constraints are
met.</a></li>
</ul>
</li>
<li><p class="first">The optional <code class="docutils literal"><span class="pre">notail</span></code> marker indicates that the optimizers should not add
<code class="docutils literal"><span class="pre">tail</span></code> or <code class="docutils literal"><span class="pre">musttail</span></code> markers to the call. It is used to prevent tail
call optimization from being performed on the call.</p>
</li>
<li><p class="first">The optional <code class="docutils literal"><span class="pre">fast-math</span> <span class="pre">flags</span></code> marker indicates that the call has one or more
<a class="reference internal" href="#fastmath"><span class="std std-ref">fast-math flags</span></a>, which are optimization hints to enable
otherwise unsafe floating-point optimizations. Fast-math flags are only valid
for calls that return a floating-point scalar or vector type.</p>
</li>
<li><p class="first">The optional &#8220;cconv&#8221; marker indicates which <a class="reference internal" href="#callingconv"><span class="std std-ref">calling
convention</span></a> the call should use. If none is
specified, the call defaults to using C calling conventions. The
calling convention of the call must match the calling convention of
the target function, or else the behavior is undefined.</p>
</li>
<li><p class="first">The optional <a class="reference internal" href="#paramattrs"><span class="std std-ref">Parameter Attributes</span></a> list for return
values. Only &#8216;<code class="docutils literal"><span class="pre">zeroext</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">signext</span></code>&#8216;, and &#8216;<code class="docutils literal"><span class="pre">inreg</span></code>&#8216; attributes
are valid here.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">ty</span></code>&#8216;: the type of the call instruction itself which is also the
type of the return value. Functions that return no value are marked
<code class="docutils literal"><span class="pre">void</span></code>.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">fnty</span></code>&#8216;: shall be the signature of the pointer to function value
being invoked. The argument types must match the types implied by
this signature. This type can be omitted if the function is not
varargs and if the function type does not return a pointer to a
function.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">fnptrval</span></code>&#8216;: An LLVM value containing a pointer to a function to
be invoked. In most cases, this is a direct function invocation, but
indirect <code class="docutils literal"><span class="pre">call</span></code>&#8216;s are just as possible, calling an arbitrary pointer
to function value.</p>
</li>
<li><p class="first">&#8216;<code class="docutils literal"><span class="pre">function</span> <span class="pre">args</span></code>&#8216;: argument list whose types match the function
signature argument types and parameter attributes. All arguments must
be of <a class="reference internal" href="#t-firstclass"><span class="std std-ref">first class</span></a> type. If the function signature
indicates the function accepts a variable number of arguments, the
extra arguments can be specified.</p>
</li>
<li><p class="first">The optional <a class="reference internal" href="#fnattrs"><span class="std std-ref">function attributes</span></a> list. Only
&#8216;<code class="docutils literal"><span class="pre">noreturn</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">nounwind</span></code>&#8216;, &#8216;<code class="docutils literal"><span class="pre">readonly</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">readnone</span></code>&#8216;
attributes are valid here.</p>
</li>
<li><p class="first">The optional <a class="reference internal" href="#opbundles"><span class="std std-ref">operand bundles</span></a> list.</p>
</li>
</ol>
</div>
<div class="section" id="id303">
<h5><a class="toc-backref" href="#id1135">Semantics:</a><a class="headerlink" href="#id303" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">call</span></code>&#8216; instruction is used to cause control flow to transfer to
a specified function, with its incoming arguments bound to the specified
values. Upon a &#8216;<code class="docutils literal"><span class="pre">ret</span></code>&#8216; instruction in the called function, control
flow continues with the instruction after the function call, and the
return value of the function is bound to the result argument.</p>
</div>
<div class="section" id="id304">
<h5><a class="toc-backref" href="#id1136">Example:</a><a class="headerlink" href="#id304" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%retval</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%argc</span><span class="p">)</span>
<span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)*</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%msg</span><span class="p">,</span> <span class="k">i32</span> <span class="m">12</span><span class="p">,</span> <span class="k">i8</span> <span class="m">42</span><span class="p">)</span>        <span class="c">; yields i32</span>
<span class="nv">%X</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">()</span>                                    <span class="c">; yields i32</span>
<span class="nv">%Y</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">fastcc</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">()</span>  <span class="c">; yields i32</span>
<span class="k">call</span> <span class="kt">void</span> <span class="nv">%foo</span><span class="p">(</span><span class="k">i8</span> <span class="m">97</span> <span class="k">signext</span><span class="p">)</span>

<span class="nv">%struct.A</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i8</span> <span class="p">}</span>
<span class="nv">%r</span> <span class="p">=</span> <span class="k">call</span> <span class="nv">%struct.A</span> <span class="vg">@foo</span><span class="p">()</span>                        <span class="c">; yields { i32, i8 }</span>
<span class="nv">%gr</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%struct.A</span> <span class="nv">%r</span><span class="p">,</span> <span class="m">0</span>                <span class="c">; yields i32</span>
<span class="nv">%gr1</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="nv">%struct.A</span> <span class="nv">%r</span><span class="p">,</span> <span class="m">1</span>               <span class="c">; yields i8</span>
<span class="nv">%Z</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="k">noreturn</span>                    <span class="c">; indicates that %foo never returns normally</span>
<span class="nv">%ZZ</span> <span class="p">=</span> <span class="k">call</span> <span class="k">zeroext</span> <span class="k">i32</span> <span class="vg">@bar</span><span class="p">()</span>                     <span class="c">; Return value is %zero extended</span>
</pre></div>
</div>
<p>llvm treats calls to some functions with names and arguments that match
the standard C99 library as being the C99 library functions, and may
perform optimizations or generate code for them under that assumption.
This is something we&#8217;d like to change in the future to provide better
support for freestanding environments and non-C-based languages.</p>
</div>
</div>
<div class="section" id="va-arg-instruction">
<span id="i-va-arg"></span><h4><a class="toc-backref" href="#id1137">&#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; Instruction</a><a class="headerlink" href="#va-arg-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id305">
<h5><a class="toc-backref" href="#id1138">Syntax:</a><a class="headerlink" href="#id305" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">va_arg</span> <span class="o">&lt;</span><span class="n">va_list</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">arglist</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">argty</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id306">
<h5><a class="toc-backref" href="#id1139">Overview:</a><a class="headerlink" href="#id306" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; instruction is used to access arguments passed through
the &#8220;variable argument&#8221; area of a function call. It is used to implement
the <code class="docutils literal"><span class="pre">va_arg</span></code> macro in C.</p>
</div>
<div class="section" id="id307">
<h5><a class="toc-backref" href="#id1140">Arguments:</a><a class="headerlink" href="#id307" title="永久链接至标题">¶</a></h5>
<p>This instruction takes a <code class="docutils literal"><span class="pre">va_list*</span></code> value and the type of the
argument. It returns a value of the specified argument type and
increments the <code class="docutils literal"><span class="pre">va_list</span></code> to point to the next argument. The actual
type of <code class="docutils literal"><span class="pre">va_list</span></code> is target specific.</p>
</div>
<div class="section" id="id308">
<h5><a class="toc-backref" href="#id1141">Semantics:</a><a class="headerlink" href="#id308" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">va_arg</span></code>&#8216; instruction loads an argument of the specified type
from the specified <code class="docutils literal"><span class="pre">va_list</span></code> and causes the <code class="docutils literal"><span class="pre">va_list</span></code> to point to
the next argument. For more information, see the variable argument
handling <a class="reference internal" href="#int-varargs"><span class="std std-ref">Intrinsic Functions</span></a>.</p>
<p>It is legal for this instruction to be called in a function which does
not take a variable number of arguments, for example, the <code class="docutils literal"><span class="pre">vfprintf</span></code>
function.</p>
<p><code class="docutils literal"><span class="pre">va_arg</span></code> is an LLVM instruction instead of an <a class="reference internal" href="#intrinsics"><span class="std std-ref">intrinsic
function</span></a> because it takes a type as an argument.</p>
</div>
<div class="section" id="id309">
<h5><a class="toc-backref" href="#id1142">Example:</a><a class="headerlink" href="#id309" title="永久链接至标题">¶</a></h5>
<p>See the <a class="reference internal" href="#int-varargs"><span class="std std-ref">variable argument processing</span></a> section.</p>
<p>Note that the code generator does not yet fully support va_arg on many
targets. Also, it does not currently support va_arg with aggregate
types on any target.</p>
</div>
</div>
<div class="section" id="landingpad-instruction">
<span id="i-landingpad"></span><h4><a class="toc-backref" href="#id1143">&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; Instruction</a><a class="headerlink" href="#landingpad-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id310">
<h5><a class="toc-backref" href="#id1144">Syntax:</a><a class="headerlink" href="#id310" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">landingpad</span> <span class="o">&lt;</span><span class="n">resultty</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;+</span>
<span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">landingpad</span> <span class="o">&lt;</span><span class="n">resultty</span><span class="o">&gt;</span> <span class="n">cleanup</span> <span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;*</span>

<span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">=</span> <span class="n">catch</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">clause</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">=</span> <span class="nb">filter</span> <span class="o">&lt;</span><span class="n">array</span> <span class="n">constant</span> <span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">array</span> <span class="n">constant</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id311">
<h5><a class="toc-backref" href="#id1145">Overview:</a><a class="headerlink" href="#id311" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling
system</a> to specify that a basic block
is a landing pad &#8212; one where the exception lands, and corresponds to the
code found in the <code class="docutils literal"><span class="pre">catch</span></code> portion of a <code class="docutils literal"><span class="pre">try</span></code>/<code class="docutils literal"><span class="pre">catch</span></code> sequence. It
defines values supplied by the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> upon
re-entry to the function. The <code class="docutils literal"><span class="pre">resultval</span></code> has the type <code class="docutils literal"><span class="pre">resultty</span></code>.</p>
</div>
<div class="section" id="id313">
<h5><a class="toc-backref" href="#id1146">Arguments:</a><a class="headerlink" href="#id313" title="永久链接至标题">¶</a></h5>
<p>The optional
<code class="docutils literal"><span class="pre">cleanup</span></code> flag indicates that the landing pad block is a cleanup.</p>
<p>A <code class="docutils literal"><span class="pre">clause</span></code> begins with the clause type &#8212; <code class="docutils literal"><span class="pre">catch</span></code> or <code class="docutils literal"><span class="pre">filter</span></code> &#8212; and
contains the global variable representing the &#8220;type&#8221; that may be caught
or filtered respectively. Unlike the <code class="docutils literal"><span class="pre">catch</span></code> clause, the <code class="docutils literal"><span class="pre">filter</span></code>
clause takes an array constant as its argument. Use
&#8220;<code class="docutils literal"><span class="pre">[0</span> <span class="pre">x</span> <span class="pre">i8**]</span> <span class="pre">undef</span></code>&#8221; for a filter which cannot throw. The
&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction must contain <em>at least</em> one <code class="docutils literal"><span class="pre">clause</span></code> or
the <code class="docutils literal"><span class="pre">cleanup</span></code> flag.</p>
</div>
<div class="section" id="id314">
<h5><a class="toc-backref" href="#id1147">Semantics:</a><a class="headerlink" href="#id314" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction defines the values which are set by the
<a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> upon re-entry to the function, and
therefore the &#8220;result type&#8221; of the <code class="docutils literal"><span class="pre">landingpad</span></code> instruction. As with
calling conventions, how the personality function results are
represented in LLVM IR is target specific.</p>
<p>The clauses are applied in order from top to bottom. If two
<code class="docutils literal"><span class="pre">landingpad</span></code> instructions are merged together through inlining, the
clauses from the calling function are appended to the list of clauses.
When the call stack is being unwound due to an exception being thrown,
the exception is compared against each <code class="docutils literal"><span class="pre">clause</span></code> in turn. If it doesn&#8217;t
match any of the clauses, and the <code class="docutils literal"><span class="pre">cleanup</span></code> flag is not set, then
unwinding continues further up the call stack.</p>
<p>The <code class="docutils literal"><span class="pre">landingpad</span></code> instruction has several restrictions:</p>
<ul class="simple">
<li>A landing pad block is a basic block which is the unwind destination
of an &#8216;<code class="docutils literal"><span class="pre">invoke</span></code>&#8216; instruction.</li>
<li>A landing pad block must have a &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction as its
first non-PHI instruction.</li>
<li>There can be only one &#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction within the landing
pad block.</li>
<li>A basic block that is not a landing pad block may not include a
&#8216;<code class="docutils literal"><span class="pre">landingpad</span></code>&#8216; instruction.</li>
</ul>
</div>
<div class="section" id="id315">
<h5><a class="toc-backref" href="#id1148">Example:</a><a class="headerlink" href="#id315" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">;; A landing pad which can catch an integer.</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">landingpad</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
         <span class="k">catch</span> <span class="k">i8</span><span class="p">**</span> <span class="vg">@_ZTIi</span>
<span class="c">;; A landing pad that is a cleanup.</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">landingpad</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
         <span class="k">cleanup</span>
<span class="c">;; A landing pad which can catch an integer and can only throw a double.</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">landingpad</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span> <span class="p">}</span>
         <span class="k">catch</span> <span class="k">i8</span><span class="p">**</span> <span class="vg">@_ZTIi</span>
         <span class="k">filter</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="k">i8</span><span class="p">**]</span> <span class="p">[</span><span class="vg">@_ZTId</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="catchpad-instruction">
<span id="i-catchpad"></span><h4><a class="toc-backref" href="#id1149">&#8216;<code class="docutils literal"><span class="pre">catchpad</span></code>&#8216; Instruction</a><a class="headerlink" href="#catchpad-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id316">
<h5><a class="toc-backref" href="#id1150">Syntax:</a><a class="headerlink" href="#id316" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">catchpad</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">catchswitch</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;*</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id317">
<h5><a class="toc-backref" href="#id1151">Overview:</a><a class="headerlink" href="#id317" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">catchpad</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling
system</a> to specify that a basic block
begins a catch handler &#8212; one where a personality routine attempts to transfer
control to catch an exception.</p>
</div>
<div class="section" id="id319">
<h5><a class="toc-backref" href="#id1152">Arguments:</a><a class="headerlink" href="#id319" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">catchswitch</span></code> operand must always be a token produced by a
<a class="reference internal" href="#i-catchswitch"><span class="std std-ref">catchswitch</span></a> instruction in a predecessor block. This
ensures that each <code class="docutils literal"><span class="pre">catchpad</span></code> has exactly one predecessor block, and it always
terminates in a <code class="docutils literal"><span class="pre">catchswitch</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">args</span></code> correspond to whatever information the personality routine
requires to know if this is an appropriate handler for the exception. Control
will transfer to the <code class="docutils literal"><span class="pre">catchpad</span></code> if this is the first appropriate handler for
the exception.</p>
<p>The <code class="docutils literal"><span class="pre">resultval</span></code> has the type <a class="reference internal" href="#t-token"><span class="std std-ref">token</span></a> and is used to match the
<code class="docutils literal"><span class="pre">catchpad</span></code> to corresponding <a class="reference internal" href="#i-catchret"><span class="std std-ref">catchrets</span></a> and other nested EH
pads.</p>
</div>
<div class="section" id="id320">
<h5><a class="toc-backref" href="#id1153">Semantics:</a><a class="headerlink" href="#id320" title="永久链接至标题">¶</a></h5>
<p>When the call stack is being unwound due to an exception being thrown, the
exception is compared against the <code class="docutils literal"><span class="pre">args</span></code>. If it doesn&#8217;t match, control will
not reach the <code class="docutils literal"><span class="pre">catchpad</span></code> instruction.  The representation of <code class="docutils literal"><span class="pre">args</span></code> is
entirely target and personality function-specific.</p>
<p>Like the <a class="reference internal" href="#i-landingpad"><span class="std std-ref">landingpad</span></a> instruction, the <code class="docutils literal"><span class="pre">catchpad</span></code>
instruction must be the first non-phi of its parent basic block.</p>
<p>The meaning of the tokens produced and consumed by <code class="docutils literal"><span class="pre">catchpad</span></code> and other &#8220;pad&#8221;
instructions is described in the
<a class="reference external" href="ExceptionHandling.html#wineh">Windows exception handling documentation</a>.</p>
<p>When a <code class="docutils literal"><span class="pre">catchpad</span></code> has been &#8220;entered&#8221; but not yet &#8220;exited&#8221; (as
described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
it is undefined behavior to execute a <a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a> or <a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>
that does not carry an appropriate <a class="reference internal" href="#ob-funclet"><span class="std std-ref">&#8220;funclet&#8221; bundle</span></a>.</p>
</div>
<div class="section" id="id322">
<h5><a class="toc-backref" href="#id1154">Example:</a><a class="headerlink" href="#id322" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>dispatch:
  %cs = catchswitch within none [label %handler0] unwind to caller
  ;; A catch block which can catch an integer.
handler0:
  %tok = catchpad within %cs [i8** @_ZTIi]
</pre></div>
</div>
</div>
</div>
<div class="section" id="cleanuppad-instruction">
<span id="i-cleanuppad"></span><h4><a class="toc-backref" href="#id1155">&#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; Instruction</a><a class="headerlink" href="#cleanuppad-instruction" title="永久链接至标题">¶</a></h4>
<div class="section" id="id323">
<h5><a class="toc-backref" href="#id1156">Syntax:</a><a class="headerlink" href="#id323" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">resultval</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">cleanuppad</span> <span class="n">within</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;*</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id324">
<h5><a class="toc-backref" href="#id1157">Overview:</a><a class="headerlink" href="#id324" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction is used by <a class="reference external" href="ExceptionHandling.html#overview">LLVM&#8217;s exception handling
system</a> to specify that a basic block
is a cleanup block &#8212; one where a personality routine attempts to
transfer control to run cleanup actions.
The <code class="docutils literal"><span class="pre">args</span></code> correspond to whatever additional
information the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> requires to
execute the cleanup.
The <code class="docutils literal"><span class="pre">resultval</span></code> has the type <a class="reference internal" href="#t-token"><span class="std std-ref">token</span></a> and is used to
match the <code class="docutils literal"><span class="pre">cleanuppad</span></code> to corresponding <a class="reference internal" href="#i-cleanupret"><span class="std std-ref">cleanuprets</span></a>.
The <code class="docutils literal"><span class="pre">parent</span></code> argument is the token of the funclet that contains the
<code class="docutils literal"><span class="pre">cleanuppad</span></code> instruction. If the <code class="docutils literal"><span class="pre">cleanuppad</span></code> is not inside a funclet,
this operand may be the token <code class="docutils literal"><span class="pre">none</span></code>.</p>
</div>
<div class="section" id="id326">
<h5><a class="toc-backref" href="#id1158">Arguments:</a><a class="headerlink" href="#id326" title="永久链接至标题">¶</a></h5>
<p>The instruction takes a list of arbitrary values which are interpreted
by the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a>.</p>
</div>
<div class="section" id="id327">
<h5><a class="toc-backref" href="#id1159">Semantics:</a><a class="headerlink" href="#id327" title="永久链接至标题">¶</a></h5>
<p>When the call stack is being unwound due to an exception being thrown,
the <a class="reference internal" href="#personalityfn"><span class="std std-ref">personality function</span></a> transfers control to the
<code class="docutils literal"><span class="pre">cleanuppad</span></code> with the aid of the personality-specific arguments.
As with calling conventions, how the personality function results are
represented in LLVM IR is target specific.</p>
<p>The <code class="docutils literal"><span class="pre">cleanuppad</span></code> instruction has several restrictions:</p>
<ul class="simple">
<li>A cleanup block is a basic block which is the unwind destination of
an exceptional instruction.</li>
<li>A cleanup block must have a &#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction as its
first non-PHI instruction.</li>
<li>There can be only one &#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction within the
cleanup block.</li>
<li>A basic block that is not a cleanup block may not include a
&#8216;<code class="docutils literal"><span class="pre">cleanuppad</span></code>&#8216; instruction.</li>
</ul>
<p>When a <code class="docutils literal"><span class="pre">cleanuppad</span></code> has been &#8220;entered&#8221; but not yet &#8220;exited&#8221; (as
described in the <a class="reference external" href="ExceptionHandling.html#wineh-constraints">EH documentation</a>),
it is undefined behavior to execute a <a class="reference internal" href="#i-call"><span class="std std-ref">call</span></a> or <a class="reference internal" href="#i-invoke"><span class="std std-ref">invoke</span></a>
that does not carry an appropriate <a class="reference internal" href="#ob-funclet"><span class="std std-ref">&#8220;funclet&#8221; bundle</span></a>.</p>
</div>
<div class="section" id="id329">
<h5><a class="toc-backref" href="#id1160">Example:</a><a class="headerlink" href="#id329" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>%tok = cleanuppad within %cs []
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="intrinsic-functions">
<span id="intrinsics"></span><h2><a class="toc-backref" href="#id1161">Intrinsic Functions</a><a class="headerlink" href="#intrinsic-functions" title="永久链接至标题">¶</a></h2>
<p>LLVM supports the notion of an &#8220;intrinsic function&#8221;. These functions
have well known names and semantics and are required to follow certain
restrictions. Overall, these intrinsics represent an extension mechanism
for the LLVM language that does not require changing all of the
transformations in LLVM when adding to the language (or the bitcode
reader/writer, the parser, etc...).</p>
<p>Intrinsic function names must all start with an &#8220;<code class="docutils literal"><span class="pre">llvm.</span></code>&#8221; prefix. This
prefix is reserved in LLVM for intrinsic names; thus, function names may
not begin with this prefix. Intrinsic functions must always be external
functions: you cannot define the body of intrinsic functions. Intrinsic
functions may only be used in call or invoke instructions: it is illegal
to take the address of an intrinsic function. Additionally, because
intrinsic functions are part of the LLVM language, it is required if any
are added that they be documented here.</p>
<p>Some intrinsic functions can be overloaded, i.e., the intrinsic
represents a family of functions that perform the same operation but on
different data types. Because LLVM can represent over 8 million
different integer types, overloading is used commonly to allow an
intrinsic function to operate on any integer type. One or more of the
argument types or the result type can be overloaded to accept any
integer type. Argument types may also be defined as exactly matching a
previous argument&#8217;s type or the result type. This allows an intrinsic
function which accepts multiple arguments, but needs all of them to be
of the same type, to only be overloaded with respect to a single
argument or the result.</p>
<p>Overloaded intrinsics will have the names of its overloaded argument
types encoded into its function name, each preceded by a period. Only
those types which are overloaded result in a name suffix. Arguments
whose type is matched against another type do not. For example, the
<code class="docutils literal"><span class="pre">llvm.ctpop</span></code> function can take an integer of any width and returns an
integer of exactly the same integer width. This leads to a family of
functions such as <code class="docutils literal"><span class="pre">i8</span> <span class="pre">&#64;llvm.ctpop.i8(i8</span> <span class="pre">%val)</span></code> and
<code class="docutils literal"><span class="pre">i29</span> <span class="pre">&#64;llvm.ctpop.i29(i29</span> <span class="pre">%val)</span></code>. Only one type, the return type, is
overloaded, and only one type suffix is required. Because the argument&#8217;s
type is matched against the return type, it does not require its own
name suffix.</p>
<p>To learn how to add an intrinsic function, please see the <a class="reference external" href="ExtendingLLVM.html">Extending
LLVM Guide</a>.</p>
<div class="section" id="variable-argument-handling-intrinsics">
<span id="int-varargs"></span><h3><a class="toc-backref" href="#id1162">Variable Argument Handling Intrinsics</a><a class="headerlink" href="#variable-argument-handling-intrinsics" title="永久链接至标题">¶</a></h3>
<p>Variable argument support is defined in LLVM with the
<a class="reference internal" href="#i-va-arg"><span class="std std-ref">va_arg</span></a> instruction and these three intrinsic
functions. These functions are related to the similarly named macros
defined in the <code class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></code> header file.</p>
<p>All of these functions operate on arguments that use a target-specific
value type &#8220;<code class="docutils literal"><span class="pre">va_list</span></code>&#8221;. The LLVM assembly language reference manual
does not define what this type is, so all transformations should be
prepared to handle these functions regardless of the type used.</p>
<p>This example shows how the <a class="reference internal" href="#i-va-arg"><span class="std std-ref">va_arg</span></a> instruction and the
variable argument handling intrinsic functions are used.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">; This struct is different for every platform. For most platforms,</span>
<span class="c">; it is merely an i8*.</span>
<span class="nv">%struct.va_list</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="k">i8</span><span class="p">*</span> <span class="p">}</span>

<span class="c">; For Unix x86_64 platforms, va_list is the following struct:</span>
<span class="c">; %struct.va_list = type { i32, i32, i8*, i8* }</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="c">; Initialize variable argument processing</span>
  <span class="nv">%ap</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%struct.va_list</span>
  <span class="nv">%ap2</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="nv">%struct.va_list</span><span class="p">*</span> <span class="nv">%ap</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_start</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">)</span>

  <span class="c">; Read a single integer argument</span>
  <span class="nv">%tmp</span> <span class="p">=</span> <span class="k">va_arg</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">,</span> <span class="k">i32</span>

  <span class="c">; Demonstrate usage of llvm.va_copy and llvm.va_end</span>
  <span class="nv">%aq</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i8</span><span class="p">*</span>
  <span class="nv">%aq2</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%aq</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_copy</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%aq2</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">)</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_end</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%aq2</span><span class="p">)</span>

  <span class="c">; Stop processing of arguments.</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.va_end</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ap2</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%tmp</span>
<span class="p">}</span>

<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.va_start</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.va_copy</span><span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i8</span><span class="p">*)</span>
<span class="k">declare</span> <span class="kt">void</span> <span class="vg">@llvm.va_end</span><span class="p">(</span><span class="k">i8</span><span class="p">*)</span>
</pre></div>
</div>
<div class="section" id="llvm-va-start-intrinsic">
<span id="int-va-start"></span><h4><a class="toc-backref" href="#id1163">&#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-va-start-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id330">
<h5><a class="toc-backref" href="#id1164">Syntax:</a><a class="headerlink" href="#id330" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">va_start</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">arglist</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id331">
<h5><a class="toc-backref" href="#id1165">Overview:</a><a class="headerlink" href="#id331" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; intrinsic initializes <code class="docutils literal"><span class="pre">*&lt;arglist&gt;</span></code> for
subsequent use by <code class="docutils literal"><span class="pre">va_arg</span></code>.</p>
</div>
<div class="section" id="id332">
<h5><a class="toc-backref" href="#id1166">Arguments:</a><a class="headerlink" href="#id332" title="永久链接至标题">¶</a></h5>
<p>The argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> element to initialize.</p>
</div>
<div class="section" id="id333">
<h5><a class="toc-backref" href="#id1167">Semantics:</a><a class="headerlink" href="#id333" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_start</span></code>&#8216; intrinsic works just like the <code class="docutils literal"><span class="pre">va_start</span></code> macro
available in C. In a target-dependent way, it initializes the
<code class="docutils literal"><span class="pre">va_list</span></code> element to which the argument points, so that the next call
to <code class="docutils literal"><span class="pre">va_arg</span></code> will produce the first variable argument passed to the
function. Unlike the C <code class="docutils literal"><span class="pre">va_start</span></code> macro, this intrinsic does not need
to know the last argument of the function as the compiler can figure
that out.</p>
</div>
</div>
<div class="section" id="llvm-va-end-intrinsic">
<h4><a class="toc-backref" href="#id1168">&#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-va-end-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id334">
<h5><a class="toc-backref" href="#id1169">Syntax:</a><a class="headerlink" href="#id334" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">va_end</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">arglist</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id335">
<h5><a class="toc-backref" href="#id1170">Overview:</a><a class="headerlink" href="#id335" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; intrinsic destroys <code class="docutils literal"><span class="pre">*&lt;arglist&gt;</span></code>, which has been
initialized previously with <code class="docutils literal"><span class="pre">llvm.va_start</span></code> or <code class="docutils literal"><span class="pre">llvm.va_copy</span></code>.</p>
</div>
<div class="section" id="id336">
<h5><a class="toc-backref" href="#id1171">Arguments:</a><a class="headerlink" href="#id336" title="永久链接至标题">¶</a></h5>
<p>The argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> to destroy.</p>
</div>
<div class="section" id="id337">
<h5><a class="toc-backref" href="#id1172">Semantics:</a><a class="headerlink" href="#id337" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_end</span></code>&#8216; intrinsic works just like the <code class="docutils literal"><span class="pre">va_end</span></code> macro
available in C. In a target-dependent way, it destroys the <code class="docutils literal"><span class="pre">va_list</span></code>
element to which the argument points. Calls to
<a class="reference internal" href="#int-va-start"><span class="std std-ref">llvm.va_start</span></a> and
<a class="reference internal" href="#int-va-copy"><span class="std std-ref">llvm.va_copy</span></a> must be matched exactly with calls to
<code class="docutils literal"><span class="pre">llvm.va_end</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-va-copy-intrinsic">
<span id="int-va-copy"></span><h4><a class="toc-backref" href="#id1173">&#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-va-copy-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id338">
<h5><a class="toc-backref" href="#id1174">Syntax:</a><a class="headerlink" href="#id338" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">va_copy</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">destarglist</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">srcarglist</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id339">
<h5><a class="toc-backref" href="#id1175">Overview:</a><a class="headerlink" href="#id339" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; intrinsic copies the current argument position
from the source argument list to the destination argument list.</p>
</div>
<div class="section" id="id340">
<h5><a class="toc-backref" href="#id1176">Arguments:</a><a class="headerlink" href="#id340" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> element to initialize.
The second argument is a pointer to a <code class="docutils literal"><span class="pre">va_list</span></code> element to copy from.</p>
</div>
<div class="section" id="id341">
<h5><a class="toc-backref" href="#id1177">Semantics:</a><a class="headerlink" href="#id341" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.va_copy</span></code>&#8216; intrinsic works just like the <code class="docutils literal"><span class="pre">va_copy</span></code> macro
available in C. In a target-dependent way, it copies the source
<code class="docutils literal"><span class="pre">va_list</span></code> element into the destination <code class="docutils literal"><span class="pre">va_list</span></code> element. This
intrinsic is necessary because the `` llvm.va_start`` intrinsic may be
arbitrarily complex and require, for example, memory allocation.</p>
</div>
</div>
</div>
<div class="section" id="accurate-garbage-collection-intrinsics">
<h3><a class="toc-backref" href="#id1178">Accurate Garbage Collection Intrinsics</a><a class="headerlink" href="#accurate-garbage-collection-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM&#8217;s support for <a class="reference external" href="GarbageCollection.html">Accurate Garbage Collection</a>
(GC) requires the frontend to generate code containing appropriate intrinsic
calls and select an appropriate GC strategy which knows how to lower these
intrinsics in a manner which is appropriate for the target collector.</p>
<p>These intrinsics allow identification of <a class="reference internal" href="#int-gcroot"><span class="std std-ref">GC roots on the
stack</span></a>, as well as garbage collector implementations that
require <a class="reference internal" href="#int-gcread"><span class="std std-ref">read</span></a> and <a class="reference internal" href="#int-gcwrite"><span class="std std-ref">write</span></a> barriers.
Frontends for type-safe garbage collected languages should generate
these intrinsics to make use of the LLVM garbage collectors. For more
details, see <a class="reference external" href="GarbageCollection.html">Garbage Collection with LLVM</a>.</p>
<div class="section" id="experimental-statepoint-intrinsics">
<h4><a class="toc-backref" href="#id1179">Experimental Statepoint Intrinsics</a><a class="headerlink" href="#experimental-statepoint-intrinsics" title="永久链接至标题">¶</a></h4>
<p>LLVM provides an second experimental set of intrinsics for describing garbage
collection safepoints in compiled code. These intrinsics are an alternative
to the <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> intrinsics, but are compatible with the ones for
<a class="reference internal" href="#int-gcread"><span class="std std-ref">read</span></a> and <a class="reference internal" href="#int-gcwrite"><span class="std std-ref">write</span></a> barriers. The
differences in approach are covered in the <a class="reference external" href="GarbageCollection.html">Garbage Collection with LLVM</a> documentation. The intrinsics themselves are
described in <a class="reference internal" href="Statepoints.html"><span class="doc">Garbage Collection Safepoints in LLVM</span></a>.</p>
</div>
<div class="section" id="llvm-gcroot-intrinsic">
<span id="int-gcroot"></span><h4><a class="toc-backref" href="#id1180">&#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-gcroot-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id343">
<h5><a class="toc-backref" href="#id1181">Syntax:</a><a class="headerlink" href="#id343" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">gcroot</span><span class="p">(</span><span class="n">i8</span><span class="o">**</span> <span class="o">%</span><span class="n">ptrloc</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">metadata</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id344">
<h5><a class="toc-backref" href="#id1182">Overview:</a><a class="headerlink" href="#id344" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; intrinsic declares the existence of a GC root to
the code generator, and allows some metadata to be associated with it.</p>
</div>
<div class="section" id="id345">
<h5><a class="toc-backref" href="#id1183">Arguments:</a><a class="headerlink" href="#id345" title="永久链接至标题">¶</a></h5>
<p>The first argument specifies the address of a stack object that contains
the root pointer. The second pointer (which must be either a constant or
a global value address) contains the meta-data to be associated with the
root.</p>
</div>
<div class="section" id="id346">
<h5><a class="toc-backref" href="#id1184">Semantics:</a><a class="headerlink" href="#id346" title="永久链接至标题">¶</a></h5>
<p>At runtime, a call to this intrinsic stores a null pointer into the
&#8220;ptrloc&#8221; location. At compile-time, the code generator generates
information to allow the runtime to find the pointer at GC safe points.
The &#8216;<code class="docutils literal"><span class="pre">llvm.gcroot</span></code>&#8216; intrinsic may only be used in a function which
<a class="reference internal" href="#gc"><span class="std std-ref">specifies a GC algorithm</span></a>.</p>
</div>
</div>
<div class="section" id="llvm-gcread-intrinsic">
<span id="int-gcread"></span><h4><a class="toc-backref" href="#id1185">&#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-gcread-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id347">
<h5><a class="toc-backref" href="#id1186">Syntax:</a><a class="headerlink" href="#id347" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">gcread</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">ObjPtr</span><span class="p">,</span> <span class="n">i8</span><span class="o">**</span> <span class="o">%</span><span class="n">Ptr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id348">
<h5><a class="toc-backref" href="#id1187">Overview:</a><a class="headerlink" href="#id348" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; intrinsic identifies reads of references from heap
locations, allowing garbage collector implementations that require read
barriers.</p>
</div>
<div class="section" id="id349">
<h5><a class="toc-backref" href="#id1188">Arguments:</a><a class="headerlink" href="#id349" title="永久链接至标题">¶</a></h5>
<p>The second argument is the address to read from, which should be an
address allocated from the garbage collector. The first object is a
pointer to the start of the referenced object, if needed by the language
runtime (otherwise null).</p>
</div>
<div class="section" id="id350">
<h5><a class="toc-backref" href="#id1189">Semantics:</a><a class="headerlink" href="#id350" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216; intrinsic has the same semantics as a load
instruction, but may be replaced with substantially more complex code by
the garbage collector runtime, as needed. The &#8216;<code class="docutils literal"><span class="pre">llvm.gcread</span></code>&#8216;
intrinsic may only be used in a function which <a class="reference internal" href="#gc"><span class="std std-ref">specifies a GC
algorithm</span></a>.</p>
</div>
</div>
<div class="section" id="llvm-gcwrite-intrinsic">
<span id="int-gcwrite"></span><h4><a class="toc-backref" href="#id1190">&#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-gcwrite-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id351">
<h5><a class="toc-backref" href="#id1191">Syntax:</a><a class="headerlink" href="#id351" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">gcwrite</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">P1</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">Obj</span><span class="p">,</span> <span class="n">i8</span><span class="o">**</span> <span class="o">%</span><span class="n">P2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id352">
<h5><a class="toc-backref" href="#id1192">Overview:</a><a class="headerlink" href="#id352" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; intrinsic identifies writes of references to heap
locations, allowing garbage collector implementations that require write
barriers (such as generational or reference counting collectors).</p>
</div>
<div class="section" id="id353">
<h5><a class="toc-backref" href="#id1193">Arguments:</a><a class="headerlink" href="#id353" title="永久链接至标题">¶</a></h5>
<p>The first argument is the reference to store, the second is the start of
the object to store it to, and the third is the address of the field of
Obj to store to. If the runtime does not require a pointer to the
object, Obj may be null.</p>
</div>
<div class="section" id="id354">
<h5><a class="toc-backref" href="#id1194">Semantics:</a><a class="headerlink" href="#id354" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216; intrinsic has the same semantics as a store
instruction, but may be replaced with substantially more complex code by
the garbage collector runtime, as needed. The &#8216;<code class="docutils literal"><span class="pre">llvm.gcwrite</span></code>&#8216;
intrinsic may only be used in a function which <a class="reference internal" href="#gc"><span class="std std-ref">specifies a GC
algorithm</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="code-generator-intrinsics">
<h3><a class="toc-backref" href="#id1195">Code Generator Intrinsics</a><a class="headerlink" href="#code-generator-intrinsics" title="永久链接至标题">¶</a></h3>
<p>These intrinsics are provided by LLVM to expose special features that
may only be implemented with code generator support.</p>
<div class="section" id="llvm-returnaddress-intrinsic">
<h4><a class="toc-backref" href="#id1196">&#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-returnaddress-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id355">
<h5><a class="toc-backref" href="#id1197">Syntax:</a><a class="headerlink" href="#id355" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span>  <span class="o">*</span><span class="nd">@llvm</span><span class="o">.</span><span class="n">returnaddress</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">level</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id356">
<h5><a class="toc-backref" href="#id1198">Overview:</a><a class="headerlink" href="#id356" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; intrinsic attempts to compute a
target-specific value indicating the return address of the current
function or one of its callers.</p>
</div>
<div class="section" id="id357">
<h5><a class="toc-backref" href="#id1199">Arguments:</a><a class="headerlink" href="#id357" title="永久链接至标题">¶</a></h5>
<p>The argument to this intrinsic indicates which function to return the
address for. Zero indicates the calling function, one indicates its
caller, etc. The argument is <strong>required</strong> to be a constant integer
value.</p>
</div>
<div class="section" id="id358">
<h5><a class="toc-backref" href="#id1200">Semantics:</a><a class="headerlink" href="#id358" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.returnaddress</span></code>&#8216; intrinsic either returns a pointer
indicating the return address of the specified call frame, or zero if it
cannot be identified. The value returned by this intrinsic is likely to
be incorrect or 0 for arguments other than zero, so it should only be
used for debugging purposes.</p>
<p>Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.</p>
</div>
</div>
<div class="section" id="llvm-frameaddress-intrinsic">
<h4><a class="toc-backref" href="#id1201">&#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-frameaddress-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id359">
<h5><a class="toc-backref" href="#id1202">Syntax:</a><a class="headerlink" href="#id359" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">frameaddress</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">level</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id360">
<h5><a class="toc-backref" href="#id1203">Overview:</a><a class="headerlink" href="#id360" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; intrinsic attempts to return the
target-specific frame pointer value for the specified stack frame.</p>
</div>
<div class="section" id="id361">
<h5><a class="toc-backref" href="#id1204">Arguments:</a><a class="headerlink" href="#id361" title="永久链接至标题">¶</a></h5>
<p>The argument to this intrinsic indicates which function to return the
frame pointer for. Zero indicates the calling function, one indicates
its caller, etc. The argument is <strong>required</strong> to be a constant integer
value.</p>
</div>
<div class="section" id="id362">
<h5><a class="toc-backref" href="#id1205">Semantics:</a><a class="headerlink" href="#id362" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.frameaddress</span></code>&#8216; intrinsic either returns a pointer
indicating the frame address of the specified call frame, or zero if it
cannot be identified. The value returned by this intrinsic is likely to
be incorrect or 0 for arguments other than zero, so it should only be
used for debugging purposes.</p>
<p>Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.</p>
</div>
</div>
<div class="section" id="llvm-localescape-and-llvm-localrecover-intrinsics">
<h4><a class="toc-backref" href="#id1206">&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-localescape-and-llvm-localrecover-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id363">
<h5><a class="toc-backref" href="#id1207">Syntax:</a><a class="headerlink" href="#id363" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">localescape</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">localrecover</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">func</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">fp</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id364">
<h5><a class="toc-backref" href="#id1208">Overview:</a><a class="headerlink" href="#id364" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; intrinsic escapes offsets of a collection of static
allocas, and the &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; intrinsic applies those offsets to a
live frame pointer to recover the address of the allocation. The offset is
computed during frame layout of the caller of <code class="docutils literal"><span class="pre">llvm.localescape</span></code>.</p>
</div>
<div class="section" id="id365">
<h5><a class="toc-backref" href="#id1209">Arguments:</a><a class="headerlink" href="#id365" title="永久链接至标题">¶</a></h5>
<p>All arguments to &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; must be pointers to static allocas or
casts of static allocas. Each function can only call &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216;
once, and it can only do so from the entry block.</p>
<p>The <code class="docutils literal"><span class="pre">func</span></code> argument to &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; must be a constant
bitcasted pointer to a function defined in the current module. The code
generator cannot determine the frame allocation offset of functions defined in
other modules.</p>
<p>The <code class="docutils literal"><span class="pre">fp</span></code> argument to &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; must be a frame pointer of a
call frame that is currently live. The return value of &#8216;<code class="docutils literal"><span class="pre">llvm.localaddress</span></code>&#8216;
is one way to produce such a value, but various runtimes also expose a suitable
pointer in platform-specific ways.</p>
<p>The <code class="docutils literal"><span class="pre">idx</span></code> argument to &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; indicates which alloca passed to
&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; to recover. It is zero-indexed.</p>
</div>
<div class="section" id="id366">
<h5><a class="toc-backref" href="#id1210">Semantics:</a><a class="headerlink" href="#id366" title="永久链接至标题">¶</a></h5>
<p>These intrinsics allow a group of functions to share access to a set of local
stack allocations of a one parent function. The parent function may call the
&#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; intrinsic once from the function entry block, and the
child functions can use &#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216; to access the escaped allocas.
The &#8216;<code class="docutils literal"><span class="pre">llvm.localescape</span></code>&#8216; intrinsic blocks inlining, as inlining changes where
the escaped allocas are allocated, which would break attempts to use
&#8216;<code class="docutils literal"><span class="pre">llvm.localrecover</span></code>&#8216;.</p>
</div>
</div>
<div class="section" id="llvm-read-register-and-llvm-write-register-intrinsics">
<span id="int-write-register"></span><span id="int-read-register"></span><h4><a class="toc-backref" href="#id1211">&#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-read-register-and-llvm-write-register-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id367">
<h5><a class="toc-backref" href="#id1212">Syntax:</a><a class="headerlink" href="#id367" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span>declare i32 @llvm.read_register.i32(metadata)
declare i64 @llvm.read_register.i64(metadata)
declare void @llvm.write_register.i32(metadata, i32 @value)
declare void @llvm.write_register.i64(metadata, i64 @value)
!0 = !{!&quot;sp\00&quot;}
</pre></div>
</div>
</div>
<div class="section" id="id368">
<h5><a class="toc-backref" href="#id1213">Overview:</a><a class="headerlink" href="#id368" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; and &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; intrinsics
provides access to the named register. The register must be valid on
the architecture being compiled to. The type needs to be compatible
with the register being read.</p>
</div>
<div class="section" id="id369">
<h5><a class="toc-backref" href="#id1214">Semantics:</a><a class="headerlink" href="#id369" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.read_register</span></code>&#8216; intrinsic returns the current value of the
register, where possible. The &#8216;<code class="docutils literal"><span class="pre">llvm.write_register</span></code>&#8216; intrinsic sets
the current value of the register, where possible.</p>
<p>This is useful to implement named register global variables that need
to always be mapped to a specific register, as is common practice on
bare-metal programs including OS kernels.</p>
<p>The compiler doesn&#8217;t check for register availability or use of the used
register in surrounding code, including inline assembly. Because of that,
allocatable registers are not supported.</p>
<p>Warning: So far it only works with the stack pointer on selected
architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of
work is needed to support other registers and even more so, allocatable
registers.</p>
</div>
</div>
<div class="section" id="llvm-stacksave-intrinsic">
<span id="int-stacksave"></span><h4><a class="toc-backref" href="#id1215">&#8216;<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stacksave-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id370">
<h5><a class="toc-backref" href="#id1216">Syntax:</a><a class="headerlink" href="#id370" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stacksave</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id371">
<h5><a class="toc-backref" href="#id1217">Overview:</a><a class="headerlink" href="#id371" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>&#8216; intrinsic is used to remember the current state
of the function stack, for use with
<a class="reference internal" href="#int-stackrestore"><span class="std std-ref">llvm.stackrestore</span></a>. This is useful for
implementing language features like scoped automatic variable sized
arrays in C99.</p>
</div>
<div class="section" id="id372">
<h5><a class="toc-backref" href="#id1218">Semantics:</a><a class="headerlink" href="#id372" title="永久链接至标题">¶</a></h5>
<p>This intrinsic returns a opaque pointer value that can be passed to
<a class="reference internal" href="#int-stackrestore"><span class="std std-ref">llvm.stackrestore</span></a>. When an
<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code> intrinsic is executed with a value saved from
<code class="docutils literal"><span class="pre">llvm.stacksave</span></code>, it effectively restores the state of the stack to
the state it was in when the <code class="docutils literal"><span class="pre">llvm.stacksave</span></code> intrinsic executed. In
practice, this pops any <a class="reference internal" href="#i-alloca"><span class="std std-ref">alloca</span></a> blocks from the stack that
were allocated after the <code class="docutils literal"><span class="pre">llvm.stacksave</span></code> was executed.</p>
</div>
</div>
<div class="section" id="llvm-stackrestore-intrinsic">
<span id="int-stackrestore"></span><h4><a class="toc-backref" href="#id1219">&#8216;<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stackrestore-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id373">
<h5><a class="toc-backref" href="#id1220">Syntax:</a><a class="headerlink" href="#id373" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackrestore</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id374">
<h5><a class="toc-backref" href="#id1221">Overview:</a><a class="headerlink" href="#id374" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.stackrestore</span></code>&#8216; intrinsic is used to restore the state of
the function stack to the state it was in when the corresponding
<a class="reference internal" href="#int-stacksave"><span class="std std-ref">llvm.stacksave</span></a> intrinsic executed. This is
useful for implementing language features like scoped automatic variable
sized arrays in C99.</p>
</div>
<div class="section" id="id375">
<h5><a class="toc-backref" href="#id1222">Semantics:</a><a class="headerlink" href="#id375" title="永久链接至标题">¶</a></h5>
<p>See the description for <a class="reference internal" href="#int-stacksave"><span class="std std-ref">llvm.stacksave</span></a>.</p>
</div>
</div>
<div class="section" id="llvm-get-dynamic-area-offset-intrinsic">
<span id="int-get-dynamic-area-offset"></span><h4><a class="toc-backref" href="#id1223">&#8216;<code class="docutils literal"><span class="pre">llvm.get.dynamic.area.offset</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-get-dynamic-area-offset-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id376">
<h5><a class="toc-backref" href="#id1224">Syntax:</a><a class="headerlink" href="#id376" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">dynamic</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">i32</span><span class="p">()</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">dynamic</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">i64</span><span class="p">()</span>

<span class="n">Overview</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">The &#39;``llvm.get.dynamic.area.offset.*``&#39; intrinsic family is used to</span>
<span class="s2">get the offset from native stack pointer to the address of the most</span>
<span class="s2">recent dynamic alloca on the caller&#39;s stack. These intrinsics are</span>
<span class="s2">intendend for use in combination with</span>
<span class="s2">:ref:`llvm.stacksave &lt;int_stacksave&gt;` to get a</span>
<span class="s2">pointer to the most recent dynamic alloca. This is useful, for example,</span>
<span class="s2">for AddressSanitizer&#39;s stack unpoisoning routines.</span>
</pre></div>
</div>
</div>
<div class="section" id="id377">
<h5><a class="toc-backref" href="#id1225">Semantics:</a><a class="headerlink" href="#id377" title="永久链接至标题">¶</a></h5>
<blockquote>
<div><p>These intrinsics return a non-negative integer value that can be used to
get the address of the most recent dynamic alloca, allocated by <a class="reference internal" href="#i-alloca"><span class="std std-ref">alloca</span></a>
on the caller&#8217;s stack. In particular, for targets where stack grows downwards,
adding this offset to the native stack pointer would get the address of the most
recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more
complicated, because substracting this value from stack pointer would get the address
one past the end of the most recent dynamic alloca.</p>
<p>Although for most targets <cite>llvm.get.dynamic.area.offset &lt;int_get_dynamic_area_offset&gt;</cite>
returns just a zero, for others, such as PowerPC and PowerPC64, it returns a
compile-time-known constant value.</p>
<p>The return value type of <a class="reference internal" href="#int-get-dynamic-area-offset"><span class="std std-ref">llvm.get.dynamic.area.offset</span></a>
must match the target&#8217;s generic address space&#8217;s (address space 0) pointer type.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="llvm-prefetch-intrinsic">
<h4><a class="toc-backref" href="#id1226">&#8216;<code class="docutils literal"><span class="pre">llvm.prefetch</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-prefetch-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id378">
<h5><a class="toc-backref" href="#id1227">Syntax:</a><a class="headerlink" href="#id378" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">rw</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">locality</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">cache</span> <span class="nb">type</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id379">
<h5><a class="toc-backref" href="#id1228">Overview:</a><a class="headerlink" href="#id379" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.prefetch</span></code>&#8216; intrinsic is a hint to the code generator to
insert a prefetch instruction if supported; otherwise, it is a noop.
Prefetches have no effect on the behavior of the program but can change
its performance characteristics.</p>
</div>
<div class="section" id="id380">
<h5><a class="toc-backref" href="#id1229">Arguments:</a><a class="headerlink" href="#id380" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">address</span></code> is the address to be prefetched, <code class="docutils literal"><span class="pre">rw</span></code> is the specifier
determining if the fetch should be for a read (0) or write (1), and
<code class="docutils literal"><span class="pre">locality</span></code> is a temporal locality specifier ranging from (0) - no
locality, to (3) - extremely local keep in cache. The <code class="docutils literal"><span class="pre">cache</span> <span class="pre">type</span></code>
specifies whether the prefetch is performed on the data (1) or
instruction (0) cache. The <code class="docutils literal"><span class="pre">rw</span></code>, <code class="docutils literal"><span class="pre">locality</span></code> and <code class="docutils literal"><span class="pre">cache</span> <span class="pre">type</span></code>
arguments must be constant integers.</p>
</div>
<div class="section" id="id381">
<h5><a class="toc-backref" href="#id1230">Semantics:</a><a class="headerlink" href="#id381" title="永久链接至标题">¶</a></h5>
<p>This intrinsic does not modify the behavior of the program. In
particular, prefetches cannot trap and do not produce a value. On
targets that support this intrinsic, the prefetch can provide hints to
the processor cache for better performance.</p>
</div>
</div>
<div class="section" id="llvm-pcmarker-intrinsic">
<h4><a class="toc-backref" href="#id1231">&#8216;<code class="docutils literal"><span class="pre">llvm.pcmarker</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-pcmarker-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id382">
<h5><a class="toc-backref" href="#id1232">Syntax:</a><a class="headerlink" href="#id382" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">pcmarker</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id383">
<h5><a class="toc-backref" href="#id1233">Overview:</a><a class="headerlink" href="#id383" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.pcmarker</span></code>&#8216; intrinsic is a method to export a Program
Counter (PC) in a region of code to simulators and other tools. The
method is target specific, but it is expected that the marker will use
exported symbols to transmit the PC of the marker. The marker makes no
guarantees that it will remain with any specific instruction after
optimizations. It is possible that the presence of a marker will inhibit
optimizations. The intended use is to be inserted after optimizations to
allow correlations of simulation runs.</p>
</div>
<div class="section" id="id384">
<h5><a class="toc-backref" href="#id1234">Arguments:</a><a class="headerlink" href="#id384" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">id</span></code> is a numerical id identifying the marker.</p>
</div>
<div class="section" id="id385">
<h5><a class="toc-backref" href="#id1235">Semantics:</a><a class="headerlink" href="#id385" title="永久链接至标题">¶</a></h5>
<p>This intrinsic does not modify the behavior of the program. Backends
that do not support this intrinsic may ignore it.</p>
</div>
</div>
<div class="section" id="llvm-readcyclecounter-intrinsic">
<h4><a class="toc-backref" href="#id1236">&#8216;<code class="docutils literal"><span class="pre">llvm.readcyclecounter</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-readcyclecounter-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id386">
<h5><a class="toc-backref" href="#id1237">Syntax:</a><a class="headerlink" href="#id386" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">readcyclecounter</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id387">
<h5><a class="toc-backref" href="#id1238">Overview:</a><a class="headerlink" href="#id387" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.readcyclecounter</span></code>&#8216; intrinsic provides access to the cycle
counter register (or similar low latency, high accuracy clocks) on those
targets that support it. On X86, it should map to RDTSC. On Alpha, it
should map to RPCC. As the backing counters overflow quickly (on the
order of 9 seconds on alpha), this should only be used for small
timings.</p>
</div>
<div class="section" id="id388">
<h5><a class="toc-backref" href="#id1239">Semantics:</a><a class="headerlink" href="#id388" title="永久链接至标题">¶</a></h5>
<p>When directly supported, reading the cycle counter should not modify any
memory. Implementations are allowed to either return a application
specific value or a system wide value. On backends without support, this
is lowered to a constant 0.</p>
<p>Note that runtime support may be conditional on the privilege-level code is
running at and the host platform.</p>
</div>
</div>
<div class="section" id="llvm-clear-cache-intrinsic">
<h4><a class="toc-backref" href="#id1240">&#8216;<code class="docutils literal"><span class="pre">llvm.clear_cache</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-clear-cache-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id389">
<h5><a class="toc-backref" href="#id1241">Syntax:</a><a class="headerlink" href="#id389" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id390">
<h5><a class="toc-backref" href="#id1242">Overview:</a><a class="headerlink" href="#id390" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.clear_cache</span></code>&#8216; intrinsic ensures visibility of modifications
in the specified range to the execution unit of the processor. On
targets with non-unified instruction and data cache, the implementation
flushes the instruction cache.</p>
</div>
<div class="section" id="id391">
<h5><a class="toc-backref" href="#id1243">Semantics:</a><a class="headerlink" href="#id391" title="永久链接至标题">¶</a></h5>
<p>On platforms with coherent instruction and data caches (e.g. x86), this
intrinsic is a nop. On platforms with non-coherent instruction and data
cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate
instructions or a system call, if cache flushing requires special
privileges.</p>
<p>The default behavior is to emit a call to <code class="docutils literal"><span class="pre">__clear_cache</span></code> from the run
time library.</p>
<p>This instrinsic does <em>not</em> empty the instruction pipeline. Modifications
of the current function are outside the scope of the intrinsic.</p>
</div>
</div>
<div class="section" id="llvm-instrprof-increment-intrinsic">
<h4><a class="toc-backref" href="#id1244">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_increment</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-instrprof-increment-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id392">
<h5><a class="toc-backref" href="#id1245">Syntax:</a><a class="headerlink" href="#id392" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">instrprof_increment</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">hash</span><span class="o">&gt;</span><span class="p">,</span>
                                       <span class="n">i32</span> <span class="o">&lt;</span><span class="n">num</span><span class="o">-</span><span class="n">counters</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">index</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id393">
<h5><a class="toc-backref" href="#id1246">Overview:</a><a class="headerlink" href="#id393" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_increment</span></code>&#8216; intrinsic can be emitted by a
frontend for use with instrumentation based profiling. These will be
lowered by the <code class="docutils literal"><span class="pre">-instrprof</span></code> pass to generate execution counts of a
program at runtime.</p>
</div>
<div class="section" id="id394">
<h5><a class="toc-backref" href="#id1247">Arguments:</a><a class="headerlink" href="#id394" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a global variable containing the
name of the entity being instrumented. This should generally be the
(mangled) function name for a set of counters.</p>
<p>The second argument is a hash value that can be used by the consumer
of the profile data to detect changes to the instrumented source, and
the third is the number of counters associated with <code class="docutils literal"><span class="pre">name</span></code>. It is an
error if <code class="docutils literal"><span class="pre">hash</span></code> or <code class="docutils literal"><span class="pre">num-counters</span></code> differ between two instances of
<code class="docutils literal"><span class="pre">instrprof_increment</span></code> that refer to the same name.</p>
<p>The last argument refers to which of the counters for <code class="docutils literal"><span class="pre">name</span></code> should
be incremented. It should be a value between 0 and <code class="docutils literal"><span class="pre">num-counters</span></code>.</p>
</div>
<div class="section" id="id395">
<h5><a class="toc-backref" href="#id1248">Semantics:</a><a class="headerlink" href="#id395" title="永久链接至标题">¶</a></h5>
<p>This intrinsic represents an increment of a profiling counter. It will
cause the <code class="docutils literal"><span class="pre">-instrprof</span></code> pass to generate the appropriate data
structures and the code to increment the appropriate value, in a
format that can be written out by a compiler runtime and consumed via
the <code class="docutils literal"><span class="pre">llvm-profdata</span></code> tool.</p>
</div>
</div>
<div class="section" id="llvm-instrprof-value-profile-intrinsic">
<h4><a class="toc-backref" href="#id1249">&#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-instrprof-value-profile-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id396">
<h5><a class="toc-backref" href="#id1250">Syntax:</a><a class="headerlink" href="#id396" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">instrprof_value_profile</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">hash</span><span class="o">&gt;</span><span class="p">,</span>
                                           <span class="n">i64</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">value_kind</span><span class="o">&gt;</span><span class="p">,</span>
                                           <span class="n">i32</span> <span class="o">&lt;</span><span class="n">index</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id397">
<h5><a class="toc-backref" href="#id1251">Overview:</a><a class="headerlink" href="#id397" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code>&#8216; intrinsic can be emitted by a
frontend for use with instrumentation based profiling. This will be
lowered by the <code class="docutils literal"><span class="pre">-instrprof</span></code> pass to find out the target values,
instrumented expressions take in a program at runtime.</p>
</div>
<div class="section" id="id398">
<h5><a class="toc-backref" href="#id1252">Arguments:</a><a class="headerlink" href="#id398" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a global variable containing the
name of the entity being instrumented. <code class="docutils literal"><span class="pre">name</span></code> should generally be the
(mangled) function name for a set of counters.</p>
<p>The second argument is a hash value that can be used by the consumer
of the profile data to detect changes to the instrumented source. It
is an error if <code class="docutils literal"><span class="pre">hash</span></code> differs between two instances of
<code class="docutils literal"><span class="pre">llvm.instrprof_*</span></code> that refer to the same name.</p>
<p>The third argument is the value of the expression being profiled. The profiled
expression&#8217;s value should be representable as an unsigned 64-bit value. The
fourth argument represents the kind of value profiling that is being done. The
supported value profiling kinds are enumerated through the
<code class="docutils literal"><span class="pre">InstrProfValueKind</span></code> type declared in the
<code class="docutils literal"><span class="pre">&lt;include/llvm/ProfileData/InstrProf.h&gt;</span></code> header file. The last argument is the
index of the instrumented expression within <code class="docutils literal"><span class="pre">name</span></code>. It should be &gt;= 0.</p>
</div>
<div class="section" id="id399">
<h5><a class="toc-backref" href="#id1253">Semantics:</a><a class="headerlink" href="#id399" title="永久链接至标题">¶</a></h5>
<p>This intrinsic represents the point where a call to a runtime routine
should be inserted for value profiling of target expressions. <code class="docutils literal"><span class="pre">-instrprof</span></code>
pass will generate the appropriate data structures and replace the
<code class="docutils literal"><span class="pre">llvm.instrprof_value_profile</span></code> intrinsic with the call to the profile
runtime library with proper arguments.</p>
</div>
</div>
</div>
<div class="section" id="standard-c-library-intrinsics">
<h3><a class="toc-backref" href="#id1254">Standard C Library Intrinsics</a><a class="headerlink" href="#standard-c-library-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for a few important standard C library
functions. These intrinsics allow source-language front-ends to pass
information about the alignment of the pointer arguments to the code
generator, providing opportunity for more efficient code generation.</p>
<div class="section" id="llvm-memcpy-intrinsic">
<span id="int-memcpy"></span><h4><a class="toc-backref" href="#id1255">&#8216;<code class="docutils literal"><span class="pre">llvm.memcpy</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-memcpy-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id400">
<h5><a class="toc-backref" href="#id1256">Syntax:</a><a class="headerlink" href="#id400" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.memcpy</span></code> on any
integer bit width and for different address spaces. Not all targets
support all bit widths however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memcpy</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">i32</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memcpy</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id401">
<h5><a class="toc-backref" href="#id1257">Overview:</a><a class="headerlink" href="#id401" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memcpy.*</span></code>&#8216; intrinsics copy a block of memory from the
source location to the destination location.</p>
<p>Note that, unlike the standard libc function, the <code class="docutils literal"><span class="pre">llvm.memcpy.*</span></code>
intrinsics do not return a value, takes extra alignment/isvolatile
arguments and the pointers can be in specified address spaces.</p>
</div>
<div class="section" id="id402">
<h5><a class="toc-backref" href="#id1258">Arguments:</a><a class="headerlink" href="#id402" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to the destination, the second is a
pointer to the source. The third argument is an integer argument
specifying the number of bytes to copy, the fourth argument is the
alignment of the source and destination locations, and the fifth is a
boolean indicating a volatile access.</p>
<p>If the call to this intrinsic has an alignment value that is not 0 or 1,
then the caller guarantees that both the source and destination pointers
are aligned to that boundary.</p>
<p>If the <code class="docutils literal"><span class="pre">isvolatile</span></code> parameter is <code class="docutils literal"><span class="pre">true</span></code>, the <code class="docutils literal"><span class="pre">llvm.memcpy</span></code> call is
a <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operation</span></a>. The detailed access behavior is not
very cleanly specified and it is unwise to depend on it.</p>
</div>
<div class="section" id="id403">
<h5><a class="toc-backref" href="#id1259">Semantics:</a><a class="headerlink" href="#id403" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memcpy.*</span></code>&#8216; intrinsics copy a block of memory from the
source location to the destination location, which are not allowed to
overlap. It copies &#8220;len&#8221; bytes of memory over. If the argument is known
to be aligned to some boundary, this can be specified as the fourth
argument, otherwise it should be set to 0 or 1 (both meaning no alignment).</p>
</div>
</div>
<div class="section" id="llvm-memmove-intrinsic">
<h4><a class="toc-backref" href="#id1260">&#8216;<code class="docutils literal"><span class="pre">llvm.memmove</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-memmove-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id404">
<h5><a class="toc-backref" href="#id1261">Syntax:</a><a class="headerlink" href="#id404" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use llvm.memmove on any integer
bit width and for different address space. Not all targets support all
bit widths however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memmove</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                         <span class="n">i32</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memmove</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span>
                                         <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id405">
<h5><a class="toc-backref" href="#id1262">Overview:</a><a class="headerlink" href="#id405" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memmove.*</span></code>&#8216; intrinsics move a block of memory from the
source location to the destination location. It is similar to the
&#8216;<code class="docutils literal"><span class="pre">llvm.memcpy</span></code>&#8216; intrinsic but allows the two memory locations to
overlap.</p>
<p>Note that, unlike the standard libc function, the <code class="docutils literal"><span class="pre">llvm.memmove.*</span></code>
intrinsics do not return a value, takes extra alignment/isvolatile
arguments and the pointers can be in specified address spaces.</p>
</div>
<div class="section" id="id406">
<h5><a class="toc-backref" href="#id1263">Arguments:</a><a class="headerlink" href="#id406" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to the destination, the second is a
pointer to the source. The third argument is an integer argument
specifying the number of bytes to copy, the fourth argument is the
alignment of the source and destination locations, and the fifth is a
boolean indicating a volatile access.</p>
<p>If the call to this intrinsic has an alignment value that is not 0 or 1,
then the caller guarantees that the source and destination pointers are
aligned to that boundary.</p>
<p>If the <code class="docutils literal"><span class="pre">isvolatile</span></code> parameter is <code class="docutils literal"><span class="pre">true</span></code>, the <code class="docutils literal"><span class="pre">llvm.memmove</span></code> call
is a <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operation</span></a>. The detailed access behavior is
not very cleanly specified and it is unwise to depend on it.</p>
</div>
<div class="section" id="id407">
<h5><a class="toc-backref" href="#id1264">Semantics:</a><a class="headerlink" href="#id407" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memmove.*</span></code>&#8216; intrinsics copy a block of memory from the
source location to the destination location, which may overlap. It
copies &#8220;len&#8221; bytes of memory over. If the argument is known to be
aligned to some boundary, this can be specified as the fourth argument,
otherwise it should be set to 0 or 1 (both meaning no alignment).</p>
</div>
</div>
<div class="section" id="llvm-memset-intrinsics">
<h4><a class="toc-backref" href="#id1265">&#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-memset-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id408">
<h5><a class="toc-backref" href="#id1266">Syntax:</a><a class="headerlink" href="#id408" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use llvm.memset on any integer
bit width and for different address spaces. However, not all targets
support all bit widths.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memset</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">i32</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">memset</span><span class="o">.</span><span class="n">p0i8</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">dest</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">i64</span> <span class="o">&lt;</span><span class="nb">len</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">isvolatile</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id409">
<h5><a class="toc-backref" href="#id1267">Overview:</a><a class="headerlink" href="#id409" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; intrinsics fill a block of memory with a
particular byte value.</p>
<p>Note that, unlike the standard libc function, the <code class="docutils literal"><span class="pre">llvm.memset</span></code>
intrinsic does not return a value and takes extra alignment/volatile
arguments. Also, the destination can be in an arbitrary address space.</p>
</div>
<div class="section" id="id410">
<h5><a class="toc-backref" href="#id1268">Arguments:</a><a class="headerlink" href="#id410" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to the destination to fill, the second
is the byte value with which to fill it, the third argument is an
integer argument specifying the number of bytes to fill, and the fourth
argument is the known alignment of the destination location.</p>
<p>If the call to this intrinsic has an alignment value that is not 0 or 1,
then the caller guarantees that the destination pointer is aligned to
that boundary.</p>
<p>If the <code class="docutils literal"><span class="pre">isvolatile</span></code> parameter is <code class="docutils literal"><span class="pre">true</span></code>, the <code class="docutils literal"><span class="pre">llvm.memset</span></code> call is
a <a class="reference internal" href="#volatile"><span class="std std-ref">volatile operation</span></a>. The detailed access behavior is not
very cleanly specified and it is unwise to depend on it.</p>
</div>
<div class="section" id="id411">
<h5><a class="toc-backref" href="#id1269">Semantics:</a><a class="headerlink" href="#id411" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.memset.*</span></code>&#8216; intrinsics fill &#8220;len&#8221; bytes of memory starting
at the destination location. If the argument is known to be aligned to
some boundary, this can be specified as the fourth argument, otherwise
it should be set to 0 or 1 (both meaning no alignment).</p>
</div>
</div>
<div class="section" id="llvm-sqrt-intrinsic">
<h4><a class="toc-backref" href="#id1270">&#8216;<code class="docutils literal"><span class="pre">llvm.sqrt.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-sqrt-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id412">
<h5><a class="toc-backref" href="#id1271">Syntax:</a><a class="headerlink" href="#id412" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.sqrt</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sqrt</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id413">
<h5><a class="toc-backref" href="#id1272">Overview:</a><a class="headerlink" href="#id413" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sqrt</span></code>&#8216; intrinsics return the sqrt of the specified operand,
returning the same value as the libm &#8216;<code class="docutils literal"><span class="pre">sqrt</span></code>&#8216; functions would. Unlike
<code class="docutils literal"><span class="pre">sqrt</span></code> in libm, however, <code class="docutils literal"><span class="pre">llvm.sqrt</span></code> has undefined behavior for
negative numbers other than -0.0 (which allows for better optimization,
because there is no need to worry about errno being set).
<code class="docutils literal"><span class="pre">llvm.sqrt(-0.0)</span></code> is defined to return -0.0 like IEEE sqrt.</p>
</div>
<div class="section" id="id414">
<h5><a class="toc-backref" href="#id1273">Arguments:</a><a class="headerlink" href="#id414" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id415">
<h5><a class="toc-backref" href="#id1274">Semantics:</a><a class="headerlink" href="#id415" title="永久链接至标题">¶</a></h5>
<p>This function returns the sqrt of the specified operand if it is a
nonnegative floating point number.</p>
</div>
</div>
<div class="section" id="llvm-powi-intrinsic">
<h4><a class="toc-backref" href="#id1275">&#8216;<code class="docutils literal"><span class="pre">llvm.powi.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-powi-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id416">
<h5><a class="toc-backref" href="#id1276">Syntax:</a><a class="headerlink" href="#id416" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.powi</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">powi</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">power</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id417">
<h5><a class="toc-backref" href="#id1277">Overview:</a><a class="headerlink" href="#id417" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.powi.*</span></code>&#8216; intrinsics return the first operand raised to the
specified (positive or negative) power. The order of evaluation of
multiplications is not defined. When a vector of floating point type is
used, the second argument remains a scalar integer value.</p>
</div>
<div class="section" id="id418">
<h5><a class="toc-backref" href="#id1278">Arguments:</a><a class="headerlink" href="#id418" title="永久链接至标题">¶</a></h5>
<p>The second argument is an integer power, and the first is a value to
raise to that power.</p>
</div>
<div class="section" id="id419">
<h5><a class="toc-backref" href="#id1279">Semantics:</a><a class="headerlink" href="#id419" title="永久链接至标题">¶</a></h5>
<p>This function returns the first value raised to the second power with an
unspecified sequence of rounding operations.</p>
</div>
</div>
<div class="section" id="llvm-sin-intrinsic">
<h4><a class="toc-backref" href="#id1280">&#8216;<code class="docutils literal"><span class="pre">llvm.sin.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-sin-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id420">
<h5><a class="toc-backref" href="#id1281">Syntax:</a><a class="headerlink" href="#id420" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.sin</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sin</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id421">
<h5><a class="toc-backref" href="#id1282">Overview:</a><a class="headerlink" href="#id421" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sin.*</span></code>&#8216; intrinsics return the sine of the operand.</p>
</div>
<div class="section" id="id422">
<h5><a class="toc-backref" href="#id1283">Arguments:</a><a class="headerlink" href="#id422" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id423">
<h5><a class="toc-backref" href="#id1284">Semantics:</a><a class="headerlink" href="#id423" title="永久链接至标题">¶</a></h5>
<p>This function returns the sine of the specified operand, returning the
same values as the libm <code class="docutils literal"><span class="pre">sin</span></code> functions would, and handles error
conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-cos-intrinsic">
<h4><a class="toc-backref" href="#id1285">&#8216;<code class="docutils literal"><span class="pre">llvm.cos.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-cos-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id424">
<h5><a class="toc-backref" href="#id1286">Syntax:</a><a class="headerlink" href="#id424" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.cos</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">cos</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id425">
<h5><a class="toc-backref" href="#id1287">Overview:</a><a class="headerlink" href="#id425" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.cos.*</span></code>&#8216; intrinsics return the cosine of the operand.</p>
</div>
<div class="section" id="id426">
<h5><a class="toc-backref" href="#id1288">Arguments:</a><a class="headerlink" href="#id426" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id427">
<h5><a class="toc-backref" href="#id1289">Semantics:</a><a class="headerlink" href="#id427" title="永久链接至标题">¶</a></h5>
<p>This function returns the cosine of the specified operand, returning the
same values as the libm <code class="docutils literal"><span class="pre">cos</span></code> functions would, and handles error
conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-pow-intrinsic">
<h4><a class="toc-backref" href="#id1290">&#8216;<code class="docutils literal"><span class="pre">llvm.pow.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-pow-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id428">
<h5><a class="toc-backref" href="#id1291">Syntax:</a><a class="headerlink" href="#id428" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.pow</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Power</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">pow</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="n">Power</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id429">
<h5><a class="toc-backref" href="#id1292">Overview:</a><a class="headerlink" href="#id429" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.pow.*</span></code>&#8216; intrinsics return the first operand raised to the
specified (positive or negative) power.</p>
</div>
<div class="section" id="id430">
<h5><a class="toc-backref" href="#id1293">Arguments:</a><a class="headerlink" href="#id430" title="永久链接至标题">¶</a></h5>
<p>The second argument is a floating point power, and the first is a value
to raise to that power.</p>
</div>
<div class="section" id="id431">
<h5><a class="toc-backref" href="#id1294">Semantics:</a><a class="headerlink" href="#id431" title="永久链接至标题">¶</a></h5>
<p>This function returns the first value raised to the second power,
returning the same values as the libm <code class="docutils literal"><span class="pre">pow</span></code> functions would, and
handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-exp-intrinsic">
<h4><a class="toc-backref" href="#id1295">&#8216;<code class="docutils literal"><span class="pre">llvm.exp.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-exp-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id432">
<h5><a class="toc-backref" href="#id1296">Syntax:</a><a class="headerlink" href="#id432" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.exp</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id433">
<h5><a class="toc-backref" href="#id1297">Overview:</a><a class="headerlink" href="#id433" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.exp.*</span></code>&#8216; intrinsics perform the exp function.</p>
</div>
<div class="section" id="id434">
<h5><a class="toc-backref" href="#id1298">Arguments:</a><a class="headerlink" href="#id434" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id435">
<h5><a class="toc-backref" href="#id1299">Semantics:</a><a class="headerlink" href="#id435" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">exp</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-exp2-intrinsic">
<h4><a class="toc-backref" href="#id1300">&#8216;<code class="docutils literal"><span class="pre">llvm.exp2.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-exp2-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id436">
<h5><a class="toc-backref" href="#id1301">Syntax:</a><a class="headerlink" href="#id436" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.exp2</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">exp2</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id437">
<h5><a class="toc-backref" href="#id1302">Overview:</a><a class="headerlink" href="#id437" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.exp2.*</span></code>&#8216; intrinsics perform the exp2 function.</p>
</div>
<div class="section" id="id438">
<h5><a class="toc-backref" href="#id1303">Arguments:</a><a class="headerlink" href="#id438" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id439">
<h5><a class="toc-backref" href="#id1304">Semantics:</a><a class="headerlink" href="#id439" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">exp2</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-log-intrinsic">
<h4><a class="toc-backref" href="#id1305">&#8216;<code class="docutils literal"><span class="pre">llvm.log.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-log-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id440">
<h5><a class="toc-backref" href="#id1306">Syntax:</a><a class="headerlink" href="#id440" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.log</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id441">
<h5><a class="toc-backref" href="#id1307">Overview:</a><a class="headerlink" href="#id441" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.log.*</span></code>&#8216; intrinsics perform the log function.</p>
</div>
<div class="section" id="id442">
<h5><a class="toc-backref" href="#id1308">Arguments:</a><a class="headerlink" href="#id442" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id443">
<h5><a class="toc-backref" href="#id1309">Semantics:</a><a class="headerlink" href="#id443" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">log</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-log10-intrinsic">
<h4><a class="toc-backref" href="#id1310">&#8216;<code class="docutils literal"><span class="pre">llvm.log10.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-log10-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id444">
<h5><a class="toc-backref" href="#id1311">Syntax:</a><a class="headerlink" href="#id444" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.log10</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">log10</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id445">
<h5><a class="toc-backref" href="#id1312">Overview:</a><a class="headerlink" href="#id445" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.log10.*</span></code>&#8216; intrinsics perform the log10 function.</p>
</div>
<div class="section" id="id446">
<h5><a class="toc-backref" href="#id1313">Arguments:</a><a class="headerlink" href="#id446" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id447">
<h5><a class="toc-backref" href="#id1314">Semantics:</a><a class="headerlink" href="#id447" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">log10</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-log2-intrinsic">
<h4><a class="toc-backref" href="#id1315">&#8216;<code class="docutils literal"><span class="pre">llvm.log2.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-log2-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id448">
<h5><a class="toc-backref" href="#id1316">Syntax:</a><a class="headerlink" href="#id448" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.log2</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">log2</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id449">
<h5><a class="toc-backref" href="#id1317">Overview:</a><a class="headerlink" href="#id449" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.log2.*</span></code>&#8216; intrinsics perform the log2 function.</p>
</div>
<div class="section" id="id450">
<h5><a class="toc-backref" href="#id1318">Arguments:</a><a class="headerlink" href="#id450" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id451">
<h5><a class="toc-backref" href="#id1319">Semantics:</a><a class="headerlink" href="#id451" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">log2</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-fma-intrinsic">
<h4><a class="toc-backref" href="#id1320">&#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-fma-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id452">
<h5><a class="toc-backref" href="#id1321">Syntax:</a><a class="headerlink" href="#id452" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.fma</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fma</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id453">
<h5><a class="toc-backref" href="#id1322">Overview:</a><a class="headerlink" href="#id453" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216; intrinsics perform the fused multiply-add
operation.</p>
</div>
<div class="section" id="id454">
<h5><a class="toc-backref" href="#id1323">Arguments:</a><a class="headerlink" href="#id454" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id455">
<h5><a class="toc-backref" href="#id1324">Semantics:</a><a class="headerlink" href="#id455" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">fma</span></code> functions
would, and does not set errno.</p>
</div>
</div>
<div class="section" id="llvm-fabs-intrinsic">
<h4><a class="toc-backref" href="#id1325">&#8216;<code class="docutils literal"><span class="pre">llvm.fabs.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-fabs-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id456">
<h5><a class="toc-backref" href="#id1326">Syntax:</a><a class="headerlink" href="#id456" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.fabs</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fabs</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id457">
<h5><a class="toc-backref" href="#id1327">Overview:</a><a class="headerlink" href="#id457" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fabs.*</span></code>&#8216; intrinsics return the absolute value of the
operand.</p>
</div>
<div class="section" id="id458">
<h5><a class="toc-backref" href="#id1328">Arguments:</a><a class="headerlink" href="#id458" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id459">
<h5><a class="toc-backref" href="#id1329">Semantics:</a><a class="headerlink" href="#id459" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">fabs</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-minnum-intrinsic">
<h4><a class="toc-backref" href="#id1330">&#8216;<code class="docutils literal"><span class="pre">llvm.minnum.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-minnum-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id460">
<h5><a class="toc-backref" href="#id1331">Syntax:</a><a class="headerlink" href="#id460" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.minnum</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">x86_fp80</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">minnum</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">ppc_fp128</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id461">
<h5><a class="toc-backref" href="#id1332">Overview:</a><a class="headerlink" href="#id461" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.minnum.*</span></code>&#8216; intrinsics return the minimum of the two
arguments.</p>
</div>
<div class="section" id="id462">
<h5><a class="toc-backref" href="#id1333">Arguments:</a><a class="headerlink" href="#id462" title="永久链接至标题">¶</a></h5>
<p>The arguments and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id463">
<h5><a class="toc-backref" href="#id1334">Semantics:</a><a class="headerlink" href="#id463" title="永久链接至标题">¶</a></h5>
<p>Follows the IEEE-754 semantics for minNum, which also match for libm&#8217;s
fmin.</p>
<p>If either operand is a NaN, returns the other non-NaN operand. Returns
NaN only if both operands are NaN. If the operands compare equal,
returns a value that compares equal to both operands. This means that
fmin(+/-0.0, +/-0.0) could return either -0.0 or 0.0.</p>
</div>
</div>
<div class="section" id="llvm-maxnum-intrinsic">
<h4><a class="toc-backref" href="#id1335">&#8216;<code class="docutils literal"><span class="pre">llvm.maxnum.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-maxnum-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id464">
<h5><a class="toc-backref" href="#id1336">Syntax:</a><a class="headerlink" href="#id464" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.maxnum</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">Val1l</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">maxnum</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val0</span><span class="p">,</span> <span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id465">
<h5><a class="toc-backref" href="#id1337">Overview:</a><a class="headerlink" href="#id465" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.maxnum.*</span></code>&#8216; intrinsics return the maximum of the two
arguments.</p>
</div>
<div class="section" id="id466">
<h5><a class="toc-backref" href="#id1338">Arguments:</a><a class="headerlink" href="#id466" title="永久链接至标题">¶</a></h5>
<p>The arguments and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id467">
<h5><a class="toc-backref" href="#id1339">Semantics:</a><a class="headerlink" href="#id467" title="永久链接至标题">¶</a></h5>
<p>Follows the IEEE-754 semantics for maxNum, which also match for libm&#8217;s
fmax.</p>
<p>If either operand is a NaN, returns the other non-NaN operand. Returns
NaN only if both operands are NaN. If the operands compare equal,
returns a value that compares equal to both operands. This means that
fmax(+/-0.0, +/-0.0) could return either -0.0 or 0.0.</p>
</div>
</div>
<div class="section" id="llvm-copysign-intrinsic">
<h4><a class="toc-backref" href="#id1340">&#8216;<code class="docutils literal"><span class="pre">llvm.copysign.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-copysign-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id468">
<h5><a class="toc-backref" href="#id1341">Syntax:</a><a class="headerlink" href="#id468" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.copysign</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="nb">float</span>  <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">fp128</span> <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">copysign</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Mag</span><span class="p">,</span> <span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Sgn</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id469">
<h5><a class="toc-backref" href="#id1342">Overview:</a><a class="headerlink" href="#id469" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.copysign.*</span></code>&#8216; intrinsics return a value with the magnitude of the
first operand and the sign of the second operand.</p>
</div>
<div class="section" id="id470">
<h5><a class="toc-backref" href="#id1343">Arguments:</a><a class="headerlink" href="#id470" title="永久链接至标题">¶</a></h5>
<p>The arguments and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id471">
<h5><a class="toc-backref" href="#id1344">Semantics:</a><a class="headerlink" href="#id471" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">copysign</span></code>
functions would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-floor-intrinsic">
<h4><a class="toc-backref" href="#id1345">&#8216;<code class="docutils literal"><span class="pre">llvm.floor.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-floor-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id472">
<h5><a class="toc-backref" href="#id1346">Syntax:</a><a class="headerlink" href="#id472" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.floor</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">floor</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id473">
<h5><a class="toc-backref" href="#id1347">Overview:</a><a class="headerlink" href="#id473" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.floor.*</span></code>&#8216; intrinsics return the floor of the operand.</p>
</div>
<div class="section" id="id474">
<h5><a class="toc-backref" href="#id1348">Arguments:</a><a class="headerlink" href="#id474" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id475">
<h5><a class="toc-backref" href="#id1349">Semantics:</a><a class="headerlink" href="#id475" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">floor</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-ceil-intrinsic">
<h4><a class="toc-backref" href="#id1350">&#8216;<code class="docutils literal"><span class="pre">llvm.ceil.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ceil-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id476">
<h5><a class="toc-backref" href="#id1351">Syntax:</a><a class="headerlink" href="#id476" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.ceil</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ceil</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id477">
<h5><a class="toc-backref" href="#id1352">Overview:</a><a class="headerlink" href="#id477" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ceil.*</span></code>&#8216; intrinsics return the ceiling of the operand.</p>
</div>
<div class="section" id="id478">
<h5><a class="toc-backref" href="#id1353">Arguments:</a><a class="headerlink" href="#id478" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id479">
<h5><a class="toc-backref" href="#id1354">Semantics:</a><a class="headerlink" href="#id479" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">ceil</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-trunc-intrinsic">
<h4><a class="toc-backref" href="#id1355">&#8216;<code class="docutils literal"><span class="pre">llvm.trunc.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-trunc-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id480">
<h5><a class="toc-backref" href="#id1356">Syntax:</a><a class="headerlink" href="#id480" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.trunc</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">trunc</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id481">
<h5><a class="toc-backref" href="#id1357">Overview:</a><a class="headerlink" href="#id481" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.trunc.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer not larger in magnitude than the operand.</p>
</div>
<div class="section" id="id482">
<h5><a class="toc-backref" href="#id1358">Arguments:</a><a class="headerlink" href="#id482" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id483">
<h5><a class="toc-backref" href="#id1359">Semantics:</a><a class="headerlink" href="#id483" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">trunc</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-rint-intrinsic">
<h4><a class="toc-backref" href="#id1360">&#8216;<code class="docutils literal"><span class="pre">llvm.rint.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-rint-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id484">
<h5><a class="toc-backref" href="#id1361">Syntax:</a><a class="headerlink" href="#id484" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.rint</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">rint</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id485">
<h5><a class="toc-backref" href="#id1362">Overview:</a><a class="headerlink" href="#id485" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.rint.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer. It may raise an inexact floating-point exception if the
operand isn&#8217;t an integer.</p>
</div>
<div class="section" id="id486">
<h5><a class="toc-backref" href="#id1363">Arguments:</a><a class="headerlink" href="#id486" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id487">
<h5><a class="toc-backref" href="#id1364">Semantics:</a><a class="headerlink" href="#id487" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">rint</span></code> functions
would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-nearbyint-intrinsic">
<h4><a class="toc-backref" href="#id1365">&#8216;<code class="docutils literal"><span class="pre">llvm.nearbyint.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-nearbyint-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id488">
<h5><a class="toc-backref" href="#id1366">Syntax:</a><a class="headerlink" href="#id488" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.nearbyint</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">nearbyint</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id489">
<h5><a class="toc-backref" href="#id1367">Overview:</a><a class="headerlink" href="#id489" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.nearbyint.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer.</p>
</div>
<div class="section" id="id490">
<h5><a class="toc-backref" href="#id1368">Arguments:</a><a class="headerlink" href="#id490" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id491">
<h5><a class="toc-backref" href="#id1369">Semantics:</a><a class="headerlink" href="#id491" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">nearbyint</span></code>
functions would, and handles error conditions in the same way.</p>
</div>
</div>
<div class="section" id="llvm-round-intrinsic">
<h4><a class="toc-backref" href="#id1370">&#8216;<code class="docutils literal"><span class="pre">llvm.round.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-round-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id492">
<h5><a class="toc-backref" href="#id1371">Syntax:</a><a class="headerlink" href="#id492" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.round</span></code> on any
floating point or vector of floating point type. Not all targets support
all types however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span>    <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">x86_fp80</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f80</span><span class="p">(</span><span class="n">x86_fp80</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">fp128</span>     <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">f128</span><span class="p">(</span><span class="n">fp128</span> <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">ppc_fp128</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">ppcf128</span><span class="p">(</span><span class="n">ppc_fp128</span>  <span class="o">%</span><span class="n">Val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id493">
<h5><a class="toc-backref" href="#id1372">Overview:</a><a class="headerlink" href="#id493" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.round.*</span></code>&#8216; intrinsics returns the operand rounded to the
nearest integer.</p>
</div>
<div class="section" id="id494">
<h5><a class="toc-backref" href="#id1373">Arguments:</a><a class="headerlink" href="#id494" title="永久链接至标题">¶</a></h5>
<p>The argument and return value are floating point numbers of the same
type.</p>
</div>
<div class="section" id="id495">
<h5><a class="toc-backref" href="#id1374">Semantics:</a><a class="headerlink" href="#id495" title="永久链接至标题">¶</a></h5>
<p>This function returns the same values as the libm <code class="docutils literal"><span class="pre">round</span></code>
functions would, and handles error conditions in the same way.</p>
</div>
</div>
</div>
<div class="section" id="bit-manipulation-intrinsics">
<h3><a class="toc-backref" href="#id1375">Bit Manipulation Intrinsics</a><a class="headerlink" href="#bit-manipulation-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for a few important bit manipulation
operations. These allow efficient code generation for some algorithms.</p>
<div class="section" id="llvm-bitreverse-intrinsics">
<h4><a class="toc-backref" href="#id1376">&#8216;<code class="docutils literal"><span class="pre">llvm.bitreverse.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-bitreverse-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id496">
<h5><a class="toc-backref" href="#id1377">Syntax:</a><a class="headerlink" href="#id496" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic function. You can use bitreverse on any
integer type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitreverse</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitreverse</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitreverse</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id497">
<h5><a class="toc-backref" href="#id1378">Overview:</a><a class="headerlink" href="#id497" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.bitreverse</span></code>&#8216; family of intrinsics is used to reverse the
bitpattern of an integer value; for example <code class="docutils literal"><span class="pre">0b1234567</span></code> becomes
<code class="docutils literal"><span class="pre">0b7654321</span></code>.</p>
</div>
<div class="section" id="id498">
<h5><a class="toc-backref" href="#id1379">Semantics:</a><a class="headerlink" href="#id498" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.bitreverse.iN</span></code> intrinsic returns an i16 value that has bit
<code class="docutils literal"><span class="pre">M</span></code> in the input moved to bit <code class="docutils literal"><span class="pre">N-M</span></code> in the output.</p>
</div>
</div>
<div class="section" id="llvm-bswap-intrinsics">
<h4><a class="toc-backref" href="#id1380">&#8216;<code class="docutils literal"><span class="pre">llvm.bswap.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-bswap-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id499">
<h5><a class="toc-backref" href="#id1381">Syntax:</a><a class="headerlink" href="#id499" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic function. You can use bswap on any
integer type that is an even number of bytes (i.e. BitWidth % 16 == 0).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bswap</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bswap</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bswap</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id500">
<h5><a class="toc-backref" href="#id1382">Overview:</a><a class="headerlink" href="#id500" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.bswap</span></code>&#8216; family of intrinsics is used to byte swap integer
values with an even number of bytes (positive multiple of 16 bits).
These are useful for performing operations on data that is not in the
target&#8217;s native byte order.</p>
</div>
<div class="section" id="id501">
<h5><a class="toc-backref" href="#id1383">Semantics:</a><a class="headerlink" href="#id501" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.bswap.i16</span></code> intrinsic returns an i16 value that has the high
and low byte of the input i16 swapped. Similarly, the <code class="docutils literal"><span class="pre">llvm.bswap.i32</span></code>
intrinsic returns an i32 value that has the four bytes of the input i32
swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the
returned i32 will have its bytes in 3, 2, 1, 0 order. The
<code class="docutils literal"><span class="pre">llvm.bswap.i48</span></code>, <code class="docutils literal"><span class="pre">llvm.bswap.i64</span></code> and other intrinsics extend this
concept to additional even-byte lengths (6 bytes, 8 bytes and more,
respectively).</p>
</div>
</div>
<div class="section" id="llvm-ctpop-intrinsic">
<h4><a class="toc-backref" href="#id1384">&#8216;<code class="docutils literal"><span class="pre">llvm.ctpop.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ctpop-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id502">
<h5><a class="toc-backref" href="#id1385">Syntax:</a><a class="headerlink" href="#id502" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use llvm.ctpop on any integer
bit width, or on any vector with integer elements. Not all targets
support all bit widths or vector types, however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i8</span><span class="p">(</span><span class="n">i8</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctpop</span><span class="o">.</span><span class="n">v2i32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id503">
<h5><a class="toc-backref" href="#id1386">Overview:</a><a class="headerlink" href="#id503" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctpop</span></code>&#8216; family of intrinsics counts the number of bits set
in a value.</p>
</div>
<div class="section" id="id504">
<h5><a class="toc-backref" href="#id1387">Arguments:</a><a class="headerlink" href="#id504" title="永久链接至标题">¶</a></h5>
<p>The only argument is the value to be counted. The argument may be of any
integer type, or a vector with integer elements. The return type must
match the argument type.</p>
</div>
<div class="section" id="id505">
<h5><a class="toc-backref" href="#id1388">Semantics:</a><a class="headerlink" href="#id505" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctpop</span></code>&#8216; intrinsic counts the 1&#8217;s in a variable, or within
each element of a vector.</p>
</div>
</div>
<div class="section" id="llvm-ctlz-intrinsic">
<h4><a class="toc-backref" href="#id1389">&#8216;<code class="docutils literal"><span class="pre">llvm.ctlz.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ctlz-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id506">
<h5><a class="toc-backref" href="#id1390">Syntax:</a><a class="headerlink" href="#id506" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.ctlz</span></code> on any
integer bit width, or any vector whose elements are integers. Not all
targets support all bit widths or vector types, however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span>   <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i8</span>  <span class="p">(</span><span class="n">i8</span>   <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i16</span> <span class="p">(</span><span class="n">i16</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i32</span> <span class="p">(</span><span class="n">i32</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i64</span> <span class="p">(</span><span class="n">i64</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declase</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ctlz</span><span class="o">.</span><span class="n">v2i32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id507">
<h5><a class="toc-backref" href="#id1391">Overview:</a><a class="headerlink" href="#id507" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctlz</span></code>&#8216; family of intrinsic functions counts the number of
leading zeros in a variable.</p>
</div>
<div class="section" id="id508">
<h5><a class="toc-backref" href="#id1392">Arguments:</a><a class="headerlink" href="#id508" title="永久链接至标题">¶</a></h5>
<p>The first argument is the value to be counted. This argument may be of
any integer type, or a vector with integer element type. The return
type must match the first argument type.</p>
<p>The second argument must be a constant and is a flag to indicate whether
the intrinsic should ensure that a zero as the first argument produces a
defined result. Historically some architectures did not provide a
defined result for zero values as efficiently, and many algorithms are
now predicated on avoiding zero-value inputs.</p>
</div>
<div class="section" id="id509">
<h5><a class="toc-backref" href="#id1393">Semantics:</a><a class="headerlink" href="#id509" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ctlz</span></code>&#8216; intrinsic counts the leading (most significant)
zeros in a variable, or within each element of the vector. If
<code class="docutils literal"><span class="pre">src</span> <span class="pre">==</span> <span class="pre">0</span></code> then the result is the size in bits of the type of <code class="docutils literal"><span class="pre">src</span></code>
if <code class="docutils literal"><span class="pre">is_zero_undef</span> <span class="pre">==</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">undef</span></code> otherwise. For example,
<code class="docutils literal"><span class="pre">llvm.ctlz(i32</span> <span class="pre">2)</span> <span class="pre">=</span> <span class="pre">30</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-cttz-intrinsic">
<h4><a class="toc-backref" href="#id1394">&#8216;<code class="docutils literal"><span class="pre">llvm.cttz.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-cttz-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id510">
<h5><a class="toc-backref" href="#id1395">Syntax:</a><a class="headerlink" href="#id510" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.cttz</span></code> on any
integer bit width, or any vector of integer elements. Not all targets
support all bit widths or vector types, however.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span>   <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i8</span>  <span class="p">(</span><span class="n">i8</span>   <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i16</span> <span class="p">(</span><span class="n">i16</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i32</span> <span class="p">(</span><span class="n">i32</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i64</span> <span class="p">(</span><span class="n">i64</span>  <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declase</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">cttz</span><span class="o">.</span><span class="n">v2i32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">src</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">is_zero_undef</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id511">
<h5><a class="toc-backref" href="#id1396">Overview:</a><a class="headerlink" href="#id511" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.cttz</span></code>&#8216; family of intrinsic functions counts the number of
trailing zeros.</p>
</div>
<div class="section" id="id512">
<h5><a class="toc-backref" href="#id1397">Arguments:</a><a class="headerlink" href="#id512" title="永久链接至标题">¶</a></h5>
<p>The first argument is the value to be counted. This argument may be of
any integer type, or a vector with integer element type. The return
type must match the first argument type.</p>
<p>The second argument must be a constant and is a flag to indicate whether
the intrinsic should ensure that a zero as the first argument produces a
defined result. Historically some architectures did not provide a
defined result for zero values as efficiently, and many algorithms are
now predicated on avoiding zero-value inputs.</p>
</div>
<div class="section" id="id513">
<h5><a class="toc-backref" href="#id1398">Semantics:</a><a class="headerlink" href="#id513" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.cttz</span></code>&#8216; intrinsic counts the trailing (least significant)
zeros in a variable, or within each element of a vector. If <code class="docutils literal"><span class="pre">src</span> <span class="pre">==</span> <span class="pre">0</span></code>
then the result is the size in bits of the type of <code class="docutils literal"><span class="pre">src</span></code> if
<code class="docutils literal"><span class="pre">is_zero_undef</span> <span class="pre">==</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">undef</span></code> otherwise. For example,
<code class="docutils literal"><span class="pre">llvm.cttz(2)</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="arithmetic-with-overflow-intrinsics">
<span id="int-overflow"></span><h3><a class="toc-backref" href="#id1399">Arithmetic with Overflow Intrinsics</a><a class="headerlink" href="#arithmetic-with-overflow-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for some arithmetic with overflow operations.</p>
<div class="section" id="llvm-sadd-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1400">&#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-sadd-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id514">
<h5><a class="toc-backref" href="#id1401">Syntax:</a><a class="headerlink" href="#id514" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.sadd.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">sadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id515">
<h5><a class="toc-backref" href="#id1402">Overview:</a><a class="headerlink" href="#id515" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed addition of the two arguments, and indicate whether an overflow
occurred during the signed summation.</p>
</div>
<div class="section" id="id516">
<h5><a class="toc-backref" href="#id1403">Arguments:</a><a class="headerlink" href="#id516" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo signed
addition.</p>
</div>
<div class="section" id="id517">
<h5><a class="toc-backref" href="#id1404">Semantics:</a><a class="headerlink" href="#id517" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.sadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed addition of the two variables. They return a structure &#8212; the
first element of which is the signed summation, and the second element
of which is a bit specifying if the signed summation resulted in an
overflow.</p>
</div>
<div class="section" id="id518">
<h5><a class="toc-backref" href="#id1405">Examples:</a><a class="headerlink" href="#id518" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.sadd.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-uadd-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1406">&#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-uadd-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id519">
<h5><a class="toc-backref" href="#id1407">Syntax:</a><a class="headerlink" href="#id519" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">uadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">uadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">uadd</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id520">
<h5><a class="toc-backref" href="#id1408">Overview:</a><a class="headerlink" href="#id520" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned addition of the two arguments, and indicate whether a carry
occurred during the unsigned summation.</p>
</div>
<div class="section" id="id521">
<h5><a class="toc-backref" href="#id1409">Arguments:</a><a class="headerlink" href="#id521" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo unsigned
addition.</p>
</div>
<div class="section" id="id522">
<h5><a class="toc-backref" href="#id1410">Semantics:</a><a class="headerlink" href="#id522" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned addition of the two arguments. They return a structure &#8212; the
first element of which is the sum, and the second element of which is a
bit specifying if the unsigned summation resulted in a carry.</p>
</div>
<div class="section" id="id523">
<h5><a class="toc-backref" href="#id1411">Examples:</a><a class="headerlink" href="#id523" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.uadd.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%carry</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-ssub-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1412">&#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-ssub-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id524">
<h5><a class="toc-backref" href="#id1413">Syntax:</a><a class="headerlink" href="#id524" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.ssub.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ssub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ssub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ssub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id525">
<h5><a class="toc-backref" href="#id1414">Overview:</a><a class="headerlink" href="#id525" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed subtraction of the two arguments, and indicate whether an
overflow occurred during the signed subtraction.</p>
</div>
<div class="section" id="id526">
<h5><a class="toc-backref" href="#id1415">Arguments:</a><a class="headerlink" href="#id526" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo signed
subtraction.</p>
</div>
<div class="section" id="id527">
<h5><a class="toc-backref" href="#id1416">Semantics:</a><a class="headerlink" href="#id527" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ssub.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed subtraction of the two arguments. They return a structure &#8212; the
first element of which is the subtraction, and the second element of
which is a bit specifying if the signed subtraction resulted in an
overflow.</p>
</div>
<div class="section" id="id528">
<h5><a class="toc-backref" href="#id1417">Examples:</a><a class="headerlink" href="#id528" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.ssub.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-usub-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1418">&#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-usub-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id529">
<h5><a class="toc-backref" href="#id1419">Syntax:</a><a class="headerlink" href="#id529" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.usub.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">usub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">usub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">usub</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id530">
<h5><a class="toc-backref" href="#id1420">Overview:</a><a class="headerlink" href="#id530" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned subtraction of the two arguments, and indicate whether an
overflow occurred during the unsigned subtraction.</p>
</div>
<div class="section" id="id531">
<h5><a class="toc-backref" href="#id1421">Arguments:</a><a class="headerlink" href="#id531" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo unsigned
subtraction.</p>
</div>
<div class="section" id="id532">
<h5><a class="toc-backref" href="#id1422">Semantics:</a><a class="headerlink" href="#id532" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.usub.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned subtraction of the two arguments. They return a structure &#8212;
the first element of which is the subtraction, and the second element of
which is a bit specifying if the unsigned subtraction resulted in an
overflow.</p>
</div>
<div class="section" id="id533">
<h5><a class="toc-backref" href="#id1423">Examples:</a><a class="headerlink" href="#id533" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.usub.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-smul-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1424">&#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-smul-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id534">
<h5><a class="toc-backref" href="#id1425">Syntax:</a><a class="headerlink" href="#id534" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.smul.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">smul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">smul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">smul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id535">
<h5><a class="toc-backref" href="#id1426">Overview:</a><a class="headerlink" href="#id535" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed multiplication of the two arguments, and indicate whether an
overflow occurred during the signed multiplication.</p>
</div>
<div class="section" id="id536">
<h5><a class="toc-backref" href="#id1427">Arguments:</a><a class="headerlink" href="#id536" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo signed
multiplication.</p>
</div>
<div class="section" id="id537">
<h5><a class="toc-backref" href="#id1428">Semantics:</a><a class="headerlink" href="#id537" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.smul.with.overflow</span></code>&#8216; family of intrinsic functions perform
a signed multiplication of the two arguments. They return a structure &#8212;
the first element of which is the multiplication, and the second element
of which is a bit specifying if the signed multiplication resulted in an
overflow.</p>
</div>
<div class="section" id="id538">
<h5><a class="toc-backref" href="#id1429">Examples:</a><a class="headerlink" href="#id538" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.smul.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-umul-with-overflow-intrinsics">
<h4><a class="toc-backref" href="#id1430">&#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-umul-with-overflow-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id539">
<h5><a class="toc-backref" href="#id1431">Syntax:</a><a class="headerlink" href="#id539" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.umul.with.overflow</span></code>
on any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">i16</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">umul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i32</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">umul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
<span class="n">declare</span> <span class="p">{</span><span class="n">i64</span><span class="p">,</span> <span class="n">i1</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">umul</span><span class="o">.</span><span class="k">with</span><span class="o">.</span><span class="n">overflow</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i64</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id540">
<h5><a class="toc-backref" href="#id1432">Overview:</a><a class="headerlink" href="#id540" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow</span></code>&#8216; family of intrinsic functions perform
a unsigned multiplication of the two arguments, and indicate whether an
overflow occurred during the unsigned multiplication.</p>
</div>
<div class="section" id="id541">
<h5><a class="toc-backref" href="#id1433">Arguments:</a><a class="headerlink" href="#id541" title="永久链接至标题">¶</a></h5>
<p>The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width. The second element of the result structure must be of type
<code class="docutils literal"><span class="pre">i1</span></code>. <code class="docutils literal"><span class="pre">%a</span></code> and <code class="docutils literal"><span class="pre">%b</span></code> are the two values that will undergo unsigned
multiplication.</p>
</div>
<div class="section" id="id542">
<h5><a class="toc-backref" href="#id1434">Semantics:</a><a class="headerlink" href="#id542" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.umul.with.overflow</span></code>&#8216; family of intrinsic functions perform
an unsigned multiplication of the two arguments. They return a structure &#8212;
the first element of which is the multiplication, and the second
element of which is a bit specifying if the unsigned multiplication
resulted in an overflow.</p>
</div>
<div class="section" id="id543">
<h5><a class="toc-backref" href="#id1435">Examples:</a><a class="headerlink" href="#id543" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="vg">@llvm.umul.with.overflow.i32</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
<span class="nv">%sum</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">0</span>
<span class="nv">%obit</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span><span class="k">i32</span><span class="p">,</span> <span class="k">i1</span><span class="p">}</span> <span class="nv">%res</span><span class="p">,</span> <span class="m">1</span>
<span class="k">br</span> <span class="k">i1</span> <span class="nv">%obit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%overflow</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%normal</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="specialised-arithmetic-intrinsics">
<h3><a class="toc-backref" href="#id1436">Specialised Arithmetic Intrinsics</a><a class="headerlink" href="#specialised-arithmetic-intrinsics" title="永久链接至标题">¶</a></h3>
<div class="section" id="llvm-canonicalize-intrinsic">
<h4><a class="toc-backref" href="#id1437">&#8216;<code class="docutils literal"><span class="pre">llvm.canonicalize.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-canonicalize-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id544">
<h5><a class="toc-backref" href="#id1438">Syntax:</a><a class="headerlink" href="#id544" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">canonicalize</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">canonicalize</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id545">
<h5><a class="toc-backref" href="#id1439">Overview:</a><a class="headerlink" href="#id545" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.canonicalize.*</span></code>&#8216; intrinsic returns the platform specific canonical
encoding of a floating point number. This canonicalization is useful for
implementing certain numeric primitives such as frexp. The canonical encoding is
defined by IEEE-754-2008 to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">2.1</span><span class="o">.</span><span class="mi">8</span> <span class="n">canonical</span> <span class="n">encoding</span><span class="p">:</span> <span class="n">The</span> <span class="n">preferred</span> <span class="n">encoding</span> <span class="n">of</span> <span class="n">a</span> <span class="n">floating</span><span class="o">-</span><span class="n">point</span>
<span class="n">representation</span> <span class="ow">in</span> <span class="n">a</span> <span class="nb">format</span><span class="o">.</span> <span class="n">Applied</span> <span class="n">to</span> <span class="n">declets</span><span class="p">,</span> <span class="n">significands</span> <span class="n">of</span> <span class="n">finite</span>
<span class="n">numbers</span><span class="p">,</span> <span class="n">infinities</span><span class="p">,</span> <span class="ow">and</span> <span class="n">NaNs</span><span class="p">,</span> <span class="n">especially</span> <span class="ow">in</span> <span class="n">decimal</span> <span class="n">formats</span><span class="o">.</span>
</pre></div>
</div>
<p>This operation can also be considered equivalent to the IEEE-754-2008
conversion of a floating-point value to the same format. NaNs are handled
according to section 6.2.</p>
<p>Examples of non-canonical encodings:</p>
<ul class="simple">
<li>x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are
converted to a canonical representation per hardware-specific protocol.</li>
<li>Many normal decimal floating point numbers have non-canonical alternative
encodings.</li>
<li>Some machines, like GPUs or ARMv7 NEON, do not support subnormal values.
These are treated as non-canonical encodings of zero and with be flushed to
a zero of the same sign by this operation.</li>
</ul>
<p>Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with
default exception handling must signal an invalid exception, and produce a
quiet NaN result.</p>
<p>This function should always be implementable as multiplication by 1.0, provided
that the compiler does not constant fold the operation. Likewise, division by
1.0 and <code class="docutils literal"><span class="pre">llvm.minnum(x,</span> <span class="pre">x)</span></code> are possible implementations. Addition with
-0.0 is also sufficient provided that the rounding mode is not -Infinity.</p>
<p><code class="docutils literal"><span class="pre">&#64;llvm.canonicalize</span></code> must preserve the equality relation. That is:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">(&#64;llvm.canonicalize(x)</span> <span class="pre">==</span> <span class="pre">x)</span></code> is equivalent to <code class="docutils literal"><span class="pre">(x</span> <span class="pre">==</span> <span class="pre">x)</span></code></li>
<li><code class="docutils literal"><span class="pre">(&#64;llvm.canonicalize(x)</span> <span class="pre">==</span> <span class="pre">&#64;llvm.canonicalize(y))</span></code> is equivalent to
to <code class="docutils literal"><span class="pre">(x</span> <span class="pre">==</span> <span class="pre">y)</span></code></li>
</ul>
<p>Additionally, the sign of zero must be conserved:
<code class="docutils literal"><span class="pre">&#64;llvm.canonicalize(-0.0)</span> <span class="pre">=</span> <span class="pre">-0.0</span></code> and <code class="docutils literal"><span class="pre">&#64;llvm.canonicalize(+0.0)</span> <span class="pre">=</span> <span class="pre">+0.0</span></code></p>
<p>The payload bits of a NaN must be conserved, with two exceptions.
First, environments which use only a single canonical representation of NaN
must perform said canonicalization. Second, SNaNs must be quieted per the
usual methods.</p>
<p>The canonicalization operation may be optimized away if:</p>
<ul class="simple">
<li>The input is known to be canonical. For example, it was produced by a
floating-point operation that is required by the standard to be canonical.</li>
<li>The result is consumed only by (or fused with) other floating-point
operations. That is, the bits of the floating point value are not examined.</li>
</ul>
</div>
</div>
<div class="section" id="llvm-fmuladd-intrinsic">
<h4><a class="toc-backref" href="#id1440">&#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-fmuladd-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id546">
<h5><a class="toc-backref" href="#id1441">Syntax:</a><a class="headerlink" href="#id546" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fmuladd</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="nb">float</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fmuladd</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id547">
<h5><a class="toc-backref" href="#id1442">Overview:</a><a class="headerlink" href="#id547" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; intrinsic functions represent multiply-add
expressions that can be fused if the code generator determines that (a) the
target instruction set has support for a fused operation, and (b) that the
fused operation is more efficient than the equivalent, separate pair of mul
and add instructions.</p>
</div>
<div class="section" id="id548">
<h5><a class="toc-backref" href="#id1443">Arguments:</a><a class="headerlink" href="#id548" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.fmuladd.*</span></code>&#8216; intrinsics each take three arguments: two
multiplicands, a and b, and an addend c.</p>
</div>
<div class="section" id="id549">
<h5><a class="toc-backref" href="#id1444">Semantics:</a><a class="headerlink" href="#id549" title="永久链接至标题">¶</a></h5>
<p>The expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">call</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">fmuladd</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to the expression a * b + c, except that rounding will
not be performed between the multiplication and addition steps if the
code generator fuses the operations. Fusion is not guaranteed, even if
the target platform supports it. If a fused multiply-add is required the
corresponding llvm.fma.* intrinsic function should be used
instead. This never sets errno, just as &#8216;<code class="docutils literal"><span class="pre">llvm.fma.*</span></code>&#8216;.</p>
</div>
<div class="section" id="id550">
<h5><a class="toc-backref" href="#id1445">Examples:</a><a class="headerlink" href="#id550" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%r2</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">float</span> <span class="vg">@llvm.fmuladd.f32</span><span class="p">(</span><span class="kt">float</span> <span class="nv">%a</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%b</span><span class="p">,</span> <span class="kt">float</span> <span class="nv">%c</span><span class="p">)</span> <span class="c">; yields float:r2 = (a * b) + c</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="half-precision-floating-point-intrinsics">
<h3><a class="toc-backref" href="#id1446">Half Precision Floating Point Intrinsics</a><a class="headerlink" href="#half-precision-floating-point-intrinsics" title="永久链接至标题">¶</a></h3>
<p>For most target platforms, half precision floating point is a
storage-only format. This means that it is a dense encoding (in memory)
but does not support computation in the format.</p>
<p>This means that code must first load the half-precision floating point
value as an i16, then convert it to float with
<a class="reference internal" href="#int-convert-from-fp16"><span class="std std-ref">llvm.convert.from.fp16</span></a>. Computation can
then be performed on the float value (including extending to double
etc). To store the value back to memory, it is first converted to float
if needed, then converted to i16 with
<a class="reference internal" href="#int-convert-to-fp16"><span class="std std-ref">llvm.convert.to.fp16</span></a>, then storing as an
i16 value.</p>
<div class="section" id="llvm-convert-to-fp16-intrinsic">
<span id="int-convert-to-fp16"></span><h4><a class="toc-backref" href="#id1447">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-convert-to-fp16-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id551">
<h5><a class="toc-backref" href="#id1448">Syntax:</a><a class="headerlink" href="#id551" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="nb">float</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">double</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id552">
<h5><a class="toc-backref" href="#id1449">Overview:</a><a class="headerlink" href="#id552" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; intrinsic function performs a conversion from a
conventional floating point type to half precision floating point format.</p>
</div>
<div class="section" id="id553">
<h5><a class="toc-backref" href="#id1450">Arguments:</a><a class="headerlink" href="#id553" title="永久链接至标题">¶</a></h5>
<p>The intrinsic function contains single argument - the value to be
converted.</p>
</div>
<div class="section" id="id554">
<h5><a class="toc-backref" href="#id1451">Semantics:</a><a class="headerlink" href="#id554" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.to.fp16</span></code>&#8216; intrinsic function performs a conversion from a
conventional floating point format to half precision floating point format. The
return value is an <code class="docutils literal"><span class="pre">i16</span></code> which contains the converted number.</p>
</div>
<div class="section" id="id555">
<h5><a class="toc-backref" href="#id1452">Examples:</a><a class="headerlink" href="#id555" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i16</span> <span class="vg">@llvm.convert.to.fp16.f32</span><span class="p">(</span><span class="kt">float</span> <span class="nv">%a</span><span class="p">)</span>
<span class="k">store</span> <span class="k">i16</span> <span class="nv">%res</span><span class="p">,</span> <span class="k">i16</span><span class="p">*</span> <span class="vg">@x</span><span class="p">,</span> <span class="k">align</span> <span class="m">2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-convert-from-fp16-intrinsic">
<span id="int-convert-from-fp16"></span><h4><a class="toc-backref" href="#id1453">&#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-convert-from-fp16-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id556">
<h5><a class="toc-backref" href="#id1454">Syntax:</a><a class="headerlink" href="#id556" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="nb">float</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f32</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">double</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from</span><span class="o">.</span><span class="n">fp16</span><span class="o">.</span><span class="n">f64</span><span class="p">(</span><span class="n">i16</span> <span class="o">%</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id557">
<h5><a class="toc-backref" href="#id1455">Overview:</a><a class="headerlink" href="#id557" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; intrinsic function performs a
conversion from half precision floating point format to single precision
floating point format.</p>
</div>
<div class="section" id="id558">
<h5><a class="toc-backref" href="#id1456">Arguments:</a><a class="headerlink" href="#id558" title="永久链接至标题">¶</a></h5>
<p>The intrinsic function contains single argument - the value to be
converted.</p>
</div>
<div class="section" id="id559">
<h5><a class="toc-backref" href="#id1457">Semantics:</a><a class="headerlink" href="#id559" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.convert.from.fp16</span></code>&#8216; intrinsic function performs a
conversion from half single precision floating point format to single
precision floating point format. The input half-float value is
represented by an <code class="docutils literal"><span class="pre">i16</span></code> value.</p>
</div>
<div class="section" id="id560">
<h5><a class="toc-backref" href="#id1458">Examples:</a><a class="headerlink" href="#id560" title="永久链接至标题">¶</a></h5>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%a</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i16</span><span class="p">,</span> <span class="k">i16</span><span class="p">*</span> <span class="vg">@x</span><span class="p">,</span> <span class="k">align</span> <span class="m">2</span>
<span class="nv">%res</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">float</span> <span class="vg">@llvm.convert.from.fp16</span><span class="p">(</span><span class="k">i16</span> <span class="nv">%a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="debugger-intrinsics">
<span id="dbg-intrinsics"></span><h3><a class="toc-backref" href="#id1459">Debugger Intrinsics</a><a class="headerlink" href="#debugger-intrinsics" title="永久链接至标题">¶</a></h3>
<p>The LLVM debugger intrinsics (which all start with <code class="docutils literal"><span class="pre">llvm.dbg.</span></code>
prefix), are described in the <a class="reference external" href="SourceLevelDebugging.html#format_common_intrinsics">LLVM Source Level
Debugging</a>
document.</p>
</div>
<div class="section" id="exception-handling-intrinsics">
<h3><a class="toc-backref" href="#id1460">Exception Handling Intrinsics</a><a class="headerlink" href="#exception-handling-intrinsics" title="永久链接至标题">¶</a></h3>
<p>The LLVM exception handling intrinsics (which all start with
<code class="docutils literal"><span class="pre">llvm.eh.</span></code> prefix), are described in the <a class="reference external" href="ExceptionHandling.html#format_common_intrinsics">LLVM Exception
Handling</a> document.</p>
</div>
<div class="section" id="trampoline-intrinsics">
<span id="int-trampoline"></span><h3><a class="toc-backref" href="#id1461">Trampoline Intrinsics</a><a class="headerlink" href="#trampoline-intrinsics" title="永久链接至标题">¶</a></h3>
<p>These intrinsics make it possible to excise one parameter, marked with
the <a class="reference internal" href="#nest"><span class="std std-ref">nest</span></a> attribute, from a function. The result is a
callable function pointer lacking the nest parameter - the caller does
not need to provide a value for it. Instead, the value to use is stored
in advance in a &#8220;trampoline&#8221;, a block of memory usually allocated on the
stack, which also contains code to splice the nest value into the
argument list. This is used to implement the GCC nested function address
extension.</p>
<p>For example, if the function is <code class="docutils literal"><span class="pre">i32</span> <span class="pre">f(i8*</span> <span class="pre">nest</span> <span class="pre">%c,</span> <span class="pre">i32</span> <span class="pre">%x,</span> <span class="pre">i32</span> <span class="pre">%y)</span></code>
then the resulting function pointer has signature <code class="docutils literal"><span class="pre">i32</span> <span class="pre">(i32,</span> <span class="pre">i32)*</span></code>.
It can be created as follows:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%tramp</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="k">align</span> <span class="m">4</span> <span class="c">; size and alignment only correct for X86</span>
<span class="nv">%tramp1</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">10</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="nv">%tramp</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span>
<span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.init.trampoline</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%tramp1</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">bitcast</span> <span class="p">(</span><span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">)*</span> <span class="vg">@f</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*),</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%nval</span><span class="p">)</span>
<span class="nv">%p</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.adjust.trampoline</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%tramp1</span><span class="p">)</span>
<span class="nv">%fp</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%p</span> <span class="k">to</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">)*</span>
</pre></div>
</div>
<p>The call <code class="docutils literal"><span class="pre">%val</span> <span class="pre">=</span> <span class="pre">call</span> <span class="pre">i32</span> <span class="pre">%fp(i32</span> <span class="pre">%x,</span> <span class="pre">i32</span> <span class="pre">%y)</span></code> is then equivalent to
<code class="docutils literal"><span class="pre">%val</span> <span class="pre">=</span> <span class="pre">call</span> <span class="pre">i32</span> <span class="pre">%f(i8*</span> <span class="pre">%nval,</span> <span class="pre">i32</span> <span class="pre">%x,</span> <span class="pre">i32</span> <span class="pre">%y)</span></code>.</p>
<div class="section" id="llvm-init-trampoline-intrinsic">
<span id="int-it"></span><h4><a class="toc-backref" href="#id1462">&#8216;<code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-init-trampoline-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id561">
<h5><a class="toc-backref" href="#id1463">Syntax:</a><a class="headerlink" href="#id561" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">trampoline</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">tramp</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">func</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">nval</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id562">
<h5><a class="toc-backref" href="#id1464">Overview:</a><a class="headerlink" href="#id562" title="永久链接至标题">¶</a></h5>
<p>This fills the memory pointed to by <code class="docutils literal"><span class="pre">tramp</span></code> with executable code,
turning it into a trampoline.</p>
</div>
<div class="section" id="id563">
<h5><a class="toc-backref" href="#id1465">Arguments:</a><a class="headerlink" href="#id563" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code> intrinsic takes three arguments, all
pointers. The <code class="docutils literal"><span class="pre">tramp</span></code> argument must point to a sufficiently large and
sufficiently aligned block of memory; this memory is written to by the
intrinsic. Note that the size and the alignment are target-specific -
LLVM currently provides no portable way of determining them, so a
front-end that generates this intrinsic needs to have some
target-specific knowledge. The <code class="docutils literal"><span class="pre">func</span></code> argument must hold a function
bitcast to an <code class="docutils literal"><span class="pre">i8*</span></code>.</p>
</div>
<div class="section" id="id564">
<h5><a class="toc-backref" href="#id1466">Semantics:</a><a class="headerlink" href="#id564" title="永久链接至标题">¶</a></h5>
<p>The block of memory pointed to by <code class="docutils literal"><span class="pre">tramp</span></code> is filled with target
dependent code, turning it into a function. Then <code class="docutils literal"><span class="pre">tramp</span></code> needs to be
passed to <a class="reference internal" href="#int-at"><span class="std std-ref">llvm.adjust.trampoline</span></a> to get a pointer which can
be <a class="reference internal" href="#int-trampoline"><span class="std std-ref">bitcast (to a new function) and called</span></a>. The new
function&#8217;s signature is the same as that of <code class="docutils literal"><span class="pre">func</span></code> with any arguments
marked with the <code class="docutils literal"><span class="pre">nest</span></code> attribute removed. At most one such <code class="docutils literal"><span class="pre">nest</span></code>
argument is allowed, and it must be of pointer type. Calling the new
function is equivalent to calling <code class="docutils literal"><span class="pre">func</span></code> with the same argument list,
but with <code class="docutils literal"><span class="pre">nval</span></code> used for the missing <code class="docutils literal"><span class="pre">nest</span></code> argument. If, after
calling <code class="docutils literal"><span class="pre">llvm.init.trampoline</span></code>, the memory pointed to by <code class="docutils literal"><span class="pre">tramp</span></code> is
modified, then the effect of any later call to the returned function
pointer is undefined.</p>
</div>
</div>
<div class="section" id="llvm-adjust-trampoline-intrinsic">
<span id="int-at"></span><h4><a class="toc-backref" href="#id1467">&#8216;<code class="docutils literal"><span class="pre">llvm.adjust.trampoline</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-adjust-trampoline-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id565">
<h5><a class="toc-backref" href="#id1468">Syntax:</a><a class="headerlink" href="#id565" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">adjust</span><span class="o">.</span><span class="n">trampoline</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">tramp</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id566">
<h5><a class="toc-backref" href="#id1469">Overview:</a><a class="headerlink" href="#id566" title="永久链接至标题">¶</a></h5>
<p>This performs any required machine-specific adjustment to the address of
a trampoline (passed as <code class="docutils literal"><span class="pre">tramp</span></code>).</p>
</div>
<div class="section" id="id567">
<h5><a class="toc-backref" href="#id1470">Arguments:</a><a class="headerlink" href="#id567" title="永久链接至标题">¶</a></h5>
<p><code class="docutils literal"><span class="pre">tramp</span></code> must point to a block of memory which already has trampoline
code filled in by a previous call to
<a class="reference internal" href="#int-it"><span class="std std-ref">llvm.init.trampoline</span></a>.</p>
</div>
<div class="section" id="id568">
<h5><a class="toc-backref" href="#id1471">Semantics:</a><a class="headerlink" href="#id568" title="永久链接至标题">¶</a></h5>
<p>On some architectures the address of the code to be executed needs to be
different than the address where the trampoline is actually stored. This
intrinsic returns the executable address corresponding to <code class="docutils literal"><span class="pre">tramp</span></code>
after performing the required machine specific adjustments. The pointer
returned can then be <a class="reference internal" href="#int-trampoline"><span class="std std-ref">bitcast and executed</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="masked-vector-load-and-store-intrinsics">
<span id="int-mload-mstore"></span><h3><a class="toc-backref" href="#id1472">Masked Vector Load and Store Intrinsics</a><a class="headerlink" href="#masked-vector-load-and-store-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for predicated vector load and store operations. The predicate is specified by a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the &#8220;off&#8221; lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed.</p>
<div class="section" id="llvm-masked-load-intrinsics">
<span id="int-mload"></span><h4><a class="toc-backref" href="#id1473">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.load.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-load-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id569">
<h5><a class="toc-backref" href="#id1474">Syntax:</a><a class="headerlink" href="#id569" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The loaded data is a vector of any integer, floating point or pointer data type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v16f32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v2f64</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">double</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v8p0f64</span>    <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">function</span> <span class="n">pointers</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v8p0f_i32f</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id570">
<h5><a class="toc-backref" href="#id1475">Overview:</a><a class="headerlink" href="#id570" title="永久链接至标题">¶</a></h5>
<p>Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand.</p>
</div>
<div class="section" id="id571">
<h5><a class="toc-backref" href="#id1476">Arguments:</a><a class="headerlink" href="#id571" title="永久链接至标题">¶</a></h5>
<p>The first operand is the base pointer for the load. The second operand is the alignment of the source location. It must be a constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the base pointer and the type of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand are the same vector types.</p>
</div>
<div class="section" id="id572">
<h5><a class="toc-backref" href="#id1477">Semantics:</a><a class="headerlink" href="#id572" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.load</span></code>&#8216; intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar load operations.
The result of this operation is equivalent to a regular vector load instruction followed by a &#8216;select&#8217; between the loaded and the passthru values, predicated on the same mask. However, using this intrinsic prevents exceptions on memory access to masked-off lanes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">call</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">v16f32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">passthru</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">The</span> <span class="n">result</span> <span class="n">of</span> <span class="n">the</span> <span class="n">two</span> <span class="n">following</span> <span class="n">instructions</span> <span class="ow">is</span> <span class="n">identical</span> <span class="n">aside</span> <span class="kn">from</span> <span class="nn">potential</span> <span class="n">memory</span> <span class="n">access</span> <span class="n">exception</span>
<span class="o">%</span><span class="n">loadlal</span> <span class="o">=</span> <span class="n">load</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">select</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">loadlal</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">passthru</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-masked-store-intrinsics">
<span id="int-mstore"></span><h4><a class="toc-backref" href="#id1478">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.store.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-store-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id573">
<h5><a class="toc-backref" href="#id1479">Syntax:</a><a class="headerlink" href="#id573" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating point or pointer data type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v8i32</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span>  <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span>   <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span>  <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;*</span>   <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">8</span>  <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v16f32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">double</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v8p0f64</span>    <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">;;</span> <span class="n">The</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">function</span> <span class="n">pointers</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v4p0f_i32f</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i32</span> <span class="p">()</span><span class="o">*&gt;*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id574">
<h5><a class="toc-backref" href="#id1480">Overview:</a><a class="headerlink" href="#id574" title="永久链接至标题">¶</a></h5>
<p>Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes.</p>
</div>
<div class="section" id="id575">
<h5><a class="toc-backref" href="#id1481">Arguments:</a><a class="headerlink" href="#id575" title="永久链接至标题">¶</a></h5>
<p>The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements.</p>
</div>
<div class="section" id="id576">
<h5><a class="toc-backref" href="#id1482">Semantics:</a><a class="headerlink" href="#id576" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.store</span></code>&#8216; intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.
The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">call</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">v16f32</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">mask</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">The</span> <span class="n">result</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">instructions</span> <span class="ow">is</span> <span class="n">identical</span> <span class="n">aside</span> <span class="kn">from</span> <span class="nn">potential</span> <span class="n">data</span> <span class="n">races</span> <span class="ow">and</span> <span class="n">memory</span> <span class="n">access</span> <span class="n">exceptions</span>
<span class="o">%</span><span class="n">oldval</span> <span class="o">=</span> <span class="n">load</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">select</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">oldval</span>
<span class="n">store</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">res</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="masked-vector-gather-and-scatter-intrinsics">
<h3><a class="toc-backref" href="#id1483">Masked Vector Gather and Scatter Intrinsics</a><a class="headerlink" href="#masked-vector-gather-and-scatter-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides intrinsics for vector gather and scatter operations. They are similar to <a class="reference internal" href="#int-mload-mstore"><span class="std std-ref">Masked Vector Load and Store</span></a>, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the &#8220;off&#8221; lanes are not accessed. When all bits are off, no memory is accessed.</p>
<div class="section" id="llvm-masked-gather-intrinsics">
<span id="int-mgather"></span><h4><a class="toc-backref" href="#id1484">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.gather.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-gather-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id577">
<h5><a class="toc-backref" href="#id1485">Syntax:</a><a class="headerlink" href="#id577" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating point or pointer data type gathered together into one vector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v16f32</span>   <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v2f64</span>    <span class="p">(</span><span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v8p0f32</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="nb">float</span><span class="o">**&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">passthru</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id578">
<h5><a class="toc-backref" href="#id1486">Overview:</a><a class="headerlink" href="#id578" title="永久链接至标题">¶</a></h5>
<p>Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers &#8216;<code class="docutils literal"><span class="pre">ptrs</span></code>&#8216;. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand.</p>
</div>
<div class="section" id="id579">
<h5><a class="toc-backref" href="#id1487">Arguments:</a><a class="headerlink" href="#id579" title="永久链接至标题">¶</a></h5>
<p>The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be a constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the &#8216;<code class="docutils literal"><span class="pre">passthru</span></code>&#8216; operand are the same vector types.</p>
</div>
<div class="section" id="id580">
<h5><a class="toc-backref" href="#id1488">Semantics:</a><a class="headerlink" href="#id580" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.gather</span></code>&#8216; intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations.
The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">res</span> <span class="o">=</span> <span class="n">call</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">gather</span><span class="o">.</span><span class="n">v4f64</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;%</span><span class="n">mask</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="o">&gt;</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">The</span> <span class="n">gather</span> <span class="k">with</span> <span class="nb">all</span><span class="o">-</span><span class="n">true</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">following</span> <span class="n">instruction</span> <span class="n">sequence</span>
<span class="o">%</span><span class="n">ptr0</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">%</span><span class="n">ptr2</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">2</span>
<span class="o">%</span><span class="n">ptr3</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">3</span>

<span class="o">%</span><span class="n">val0</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr0</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="o">%</span><span class="n">val1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr1</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="o">%</span><span class="n">val2</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr2</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="o">%</span><span class="n">val3</span> <span class="o">=</span> <span class="n">load</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr3</span><span class="p">,</span> <span class="n">align</span> <span class="mi">8</span>

<span class="o">%</span><span class="n">vec0</span>    <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;</span><span class="n">undef</span><span class="p">,</span> <span class="o">%</span><span class="n">val0</span><span class="p">,</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">vec01</span>   <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;%</span><span class="n">vec0</span><span class="p">,</span> <span class="o">%</span><span class="n">val1</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">%</span><span class="n">vec012</span>  <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;%</span><span class="n">vec01</span><span class="p">,</span> <span class="o">%</span><span class="n">val2</span><span class="p">,</span> <span class="mi">2</span>
<span class="o">%</span><span class="n">vec0123</span> <span class="o">=</span> <span class="n">insertelement</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">&gt;%</span><span class="n">vec012</span><span class="p">,</span> <span class="o">%</span><span class="n">val3</span><span class="p">,</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="llvm-masked-scatter-intrinsics">
<span id="int-mscatter"></span><h4><a class="toc-backref" href="#id1489">&#8216;<code class="docutils literal"><span class="pre">llvm.masked.scatter.*</span></code>&#8216; Intrinsics</a><a class="headerlink" href="#llvm-masked-scatter-intrinsics" title="永久链接至标题">¶</a></h4>
<div class="section" id="id581">
<h5><a class="toc-backref" href="#id1490">Syntax:</a><a class="headerlink" href="#id581" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v8i32</span>   <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span>     <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span>     <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v16f32</span>  <span class="p">(</span><span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="nb">float</span><span class="o">*&gt;</span>  <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">16</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v4p0f64</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">double</span><span class="o">**&gt;</span> <span class="o">&lt;</span><span class="n">ptrs</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">4</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id582">
<h5><a class="toc-backref" href="#id1491">Overview:</a><a class="headerlink" href="#id582" title="永久链接至标题">¶</a></h5>
<p>Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes.</p>
</div>
<div class="section" id="id583">
<h5><a class="toc-backref" href="#id1492">Arguments:</a><a class="headerlink" href="#id583" title="永久链接至标题">¶</a></h5>
<p>The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements.</p>
</div>
<div class="section" id="id584">
<h5><a class="toc-backref" href="#id1493">Semantics:</a><a class="headerlink" href="#id584" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.masked.scatter</span></code>&#8216; intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;;</span> <span class="n">This</span> <span class="n">instruction</span> <span class="n">unconditionaly</span> <span class="n">stores</span> <span class="n">data</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">multiple</span> <span class="n">addresses</span>
<span class="n">call</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">scatter</span><span class="o">.</span><span class="n">v8i32</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span>  <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i1</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="o">..</span> <span class="n">true</span><span class="o">&gt;</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">scalar</span> <span class="n">stores</span>
<span class="o">%</span><span class="n">val0</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">val1</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">..</span>
<span class="o">%</span><span class="n">val7</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">&gt;</span> <span class="o">%</span><span class="n">value</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">7</span>
<span class="o">%</span><span class="n">ptr0</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
<span class="o">%</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">..</span>
<span class="o">%</span><span class="n">ptr7</span> <span class="o">=</span> <span class="n">extractelement</span> <span class="o">&lt;</span><span class="mi">8</span> <span class="n">x</span> <span class="n">i32</span><span class="o">*&gt;</span> <span class="o">%</span><span class="n">ptrs</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">7</span>
<span class="p">;;</span> <span class="n">Note</span><span class="p">:</span> <span class="n">the</span> <span class="n">order</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">stores</span> <span class="ow">is</span> <span class="n">important</span> <span class="n">when</span> <span class="n">they</span> <span class="n">overlap</span><span class="p">:</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">val0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr0</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">val1</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr1</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
<span class="o">..</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">val7</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr7</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="memory-use-markers">
<h3><a class="toc-backref" href="#id1494">Memory Use Markers</a><a class="headerlink" href="#memory-use-markers" title="永久链接至标题">¶</a></h3>
<p>This class of intrinsics provides information about the lifetime of
memory objects and ranges where variables are immutable.</p>
<div class="section" id="llvm-lifetime-start-intrinsic">
<span id="int-lifestart"></span><h4><a class="toc-backref" href="#id1495">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.start</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-lifetime-start-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id585">
<h5><a class="toc-backref" href="#id1496">Syntax:</a><a class="headerlink" href="#id585" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">lifetime</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id586">
<h5><a class="toc-backref" href="#id1497">Overview:</a><a class="headerlink" href="#id586" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.start</span></code>&#8216; intrinsic specifies the start of a memory
object&#8217;s lifetime.</p>
</div>
<div class="section" id="id587">
<h5><a class="toc-backref" href="#id1498">Arguments:</a><a class="headerlink" href="#id587" title="永久链接至标题">¶</a></h5>
<p>The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized. The second argument is a pointer
to the object.</p>
</div>
<div class="section" id="id588">
<h5><a class="toc-backref" href="#id1499">Semantics:</a><a class="headerlink" href="#id588" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that before this point in the code, the value
of the memory pointed to by <code class="docutils literal"><span class="pre">ptr</span></code> is dead. This means that it is known
to never be used and has an undefined value. A load from the pointer
that precedes this intrinsic can be replaced with <code class="docutils literal"><span class="pre">'undef'</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-lifetime-end-intrinsic">
<span id="int-lifeend"></span><h4><a class="toc-backref" href="#id1500">&#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.end</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-lifetime-end-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id589">
<h5><a class="toc-backref" href="#id1501">Syntax:</a><a class="headerlink" href="#id589" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">lifetime</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id590">
<h5><a class="toc-backref" href="#id1502">Overview:</a><a class="headerlink" href="#id590" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.lifetime.end</span></code>&#8216; intrinsic specifies the end of a memory
object&#8217;s lifetime.</p>
</div>
<div class="section" id="id591">
<h5><a class="toc-backref" href="#id1503">Arguments:</a><a class="headerlink" href="#id591" title="永久链接至标题">¶</a></h5>
<p>The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized. The second argument is a pointer
to the object.</p>
</div>
<div class="section" id="id592">
<h5><a class="toc-backref" href="#id1504">Semantics:</a><a class="headerlink" href="#id592" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that after this point in the code, the value of
the memory pointed to by <code class="docutils literal"><span class="pre">ptr</span></code> is dead. This means that it is known to
never be used and has an undefined value. Any stores into the memory
object following this intrinsic may be removed as dead.</p>
</div>
</div>
<div class="section" id="llvm-invariant-start-intrinsic">
<h4><a class="toc-backref" href="#id1505">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.start</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-invariant-start-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id593">
<h5><a class="toc-backref" href="#id1506">Syntax:</a><a class="headerlink" href="#id593" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{}</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">invariant</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id594">
<h5><a class="toc-backref" href="#id1507">Overview:</a><a class="headerlink" href="#id594" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.invariant.start</span></code>&#8216; intrinsic specifies that the contents of
a memory object will not change.</p>
</div>
<div class="section" id="id595">
<h5><a class="toc-backref" href="#id1508">Arguments:</a><a class="headerlink" href="#id595" title="永久链接至标题">¶</a></h5>
<p>The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized. The second argument is a pointer
to the object.</p>
</div>
<div class="section" id="id596">
<h5><a class="toc-backref" href="#id1509">Semantics:</a><a class="headerlink" href="#id596" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that until an <code class="docutils literal"><span class="pre">llvm.invariant.end</span></code> that uses
the return value, the referenced memory location is constant and
unchanging.</p>
</div>
</div>
<div class="section" id="llvm-invariant-end-intrinsic">
<h4><a class="toc-backref" href="#id1510">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.end</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-invariant-end-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id597">
<h5><a class="toc-backref" href="#id1511">Syntax:</a><a class="headerlink" href="#id597" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">invariant</span><span class="o">.</span><span class="n">end</span><span class="p">({}</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">start</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">nocapture</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id598">
<h5><a class="toc-backref" href="#id1512">Overview:</a><a class="headerlink" href="#id598" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.invariant.end</span></code>&#8216; intrinsic specifies that the contents of a
memory object are mutable.</p>
</div>
<div class="section" id="id599">
<h5><a class="toc-backref" href="#id1513">Arguments:</a><a class="headerlink" href="#id599" title="永久链接至标题">¶</a></h5>
<p>The first argument is the matching <code class="docutils literal"><span class="pre">llvm.invariant.start</span></code> intrinsic.
The second argument is a constant integer representing the size of the
object, or -1 if it is variable sized and the third argument is a
pointer to the object.</p>
</div>
<div class="section" id="id600">
<h5><a class="toc-backref" href="#id1514">Semantics:</a><a class="headerlink" href="#id600" title="永久链接至标题">¶</a></h5>
<p>This intrinsic indicates that the memory is mutable again.</p>
</div>
</div>
<div class="section" id="llvm-invariant-group-barrier-intrinsic">
<h4><a class="toc-backref" href="#id1515">&#8216;<code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-invariant-group-barrier-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id601">
<h5><a class="toc-backref" href="#id1516">Syntax:</a><a class="headerlink" href="#id601" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">invariant</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">barrier</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id602">
<h5><a class="toc-backref" href="#id1517">Overview:</a><a class="headerlink" href="#id602" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code>&#8216; intrinsic can be used when an invariant
established by invariant.group metadata no longer holds, to obtain a new pointer
value that does not carry the invariant information.</p>
</div>
<div class="section" id="id603">
<h5><a class="toc-backref" href="#id1518">Arguments:</a><a class="headerlink" href="#id603" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.invariant.group.barrier</span></code> takes only one argument, which is
the pointer to the memory for which the <code class="docutils literal"><span class="pre">invariant.group</span></code> no longer holds.</p>
</div>
<div class="section" id="id604">
<h5><a class="toc-backref" href="#id1519">Semantics:</a><a class="headerlink" href="#id604" title="永久链接至标题">¶</a></h5>
<p>Returns another pointer that aliases its argument but which is considered different
for the purposes of <code class="docutils literal"><span class="pre">load</span></code>/<code class="docutils literal"><span class="pre">store</span></code> <code class="docutils literal"><span class="pre">invariant.group</span></code> metadata.</p>
</div>
</div>
</div>
<div class="section" id="general-intrinsics">
<h3><a class="toc-backref" href="#id1520">General Intrinsics</a><a class="headerlink" href="#general-intrinsics" title="永久链接至标题">¶</a></h3>
<p>This class of intrinsics is designed to be generic and has no specific
purpose.</p>
<div class="section" id="llvm-var-annotation-intrinsic">
<h4><a class="toc-backref" href="#id1521">&#8216;<code class="docutils literal"><span class="pre">llvm.var.annotation</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-var-annotation-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id605">
<h5><a class="toc-backref" href="#id1522">Syntax:</a><a class="headerlink" href="#id605" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">annotation</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id606">
<h5><a class="toc-backref" href="#id1523">Overview:</a><a class="headerlink" href="#id606" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.var.annotation</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id607">
<h5><a class="toc-backref" href="#id1524">Arguments:</a><a class="headerlink" href="#id607" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to a value, the second is a pointer to a
global string, the third is a pointer to a global string which is the
source file name, and the last argument is the line number.</p>
</div>
<div class="section" id="id608">
<h5><a class="toc-backref" href="#id1525">Semantics:</a><a class="headerlink" href="#id608" title="永久链接至标题">¶</a></h5>
<p>This intrinsic allows annotation of local variables with arbitrary
strings. This can be useful for special purpose optimizations that want
to look for these annotations. These have no other defined use; they are
ignored by code generation and optimization.</p>
</div>
</div>
<div class="section" id="llvm-ptr-annotation-intrinsic">
<h4><a class="toc-backref" href="#id1526">&#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-ptr-annotation-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id609">
<h5><a class="toc-backref" href="#id1527">Syntax:</a><a class="headerlink" href="#id609" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use &#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation</span></code>&#8216; on a
pointer to an integer of any width. <em>NOTE</em> you must specify an address space for
the pointer. The identifier for the default address space is the integer
&#8216;<code class="docutils literal"><span class="pre">0</span></code>&#8216;.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span>   <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i8</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span><span class="o">*</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span><span class="o">*</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span><span class="o">*</span>  <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">p</span><span class="o">&lt;</span><span class="n">address</span> <span class="n">space</span><span class="o">&gt;</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id610">
<h5><a class="toc-backref" href="#id1528">Overview:</a><a class="headerlink" href="#id610" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.ptr.annotation</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id611">
<h5><a class="toc-backref" href="#id1529">Arguments:</a><a class="headerlink" href="#id611" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to an integer value of arbitrary bitwidth
(result of some expression), the second is a pointer to a global string, the
third is a pointer to a global string which is the source file name, and the
last argument is the line number. It returns the value of the first argument.</p>
</div>
<div class="section" id="id612">
<h5><a class="toc-backref" href="#id1530">Semantics:</a><a class="headerlink" href="#id612" title="永久链接至标题">¶</a></h5>
<p>This intrinsic allows annotation of a pointer to an integer with arbitrary
strings. This can be useful for special purpose optimizations that want to look
for these annotations. These have no other defined use; they are ignored by code
generation and optimization.</p>
</div>
</div>
<div class="section" id="llvm-annotation-intrinsic">
<h4><a class="toc-backref" href="#id1531">&#8216;<code class="docutils literal"><span class="pre">llvm.annotation.*</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-annotation-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id613">
<h5><a class="toc-backref" href="#id1532">Syntax:</a><a class="headerlink" href="#id613" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use &#8216;<code class="docutils literal"><span class="pre">llvm.annotation</span></code>&#8216; on
any integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i8</span><span class="p">(</span><span class="n">i8</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i16</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i16</span><span class="p">(</span><span class="n">i16</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i256</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">annotation</span><span class="o">.</span><span class="n">i256</span><span class="p">(</span><span class="n">i256</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span>  <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id614">
<h5><a class="toc-backref" href="#id1533">Overview:</a><a class="headerlink" href="#id614" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.annotation</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id615">
<h5><a class="toc-backref" href="#id1534">Arguments:</a><a class="headerlink" href="#id615" title="永久链接至标题">¶</a></h5>
<p>The first argument is an integer value (result of some expression), the
second is a pointer to a global string, the third is a pointer to a
global string which is the source file name, and the last argument is
the line number. It returns the value of the first argument.</p>
</div>
<div class="section" id="id616">
<h5><a class="toc-backref" href="#id1535">Semantics:</a><a class="headerlink" href="#id616" title="永久链接至标题">¶</a></h5>
<p>This intrinsic allows annotations to be put on arbitrary expressions
with arbitrary strings. This can be useful for special purpose
optimizations that want to look for these annotations. These have no
other defined use; they are ignored by code generation and optimization.</p>
</div>
</div>
<div class="section" id="llvm-trap-intrinsic">
<h4><a class="toc-backref" href="#id1536">&#8216;<code class="docutils literal"><span class="pre">llvm.trap</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-trap-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id617">
<h5><a class="toc-backref" href="#id1537">Syntax:</a><a class="headerlink" href="#id617" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">trap</span><span class="p">()</span> <span class="n">noreturn</span> <span class="n">nounwind</span>
</pre></div>
</div>
</div>
<div class="section" id="id618">
<h5><a class="toc-backref" href="#id1538">Overview:</a><a class="headerlink" href="#id618" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.trap</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id619">
<h5><a class="toc-backref" href="#id1539">Arguments:</a><a class="headerlink" href="#id619" title="永久链接至标题">¶</a></h5>
<p>None.</p>
</div>
<div class="section" id="id620">
<h5><a class="toc-backref" href="#id1540">Semantics:</a><a class="headerlink" href="#id620" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is lowered to the target dependent trap instruction. If
the target does not have a trap instruction, this intrinsic will be
lowered to a call of the <code class="docutils literal"><span class="pre">abort()</span></code> function.</p>
</div>
</div>
<div class="section" id="llvm-debugtrap-intrinsic">
<h4><a class="toc-backref" href="#id1541">&#8216;<code class="docutils literal"><span class="pre">llvm.debugtrap</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-debugtrap-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id621">
<h5><a class="toc-backref" href="#id1542">Syntax:</a><a class="headerlink" href="#id621" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">debugtrap</span><span class="p">()</span> <span class="n">nounwind</span>
</pre></div>
</div>
</div>
<div class="section" id="id622">
<h5><a class="toc-backref" href="#id1543">Overview:</a><a class="headerlink" href="#id622" title="永久链接至标题">¶</a></h5>
<p>The &#8216;<code class="docutils literal"><span class="pre">llvm.debugtrap</span></code>&#8216; intrinsic.</p>
</div>
<div class="section" id="id623">
<h5><a class="toc-backref" href="#id1544">Arguments:</a><a class="headerlink" href="#id623" title="永久链接至标题">¶</a></h5>
<p>None.</p>
</div>
<div class="section" id="id624">
<h5><a class="toc-backref" href="#id1545">Semantics:</a><a class="headerlink" href="#id624" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is lowered to code which is intended to cause an
execution trap with the intention of requesting the attention of a
debugger.</p>
</div>
</div>
<div class="section" id="llvm-stackprotector-intrinsic">
<h4><a class="toc-backref" href="#id1546">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotector</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stackprotector-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id625">
<h5><a class="toc-backref" href="#id1547">Syntax:</a><a class="headerlink" href="#id625" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackprotector</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">guard</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">**</span> <span class="o">&lt;</span><span class="n">slot</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id626">
<h5><a class="toc-backref" href="#id1548">Overview:</a><a class="headerlink" href="#id626" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotector</span></code> intrinsic takes the <code class="docutils literal"><span class="pre">guard</span></code> and stores it
onto the stack at <code class="docutils literal"><span class="pre">slot</span></code>. The stack slot is adjusted to ensure that it
is placed on the stack before local variables.</p>
</div>
<div class="section" id="id627">
<h5><a class="toc-backref" href="#id1549">Arguments:</a><a class="headerlink" href="#id627" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotector</span></code> intrinsic requires two pointer arguments.
The first argument is the value loaded from the stack guard
<code class="docutils literal"><span class="pre">&#64;__stack_chk_guard</span></code>. The second variable is an <code class="docutils literal"><span class="pre">alloca</span></code> that has
enough space to hold the value of the guard.</p>
</div>
<div class="section" id="id628">
<h5><a class="toc-backref" href="#id1550">Semantics:</a><a class="headerlink" href="#id628" title="永久链接至标题">¶</a></h5>
<p>This intrinsic causes the prologue/epilogue inserter to force the position of
the <code class="docutils literal"><span class="pre">AllocaInst</span></code> stack slot to be before local variables on the stack. This is
to ensure that if a local variable on the stack is overwritten, it will destroy
the value of the guard. When the function exits, the guard on the stack is
checked against the original guard by <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code>. If they are
different, then <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code> causes the program to abort by
calling the <code class="docutils literal"><span class="pre">__stack_chk_fail()</span></code> function.</p>
</div>
</div>
<div class="section" id="llvm-stackprotectorcheck-intrinsic">
<h4><a class="toc-backref" href="#id1551">&#8216;<code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-stackprotectorcheck-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id629">
<h5><a class="toc-backref" href="#id1552">Syntax:</a><a class="headerlink" href="#id629" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">stackprotectorcheck</span><span class="p">(</span><span class="n">i8</span><span class="o">**</span> <span class="o">&lt;</span><span class="n">guard</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id630">
<h5><a class="toc-backref" href="#id1553">Overview:</a><a class="headerlink" href="#id630" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code> intrinsic compares <code class="docutils literal"><span class="pre">guard</span></code> against an already
created stack protector and if they are not equal calls the
<code class="docutils literal"><span class="pre">__stack_chk_fail()</span></code> function.</p>
</div>
<div class="section" id="id631">
<h5><a class="toc-backref" href="#id1554">Arguments:</a><a class="headerlink" href="#id631" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.stackprotectorcheck</span></code> intrinsic requires one pointer argument, the
the variable <code class="docutils literal"><span class="pre">&#64;__stack_chk_guard</span></code>.</p>
</div>
<div class="section" id="id632">
<h5><a class="toc-backref" href="#id1555">Semantics:</a><a class="headerlink" href="#id632" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is provided to perform the stack protector check by comparing
<code class="docutils literal"><span class="pre">guard</span></code> with the stack slot created by <code class="docutils literal"><span class="pre">llvm.stackprotector</span></code> and if the
values do not match call the <code class="docutils literal"><span class="pre">__stack_chk_fail()</span></code> function.</p>
<p>The reason to provide this as an IR level intrinsic instead of implementing it
via other IR operations is that in order to perform this operation at the IR
level without an intrinsic, one would need to create additional basic blocks to
handle the success/failure cases. This makes it difficult to stop the stack
protector check from disrupting sibling tail calls in Codegen. With this
intrinsic, we are able to generate the stack protector basic blocks late in
codegen after the tail call decision has occurred.</p>
</div>
</div>
<div class="section" id="llvm-objectsize-intrinsic">
<h4><a class="toc-backref" href="#id1556">&#8216;<code class="docutils literal"><span class="pre">llvm.objectsize</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-objectsize-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id633">
<h5><a class="toc-backref" href="#id1557">Syntax:</a><a class="headerlink" href="#id633" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">objectsize</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="nb">min</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">objectsize</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="nb">object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="nb">min</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id634">
<h5><a class="toc-backref" href="#id1558">Overview:</a><a class="headerlink" href="#id634" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> intrinsic is designed to provide information to
the optimizers to determine at compile time whether a) an operation
(like memcpy) will overflow a buffer that corresponds to an object, or
b) that a runtime check for overflow isn&#8217;t necessary. An object in this
context means an allocation of a specific class, structure, array, or
other object.</p>
</div>
<div class="section" id="id635">
<h5><a class="toc-backref" href="#id1559">Arguments:</a><a class="headerlink" href="#id635" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> intrinsic takes two arguments. The first
argument is a pointer to or into the <code class="docutils literal"><span class="pre">object</span></code>. The second argument is
a boolean and determines whether <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> returns 0 (if true)
or -1 (if false) when the object size is unknown. The second argument
only accepts constants.</p>
</div>
<div class="section" id="id636">
<h5><a class="toc-backref" href="#id1560">Semantics:</a><a class="headerlink" href="#id636" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> intrinsic is lowered to a constant representing
the size of the object concerned. If the size cannot be determined at
compile time, <code class="docutils literal"><span class="pre">llvm.objectsize</span></code> returns <code class="docutils literal"><span class="pre">i32/i64</span> <span class="pre">-1</span> <span class="pre">or</span> <span class="pre">0</span></code> (depending
on the <code class="docutils literal"><span class="pre">min</span></code> argument).</p>
</div>
</div>
<div class="section" id="llvm-expect-intrinsic">
<h4><a class="toc-backref" href="#id1561">&#8216;<code class="docutils literal"><span class="pre">llvm.expect</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-expect-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id637">
<h5><a class="toc-backref" href="#id1562">Syntax:</a><a class="headerlink" href="#id637" title="永久链接至标题">¶</a></h5>
<p>This is an overloaded intrinsic. You can use <code class="docutils literal"><span class="pre">llvm.expect</span></code> on any
integer bit width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">i1</span><span class="p">(</span><span class="n">i1</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">expected_val</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">i32</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">expected_val</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="n">val</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i64</span> <span class="o">&lt;</span><span class="n">expected_val</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id638">
<h5><a class="toc-backref" href="#id1563">Overview:</a><a class="headerlink" href="#id638" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.expect</span></code> intrinsic provides information about expected (the
most probable) value of <code class="docutils literal"><span class="pre">val</span></code>, which can be used by optimizers.</p>
</div>
<div class="section" id="id639">
<h5><a class="toc-backref" href="#id1564">Arguments:</a><a class="headerlink" href="#id639" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.expect</span></code> intrinsic takes two arguments. The first argument is
a value. The second argument is an expected value, this needs to be a
constant value, variables are not allowed.</p>
</div>
<div class="section" id="id640">
<h5><a class="toc-backref" href="#id1565">Semantics:</a><a class="headerlink" href="#id640" title="永久链接至标题">¶</a></h5>
<p>This intrinsic is lowered to the <code class="docutils literal"><span class="pre">val</span></code>.</p>
</div>
</div>
<div class="section" id="llvm-assume-intrinsic">
<span id="int-assume"></span><h4><a class="toc-backref" href="#id1566">&#8216;<code class="docutils literal"><span class="pre">llvm.assume</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-assume-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id641">
<h5><a class="toc-backref" href="#id1567">Syntax:</a><a class="headerlink" href="#id641" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">assume</span><span class="p">(</span><span class="n">i1</span> <span class="o">%</span><span class="n">cond</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id642">
<h5><a class="toc-backref" href="#id1568">Overview:</a><a class="headerlink" href="#id642" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.assume</span></code> allows the optimizer to assume that the provided
condition is true. This information can then be used in simplifying other parts
of the code.</p>
</div>
<div class="section" id="id643">
<h5><a class="toc-backref" href="#id1569">Arguments:</a><a class="headerlink" href="#id643" title="永久链接至标题">¶</a></h5>
<p>The condition which the optimizer may assume is always true.</p>
</div>
<div class="section" id="id644">
<h5><a class="toc-backref" href="#id1570">Semantics:</a><a class="headerlink" href="#id644" title="永久链接至标题">¶</a></h5>
<p>The intrinsic allows the optimizer to assume that the provided condition is
always true whenever the control flow reaches the intrinsic call. No code is
generated for this intrinsic, and instructions that contribute only to the
provided condition are not used for code generation. If the condition is
violated during execution, the behavior is undefined.</p>
<p>Note that the optimizer might limit the transformations performed on values
used by the <code class="docutils literal"><span class="pre">llvm.assume</span></code> intrinsic in order to preserve the instructions
only used to form the intrinsic&#8217;s input argument. This might prove undesirable
if the extra information provided by the <code class="docutils literal"><span class="pre">llvm.assume</span></code> intrinsic does not cause
sufficient overall improvement in code quality. For this reason,
<code class="docutils literal"><span class="pre">llvm.assume</span></code> should not be used to document basic mathematical invariants
that the optimizer can otherwise deduce or facts that are of little use to the
optimizer.</p>
</div>
</div>
<div class="section" id="llvm-bitset-test-intrinsic">
<span id="bitset-test"></span><h4><a class="toc-backref" href="#id1571">&#8216;<code class="docutils literal"><span class="pre">llvm.bitset.test</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-bitset-test-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id645">
<h5><a class="toc-backref" href="#id1572">Syntax:</a><a class="headerlink" href="#id645" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">bitset</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="n">ptr</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">%</span><span class="n">bitset</span><span class="p">)</span> <span class="n">nounwind</span> <span class="n">readnone</span>
</pre></div>
</div>
</div>
<div class="section" id="id646">
<h5><a class="toc-backref" href="#id1573">Arguments:</a><a class="headerlink" href="#id646" title="永久链接至标题">¶</a></h5>
<p>The first argument is a pointer to be tested. The second argument is a
metadata object representing an identifier for a <a class="reference internal" href="BitSets.html"><span class="doc">bitset</span></a>.</p>
</div>
<div class="section" id="id647">
<h5><a class="toc-backref" href="#id1574">Overview:</a><a class="headerlink" href="#id647" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.bitset.test</span></code> intrinsic tests whether the given pointer is a
member of the given bitset.</p>
</div>
</div>
<div class="section" id="llvm-donothing-intrinsic">
<h4><a class="toc-backref" href="#id1575">&#8216;<code class="docutils literal"><span class="pre">llvm.donothing</span></code>&#8216; Intrinsic</a><a class="headerlink" href="#llvm-donothing-intrinsic" title="永久链接至标题">¶</a></h4>
<div class="section" id="id648">
<h5><a class="toc-backref" href="#id1576">Syntax:</a><a class="headerlink" href="#id648" title="永久链接至标题">¶</a></h5>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">donothing</span><span class="p">()</span> <span class="n">nounwind</span> <span class="n">readnone</span>
</pre></div>
</div>
</div>
<div class="section" id="id649">
<h5><a class="toc-backref" href="#id1577">Overview:</a><a class="headerlink" href="#id649" title="永久链接至标题">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">llvm.donothing</span></code> intrinsic doesn&#8217;t perform any operation. It&#8217;s one of only
two intrinsics (besides <code class="docutils literal"><span class="pre">llvm.experimental.patchpoint</span></code>) that can be called
with an invoke instruction.</p>
</div>
<div class="section" id="id650">
<h5><a class="toc-backref" href="#id1578">Arguments:</a><a class="headerlink" href="#id650" title="永久链接至标题">¶</a></h5>
<p>None.</p>
</div>
<div class="section" id="id651">
<h5><a class="toc-backref" href="#id1579">Semantics:</a><a class="headerlink" href="#id651" title="永久链接至标题">¶</a></h5>
<p>This intrinsic does nothing, and it&#8217;s removed by optimizers and ignored
by codegen.</p>
</div>
</div>
</div>
<div class="section" id="stack-map-intrinsics">
<h3><a class="toc-backref" href="#id1580">Stack Map Intrinsics</a><a class="headerlink" href="#stack-map-intrinsics" title="永久链接至标题">¶</a></h3>
<p>LLVM provides experimental intrinsics to support runtime patching
mechanisms commonly desired in dynamic language JITs. These intrinsics
are described in <a class="reference internal" href="StackMaps.html"><span class="doc">Stack maps and patch points in LLVM</span></a>.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="CMake.html" title="Building LLVM with CMake"
             >下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="概述"
             >上一页</a> |</li>
  <li><a href="http://llvm.org/">LLVM 官网</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">LLVM 中文文档</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; 版权所有 2003-2016, LLVM Project.
      最后更新于 2016-04-18.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1 创建。
    </div>

  </body>
</html>